---
title: "Descriptive adventures"
author: "Verooo"
date: "2024-11-08"
output: html_document
---

```{r, globalsettings, echo=FALSE, warning=FALSE, results='hide'}
library(knitr)

knitr::opts_chunk$set(echo = TRUE)
opts_chunk$set(tidy.opts=list(width.cutoff=100),tidy=TRUE, warning = FALSE, message = FALSE,comment = "#>", cache=TRUE, class.source=c("test"), class.output=c("test2"))
options(width = 100)
rgl::setupKnitr()

colorize <- function(x, color) {sprintf("<span style='color: %s;'>%s</span>", color, x) }

```

```{r klippy, echo=FALSE, include=FALSE}
klippy::klippy(position = c('top', 'right'))
#klippy::klippy(color = 'darkred')
#klippy::klippy(tooltip_message = 'Click to copy', tooltip_success = 'Done')
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

```

# Getting started

```{r clean}
rm(list = ls())
```

## Packages

```{r package}
require(tidyverse)
require(RSiena)
require(RsienaTwoStep)

#install.packages("data.table")
require(data.table)  # mainly for faster data handling
# install.packages('xml2')
require(xml2)
# install.packages('rvest')
require(rvest)
require(igraph)

require(ggraph)
#install.packages('visNetwork')
require(visNetwork)
#install.packages('threejs')
require(threejs)
#install.packages('networkD3')
require(networkD3)


```

## Functions

```{r functions 1}
fpackage.check <- function(packages) {
    lapply(packages, FUN = function(x) {
        if (!require(x, character.only = TRUE)) {
            install.packages(x, dependencies = TRUE)
            library(x, character.only = TRUE)
        }
    })
}

fsave <- function(x, file = NULL, location = "./data/processed/") {
    ifelse(!dir.exists("data"), dir.create("data"), FALSE)
    ifelse(!dir.exists("data/processed"), dir.create("data/processed"), FALSE)
    if (is.null(file))
        file = deparse(substitute(x))
    datename <- substr(gsub("[:-]", "", Sys.time()), 1, 8)
    totalname <- paste(location, file, "_", datename, ".rda", sep = "")
    save(x, file = totalname)  #need to fix if file is reloaded as input name, not as x. 
}

fload <- function(filename) {
    load(filename)
    get(ls()[ls() != "filename"])
}

fshowdf <- function(x, ...) {
    knitr::kable(x, digits = 2, "html", ...) %>%
        kableExtra::kable_styling(bootstrap_options = c("striped", "hover")) %>%
        kableExtra::scroll_box(width = "100%", height = "300px")
}


# this is the most important one. We created it in the previous script

f_pubnets <- function(df_scholars = df, list_publications = publications, discip = "sociology"+"political science", affiliation = "RU",
    waves = list(wave1 = c(2018, 2019, 2020), wave2 = c(2021, 2022, 2023))) {

    publications <- list_publications %>%
        bind_rows() %>%
        distinct(title, .keep_all = TRUE)

    df_scholars %>%
        filter(affil1 == affiliation | affil2 == affiliation) %>%
        filter(discipline == discip) -> df_sel

    networklist <- list()
    for (wave in 1:length(waves)) {
        networklist[[wave]] <- matrix(0, nrow = nrow(df_sel), ncol = nrow(df_sel))
    }

    publicationlist <- list()
    for (wave in 1:length(waves)) {
        publicationlist[[wave]] <- publications %>%
            filter(gs_id %in% df_sel$gs_id) %>%
            filter(year %in% waves[[wave]]) %>%
            select(author) %>%
            lapply(str_split, pattern = ",")
    }

    publicationlist2 <- list()
    for (wave in 1:length(waves)) {
        publicationlist2[[wave]] <- publicationlist[[wave]]$author %>%
            # lowercase
        lapply(tolower) %>%
            # Removing diacritics
        lapply(stri_trans_general, id = "latin-ascii") %>%
            # only last name
        lapply(word, start = -1, sep = " ") %>%
            # only last last name
        lapply(word, start = -1, sep = "-")
    }

    for (wave in 1:length(waves)) {
        # let us remove all publications with only one author
        remove <- which(sapply(publicationlist2[[wave]], FUN = function(x) length(x) == 1) == TRUE)
        publicationlist2[[wave]] <- publicationlist2[[wave]][-remove]
    }

    for (wave in 1:length(waves)) {
        pubs <- publicationlist2[[wave]]
        for (ego in 1:nrow(df_sel)) {
            # which ego?
            lastname_ego <- df_sel$lastname[ego]
            # for all publications
            for (pub in 1:length(pubs)) {
                # only continue if ego is author of pub
                if (lastname_ego %in% pubs[[pub]]) {
                  aut_pot <- which.max(pubs[[pub]] %in% lastname_ego)
                  # only continue if ego is first author of pub
                  if (aut_pot == 1) {
                    # check all alters/co-authors
                    for (alter in 1:nrow(df_sel)) {
                      # which alter
                      lastname_alter <- df_sel$lastname[alter]
                      if (lastname_alter %in% pubs[[pub]]) {
                        networklist[[wave]][ego, alter] <- networklist[[wave]][ego, alter] + 1
                      }
                    }
                  }
                }
            }
        }
    }
    return(list(df = df_sel, network = networklist))
}

```

## More functions

```{r functions 2}
fcolnet <- function(data = scholars, university = "RU", discipline = "sociology"+"political science", waves = list(c(2015,
    2018), c(2019, 2023)), type = c("first")) {

    # step 1
    demographics <- do.call(rbind.data.frame, data$demographics)
    demographics <- demographics %>%
        mutate(Universiteit1.22 = replace(Universiteit1.22, is.na(Universiteit1.22), ""), Universiteit2.22 = replace(Universiteit2.22,
            is.na(Universiteit2.22), ""), Universiteit1.24 = replace(Universiteit1.24, is.na(Universiteit1.24),
            ""), Universiteit2.24 = replace(Universiteit2.24, is.na(Universiteit2.24), ""), discipline.22 = replace(discipline.22,
            is.na(discipline.22), ""), discipline.24 = replace(discipline.24, is.na(discipline.24), ""))

    sample <- which((demographics$Universiteit1.22 %in% university | demographics$Universiteit2.22 %in%
        university | demographics$Universiteit1.24 %in% university | demographics$Universiteit2.24 %in%
        university) & (demographics$discipline.22 %in% discipline | demographics$discipline.24 %in% discipline))

    demographics_soc <- demographics[sample, ]
    scholars_sel <- lapply(scholars, "[", sample)

    # step 2
    ids <- demographics_soc$au_id
    nwaves <- length(waves)
    nets <- array(0, dim = c(nwaves, length(ids), length(ids)), dimnames = list(wave = 1:nwaves, ids,
        ids))
    dimnames(nets)

    # step 3
    df_works <- tibble(works_id = unlist(lapply(scholars_sel$work, function(l) l$id)), works_author = unlist(lapply(scholars_sel$work,
        function(l) l$author), recursive = FALSE), works_year = unlist(lapply(scholars_sel$work, function(l) l$publication_year),
        recursive = FALSE))

    df_works <- df_works[!duplicated(df_works), ]

    # step 4
    if (type == "first") {
        for (j in 1:nwaves) {
            df_works_w <- df_works[df_works$works_year >= waves[[j]][1] & df_works$works_year <= waves[[j]][2],
                ]
            for (i in 1:nrow(df_works_w)) {
                ego <- df_works_w$works_author[i][[1]]$au_id[1]
                alters <- df_works_w$works_author[i][[1]]$au_id[-1]
                if (sum(ids %in% ego) > 0 & sum(ids %in% alters) > 0) {
                  nets[j, which(ids %in% ego), which(ids %in% alters)] <- 1
                }
            }
        }
    }

    if (type == "last") {
        for (j in 1:nwaves) {
            df_works_w <- df_works[df_works$works_year >= waves[[j]][1] & df_works$works_year <= waves[[j]][2],
                ]
            for (i in 1:nrow(df_works_w)) {
                ego <- rev(df_works_w$works_author[i][[1]]$au_id)[1]
                alters <- rev(df_works_w$works_author[i][[1]]$au_id)[-1]
                if (sum(ids %in% ego) > 0 & sum(ids %in% alters) > 0) {
                  nets[j, which(ids %in% ego), which(ids %in% alters)] <- 1
                }
            }
        }
    }

    if (type == "all") {
        for (j in 1:nwaves) {
            df_works_w <- df_works[df_works$works_year >= waves[[j]][1] & df_works$works_year <= waves[[j]][2],
                ]
            for (i in 1:nrow(df_works_w)) {
                egos <- df_works_w$works_author[i][[1]]$au_id
                if (sum(ids %in% egos) > 0) {
                  nets[j, which(ids %in% egos), which(ids %in% egos)] <- 1
                }
            }
        }
    }
    output <- list()
    output$data <- scholars_sel
    output$nets <- nets
    return(output)
}
```

## Load data

Scholar

```{r scholar data}
scholars <- fload("./data/processed/scholars_20240924.rda") 
#make sure to lead fload first of course
```

```{r saving schoalr output}
# save the output of your function

test  <- fcolnet(data = scholars, 
                university = "RU", 
                discipline = c("sociology", "political science"),
                waves = list(c(2015, 2018), c(2019, 2023)), 
                type = c("all")) # all, first, last # which ties in there

# USE not all but first or last so the ties are directed from "perspective" of first author of the publications 
# usually first author has most prestige
```

Ego

```{r df_ego data}
df_ego <- fload("./data/processed/df_ego_20241108.rda")
```

```{r matrix data ego}

test_w1 <- igraph::graph_from_adjacency_matrix(
  test$nets[1,,], # first wave of data. 
  # (thus I select the array of networks and take the first matrix)
  mode = c("directed"),
  weighted = NULL,
  diag = FALSE,
  add.colnames = NULL,
  add.rownames = NULL)

```

# Descriptives

## Ego level

### Gender

-   Gender

    -   descriptives (mean etc.)

```{r sum gender}
summary(df_ego$gender)

```

    -   overall

```{r hist gender}
# Histogram of prestige scores for Wave 1  
hist(df_ego$gender, breaks = , main = "Distribution of gender",     xlab = "Gender", ylab = "Frequency", col = "#B3DE69") # INSERT YEARS OF WAVE/TIME FRAME STILL
```

```         
-   Gender per department
```

```{r gender per dep.}
# STILL DO 
```

### h index

```         
-   descriptives (mean etc.)
```

```{r sum h index}
summary(df_ego$h_index) 
```

```         
- Overall  (INSERT YEARS STILL)
```

```{r hist h index}

# Histogram of prestige scores for Wave 1 
hist(df_ego$h_index, breaks = 30, main = "Distribution of H-Index from yearX to yearX",     xlab = "H Index", ylab = "Frequency", col = "#B3DE69") # INSERT YEARS OF WAVE/TIME FRAME STILL
```

```         
-   H index per department
```

```{r h index per dep.}
# STILL DO 
```

## Ego network

### basic descriptives

-   Nr. of nodes

```{r nodes}
vcount(test_w1)
```

-   Nr. of edges

```{r edges}
ecount(test_w1)
```

-   Dyad census

    ```{r dyad cen}
    # still do 
    ```

-   Triad-census

    ```{r triad cen}
    # still do 
    ```

-   edge-density

    ```{r edge dens}
    #still do 
    ```

### more indepth:

-   reciprocity

    ```{r recip}
    #still do 
    ```

-   degree centrality / degreee?

    ```{r degree}
    # still do 
    ```

-   Betweenness centrality /betweenness?

    ```{r betweenness}
    #still do 
    ```

-   Clustering

    ```{r clustering}
    #still do 
    ```

## Network-level descriptives

-   Density

    ```{r density}
    #still do 
    ```

-   Average path length

    ```{r path length}
    # still do 
    ```

-   Segregation

    -   Mortons I
    -   igraphs
    -   ggraphs

```{r plot}

plot(test_w1,
     vertex.label = NA,
     edge.width = 0.2,
     edge.arrow.size =0.2)
```

```{r plot gender}
names(df_ego) #see labels of variables 


plot(test_w1,
vertex.color = ifelse(df_ego$gender == 1, "#FB8072", "#80B1D3"), # now, I can use actor attributes for plotting.
# here: if gender = 1 (aka man) then red dot, if not then blue 
vertex.label = NA,
edge.width = 0.2,
edge.arrow.size =0.2)

# if you dont want plot to turn, save the layout (look at SNASS)


```

# Detour: Colors

```{r mypalette, include = FALSE, eval = FALSE}
# palette i like:
palette("Set 3");  sinplot("Set 3")
palette.swatch("Set 3")
palette.colors(palette = "Set 3")
 "#8DD3C7" "#FFFFB3" "#BEBADA" "#FB8072" "#80B1D3" "#FDB462"
 "#B3DE69" "#FCCDE5" "#D9D9D9" "#BC80BD" "#CCEBC5" "#FFED6F"
```


```{r colors in R, include = FALSE, eval = FALSE}
colors (distinct = TRUE) # prints all colors R knows
palette.pals()
#  [1] "R3"              "R4"              "ggplot2"        
#  [4] "Okabe-Ito"       "Accent"          "Dark 2"         
#  [7] "Paired"          "Pastel 1"        "Pastel 2"       
# [10] "Set 1"           "Set 2"           "Set 3"          
# [13] "Tableau 10"      "Classic Tableau" "Polychrome 36"  
# [16] "Alphabet"       

palette.colors(palette = "-palette name here-")
# [1] "#000000" "#E69F00" "#56B4E9" "#009E73" "#F0E442" "#0072B2"
# [7] "#D55E00" "#CC79A7" "#999999"
```


```{r look at colors PLOT, include = FALSE, eval = FALSE}
## Demonstrate the colors 1:8 in different palettes using a custom matplot()
sinplot <- function(main=NULL, n = 8) {
    x <- outer(
	seq(-pi, pi, length.out = 50),
	seq(  0, pi, length.out = n),
	function(x, y) sin(x - y)
    )
    matplot(x, type = "l", lwd = 4, lty = 1, col = 1:n, ylab = "", main=main)
}
sinplot("default palette")

palette("R3");        sinplot("R3")
palette("Okabe-Ito"); sinplot("Okabe-Ito")
palette("Tableau")  ; sinplot("Tableau", n = 10) # i like 
palROB <- colorRampPalette(c("red", "darkorange2", "blue"), space = "Lab")
palette(palROB(16)); sinplot("palROB(16)", n = 16) # the orange purple blue rainbow retro vibe yay 
palette("default") # reset
```


```{r look at colors SWATCH, include = FALSE, eval = FALSE}
palette.swatch <- function(palette = palette.pals(), n = 8, nrow = 8,
                           border = "black", cex = 1, ...)
{
     cols <- sapply(palette, palette.colors, n = n, recycle = TRUE)
     ncol <- ncol(cols)
     nswatch <- min(ncol, nrow)
     op <- par(mar = rep(0.1, 4),
               mfrow = c(1, min(5, ceiling(ncol/nrow))),
     	       cex = cex, ...)
     on.exit(par(op))
     while (length(palette)) {
 	subset <- seq_len(min(nrow, ncol(cols)))
 	plot.new()
 	plot.window(c(0, n), c(0.25, nrow + 0.25))
 	y <- rev(subset)
 	text(0, y + 0.1, palette[subset], adj = c(0, 0))
 	y <- rep(y, each = n)
 	rect(rep(0:(n-1), n), y, rep(1:n, n), y - 0.5,
 	     col = cols[, subset], border = border)
 	palette <- palette[-subset]
 	cols    <- cols [, -subset, drop = FALSE]
     }
}

palette.swatch()

palette.swatch(n = 26) # show full "Alphabet"; recycle most others



```
