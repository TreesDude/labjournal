<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />


<meta name="author" content="Verooo" />

<meta name="date" content="2024-11-20" />

<title>Model estimation</title>

<script src="site_libs/header-attrs-2.28/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/darkly.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.13.2/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<script src="site_libs/navigation-1.1/codefolding.js"></script>
<script src="site_libs/navigation-1.1/sourceembed.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<script src="site_libs/clipboard-1.7.1/clipboard.min.js"></script>
<link href="site_libs/primer-tooltips-1.4.0/build.css" rel="stylesheet" />
<link href="site_libs/klippy-0.0.0.9500/css/klippy.min.css" rel="stylesheet" />
<script src="site_libs/klippy-0.0.0.9500/js/klippy.min.js"></script>
<link href="site_libs/font-awesome-6.4.2/css/all.min.css" rel="stylesheet" />
<link href="site_libs/font-awesome-6.4.2/css/v4-shims.min.css" rel="stylesheet" />

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>




<style type="text/css">
#rmd-source-code {
  display: none;
}
</style>


<link rel="stylesheet" href="styles.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark the anchor link active (and if it's in a dropdown, also mark that active)
  var dropdown = menuAnchor.closest('li.dropdown');
  if (window.bootstrap) { // Bootstrap 4+
    menuAnchor.addClass('active');
    dropdown.find('> .dropdown-toggle').addClass('active');
  } else { // Bootstrap 3
    menuAnchor.parent().addClass('active');
    dropdown.addClass('active');
  }

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before, .tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "\e259";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "\e258";
  font-family: 'Glyphicons Halflings';
  border: none;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->
<style type="text/css">
.code-folding-btn { margin-bottom: 4px; }
</style>



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html"></a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">
    <span class="fa fa-home"></span>
     
  </a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    My journal
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="testjt.html">Week 1</a>
    </li>
    <li>
      <a href="week2.html">Week 2</a>
    </li>
    <li>
      <a href="Webscraping-Chapter8-tutorial.html">Chapter 8 - Webscraping tutorial</a>
    </li>
    <li>
      <a href="week3RSelenium.html">Week 3 - RSelenium (see Ch.8 tab tho)</a>
    </li>
    <li>
      <a href="networkvis.html">Chapter 9 - Netw. Visualisation tutorial</a>
    </li>
    <li>
      <a href="week5.html">Week 5/Chapter 7 - Analysis pt.1</a>
    </li>
    <li>
      <a href="week5-2.html">!Week 5/Chapter 7 - Analysis pt.2</a>
    </li>
    <li>
      <a href="datapractice1.html">Week 5 - Practice data 1</a>
    </li>
    <li>
      <a href="week6.html">Week 6</a>
    </li>
    <li>
      <a href="weekbacktrack.html">Week Nr. getbackontrack</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    RQs
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="RQdraft1.html">1st draft</a>
    </li>
    <li>
      <a href="RQdraft2.html">2nd draft - w Intro &amp; data types</a>
    </li>
    <li>
      <a href="RQdraft3.html">3rd draft</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Project design
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="clarifyRQsandDesign.html">Clarify RQs</a>
    </li>
    <li>
      <a href="plotting1.html">Plotting</a>
    </li>
    <li>
      <a href="revisitwithJochem.html">Check-in with Jochem</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Step-by-step analysis
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="datapreptrynew.html">Data prep</a>
    </li>
    <li>
      <a href="descriptivestry.html">Step 3: initial description</a>
    </li>
    <li>
      <a href="RSienatry.html">Step 4&amp;5: Specify &amp; Estimate model</a>
    </li>
    <li>
      <a href="estimate_M0.html">Test estimate display</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Draft report
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="draftintro.html">Introduction</a>
    </li>
    <li>
      <a href="drafttheory.html">Theory</a>
    </li>
    <li class="dropdown-submenu">
      <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">Data</a>
      <ul class="dropdown-menu" role="menu">
        <li>
          <a href="draftdata.html">Data &amp; Methods</a>
        </li>
        <li>
          <a href="datapreptrynew.html">Data preparation</a>
        </li>
        <li>
          <a href="descriptivestry.html">Descriptives</a>
        </li>
      </ul>
    </li>
    <li class="dropdown-submenu">
      <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">Results</a>
      <ul class="dropdown-menu" role="menu">
        <li>
          <a href="draftdesresults.html">Descriptive results</a>
        </li>
        <li>
          <a href="modelestimate.html">Model Estimation</a>
        </li>
        <li>
          <a href="draftGOF.html">Goodness Of Fit</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="draftdiscussion.html">Discussion &amp; Conclusion</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Final report
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="finalintro.html">Introduction</a>
    </li>
    <li>
      <a href="finaltheory.html">Theory</a>
    </li>
    <li class="dropdown-submenu">
      <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">Data</a>
      <ul class="dropdown-menu" role="menu">
        <li>
          <a href="finaldata.html">Data &amp; Methods</a>
        </li>
        <li>
          <a href="finaldataprep.html">Data preparation</a>
        </li>
        <li>
          <a href="finaldescriptives.html">Descriptives</a>
        </li>
      </ul>
    </li>
    <li class="dropdown-submenu">
      <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">Results</a>
      <ul class="dropdown-menu" role="menu">
        <li>
          <a href="finaldesresults.html">Descriptive results</a>
        </li>
        <li>
          <a href="finalestimate.html">Model Estimation</a>
        </li>
        <li>
          <a href="finalGOF.html">Goodness Of Fit</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="finaldiscussion.html">Discussion &amp; Conclusion</a>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/JochemTolsma/labjournal">
    <span class="fab fa-github"></span>
     
  </a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">

<div class="btn-group pull-right float-right">
<button type="button" class="btn btn-default btn-xs btn-secondary btn-sm dropdown-toggle" data-toggle="dropdown" data-bs-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><span>Code</span> <span class="caret"></span></button>
<ul class="dropdown-menu dropdown-menu-right" style="min-width: 50px;">
<li><a id="rmd-show-all-code" href="#">Show All Code</a></li>
<li><a id="rmd-hide-all-code" href="#">Hide All Code</a></li>
<li role="separator" class="divider"></li>
<li><a id="rmd-download-source" href="#">Download Rmd</a></li>
</ul>
</div>



<h1 class="title toc-ignore">Model estimation</h1>
<h4 class="author">Verooo</h4>
<h4 class="date">2024-11-20</h4>

</div>


<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
My Descriptives
</title>
<p><link rel="stylesheet" href="styles.css">
<!-- Link to the CSS file I created for dark mode code chunks --></p>
</head>
</html>
<script>
  addClassKlippyTo("pre.r, pre.markdown");
  addKlippy('right', 'top', 'auto', '1', 'Copy code', 'Copied!');
</script>
<div id="setup" class="section level1" number="1">
<h1><span class="header-section-number">1</span> Setup</h1>
<p>Clean workspace. As always.</p>
<pre class="r test"><code>rm(list = ls())</code></pre>
<div id="packages" class="section level2" number="1.1">
<h2><span class="header-section-number">1.1</span> Packages</h2>
<pre class="r test"><code>require(tidyverse)
require(RSiena)
require(RsienaTwoStep)

# install.packages(&#39;data.table&#39;)
require(data.table)  # mainly for faster data handling
# install.packages(&#39;xml2&#39;)
require(xml2)
# install.packages(&#39;rvest&#39;)
require(rvest)
require(igraph)
require(ggraph)


# install.packages(&#39;visNetwork&#39;)
require(visNetwork)
# install.packages(&#39;threejs&#39;)
require(threejs)
# install.packages(&#39;networkD3&#39;)
require(networkD3)</code></pre>
</div>
<div id="functions" class="section level2" number="1.2">
<h2><span class="header-section-number">1.2</span> Functions</h2>
<p>Functions chunk:</p>
<pre class="r test"><code>fpackage.check &lt;- function(packages) {
    lapply(packages, FUN = function(x) {
        if (!require(x, character.only = TRUE)) {
            install.packages(x, dependencies = TRUE)
            library(x, character.only = TRUE)
        }
    })
}

fsave &lt;- function(x, file = NULL, location = &quot;./data/processed/&quot;) {
    ifelse(!dir.exists(&quot;data&quot;), dir.create(&quot;data&quot;), FALSE)
    ifelse(!dir.exists(&quot;data/processed&quot;), dir.create(&quot;data/processed&quot;), FALSE)
    if (is.null(file))
        file = deparse(substitute(x))
    datename &lt;- substr(gsub(&quot;[:-]&quot;, &quot;&quot;, Sys.time()), 1, 8)
    totalname &lt;- paste(location, file, &quot;_&quot;, datename, &quot;.rda&quot;, sep = &quot;&quot;)
    save(x, file = totalname)  #need to fix if file is reloaded as input name, not as x. 
}

fload &lt;- function(filename) {
    load(filename)
    get(ls()[ls() != &quot;filename&quot;])
}

fshowdf &lt;- function(x, ...) {
    knitr::kable(x, digits = 2, &quot;html&quot;, ...) %&gt;%
        kableExtra::kable_styling(bootstrap_options = c(&quot;striped&quot;, &quot;hover&quot;)) %&gt;%
        kableExtra::scroll_box(width = &quot;100%&quot;, height = &quot;300px&quot;)
}


# this is the most important one. We created it in the previous script

f_pubnets &lt;- function(df_scholars = df, list_publications = publications, discip = &quot;sociology&quot; + &quot;political science&quot;,
    affiliation = &quot;RU&quot;, waves = list(wave1 = c(2018, 2019, 2020), wave2 = c(2021, 2022, 2023))) {

    publications &lt;- list_publications %&gt;%
        bind_rows() %&gt;%
        distinct(title, .keep_all = TRUE)

    df_scholars %&gt;%
        filter(affil1 == affiliation | affil2 == affiliation) %&gt;%
        filter(discipline == discip) -&gt; df_sel

    networklist &lt;- list()
    for (wave in 1:length(waves)) {
        networklist[[wave]] &lt;- matrix(0, nrow = nrow(df_sel), ncol = nrow(df_sel))
    }

    publicationlist &lt;- list()
    for (wave in 1:length(waves)) {
        publicationlist[[wave]] &lt;- publications %&gt;%
            filter(gs_id %in% df_sel$gs_id) %&gt;%
            filter(year %in% waves[[wave]]) %&gt;%
            select(author) %&gt;%
            lapply(str_split, pattern = &quot;,&quot;)
    }

    publicationlist2 &lt;- list()
    for (wave in 1:length(waves)) {
        publicationlist2[[wave]] &lt;- publicationlist[[wave]]$author %&gt;%
            # lowercase
        lapply(tolower) %&gt;%
            # Removing diacritics
        lapply(stri_trans_general, id = &quot;latin-ascii&quot;) %&gt;%
            # only last name
        lapply(word, start = -1, sep = &quot; &quot;) %&gt;%
            # only last last name
        lapply(word, start = -1, sep = &quot;-&quot;)
    }

    for (wave in 1:length(waves)) {
        # let us remove all publications with only one author
        remove &lt;- which(sapply(publicationlist2[[wave]], FUN = function(x) length(x) == 1) == TRUE)
        publicationlist2[[wave]] &lt;- publicationlist2[[wave]][-remove]
    }

    for (wave in 1:length(waves)) {
        pubs &lt;- publicationlist2[[wave]]
        for (ego in 1:nrow(df_sel)) {
            # which ego?
            lastname_ego &lt;- df_sel$lastname[ego]
            # for all publications
            for (pub in 1:length(pubs)) {
                # only continue if ego is author of pub
                if (lastname_ego %in% pubs[[pub]]) {
                  aut_pot &lt;- which.max(pubs[[pub]] %in% lastname_ego)
                  # only continue if ego is first author of pub
                  if (aut_pot == 1) {
                    # check all alters/co-authors
                    for (alter in 1:nrow(df_sel)) {
                      # which alter
                      lastname_alter &lt;- df_sel$lastname[alter]
                      if (lastname_alter %in% pubs[[pub]]) {
                        networklist[[wave]][ego, alter] &lt;- networklist[[wave]][ego, alter] + 1
                      }
                    }
                  }
                }
            }
        }
    }
    return(list(df = df_sel, network = networklist))
}</code></pre>
<p>More functions:</p>
<pre class="r test"><code>fcolnet &lt;- function(data = scholars, university = &quot;RU&quot;, discipline = &quot;sociology&quot; + &quot;political science&quot;,
    waves = list(c(2015, 2018), c(2019, 2023)), type = c(&quot;first&quot;)) {

    # step 1
    demographics &lt;- do.call(rbind.data.frame, data$demographics)
    demographics &lt;- demographics %&gt;%
        mutate(Universiteit1.22 = replace(Universiteit1.22, is.na(Universiteit1.22), &quot;&quot;), Universiteit2.22 = replace(Universiteit2.22,
            is.na(Universiteit2.22), &quot;&quot;), Universiteit1.24 = replace(Universiteit1.24, is.na(Universiteit1.24),
            &quot;&quot;), Universiteit2.24 = replace(Universiteit2.24, is.na(Universiteit2.24), &quot;&quot;), discipline.22 = replace(discipline.22,
            is.na(discipline.22), &quot;&quot;), discipline.24 = replace(discipline.24, is.na(discipline.24), &quot;&quot;))

    sample &lt;- which((demographics$Universiteit1.22 %in% university | demographics$Universiteit2.22 %in%
        university | demographics$Universiteit1.24 %in% university | demographics$Universiteit2.24 %in%
        university) &amp; (demographics$discipline.22 %in% discipline | demographics$discipline.24 %in% discipline))

    demographics_soc &lt;- demographics[sample, ]
    scholars_sel &lt;- lapply(scholars, &quot;[&quot;, sample)

    # step 2
    ids &lt;- demographics_soc$au_id
    nwaves &lt;- length(waves)
    nets &lt;- array(0, dim = c(nwaves, length(ids), length(ids)), dimnames = list(wave = 1:nwaves, ids,
        ids))
    dimnames(nets)

    # step 3
    df_works &lt;- tibble(works_id = unlist(lapply(scholars_sel$work, function(l) l$id)), works_author = unlist(lapply(scholars_sel$work,
        function(l) l$author), recursive = FALSE), works_year = unlist(lapply(scholars_sel$work, function(l) l$publication_year),
        recursive = FALSE))

    df_works &lt;- df_works[!duplicated(df_works), ]

    # step 4
    if (type == &quot;first&quot;) {
        for (j in 1:nwaves) {
            df_works_w &lt;- df_works[df_works$works_year &gt;= waves[[j]][1] &amp; df_works$works_year &lt;= waves[[j]][2],
                ]
            for (i in 1:nrow(df_works_w)) {
                ego &lt;- df_works_w$works_author[i][[1]]$au_id[1]
                alters &lt;- df_works_w$works_author[i][[1]]$au_id[-1]
                if (sum(ids %in% ego) &gt; 0 &amp; sum(ids %in% alters) &gt; 0) {
                  nets[j, which(ids %in% ego), which(ids %in% alters)] &lt;- 1
                }
            }
        }
    }

    if (type == &quot;last&quot;) {
        for (j in 1:nwaves) {
            df_works_w &lt;- df_works[df_works$works_year &gt;= waves[[j]][1] &amp; df_works$works_year &lt;= waves[[j]][2],
                ]
            for (i in 1:nrow(df_works_w)) {
                ego &lt;- rev(df_works_w$works_author[i][[1]]$au_id)[1]
                alters &lt;- rev(df_works_w$works_author[i][[1]]$au_id)[-1]
                if (sum(ids %in% ego) &gt; 0 &amp; sum(ids %in% alters) &gt; 0) {
                  nets[j, which(ids %in% ego), which(ids %in% alters)] &lt;- 1
                }
            }
        }
    }

    if (type == &quot;all&quot;) {
        for (j in 1:nwaves) {
            df_works_w &lt;- df_works[df_works$works_year &gt;= waves[[j]][1] &amp; df_works$works_year &lt;= waves[[j]][2],
                ]
            for (i in 1:nrow(df_works_w)) {
                egos &lt;- df_works_w$works_author[i][[1]]$au_id
                if (sum(ids %in% egos) &gt; 0) {
                  nets[j, which(ids %in% egos), which(ids %in% egos)] &lt;- 1
                }
            }
        }
    }
    output &lt;- list()
    output$data &lt;- scholars_sel
    output$nets &lt;- nets
    return(output)
}</code></pre>
</div>
</div>
<div id="get-data" class="section level1" number="2">
<h1><span class="header-section-number">2</span> Get Data</h1>
<p>Load Scholar Data</p>
<pre class="r test"><code>scholars &lt;- fload(&quot;./data/processed/scholars_20240924.rda&quot;)</code></pre>
<p>Save the output of the function.</p>
<pre class="r test"><code># save the output of your function
test &lt;- fcolnet(data = scholars, university = &quot;RU&quot;, discipline = c(&quot;sociology&quot;, &quot;political science&quot;),
    waves = list(c(2015, 2018), c(2019, 2023)), type = c(&quot;first&quot;))</code></pre>
<p>Load Ego Data</p>
</div>
<div id="make-network-data" class="section level1" number="3">
<h1><span class="header-section-number">3</span> Make Network Data</h1>
<pre class="r test"><code># step1 data
wave1 &lt;- test$nets[1, , ]
wave2 &lt;- test$nets[2, , ]

# put nets in an array
net_array &lt;- array(data = c(wave1, wave2), dim = c(dim(wave1), 2))</code></pre>
<hr />
</div>
<div id="analysis" class="section level1" number="4">
<h1><span class="header-section-number">4</span> Analysis</h1>
<!--
## TEST MODEL

### test 1: Define Siena Data & Variables
-->
<!-- Print short descriptive report-->
<!-- ### test 2: Make effects object/structure -->
<!--

e.g. outdegree (density), called density, three things: evaluation,
endowment, and creation you can only include two of the three (tie
creation, breaking and maintaining)

The assumption is: mechanisms to make and break a a tie are the same so
WE ONLY USE THE EVALUATION part

All these effects are described in the manual of RSiena Chapter 12!

-->
<!--  
### Step X: Initial description
-->
<!--
Has a lot of information in there Also: how tie CHANGED Also: Jaccard
index (measure of stability) Also rate parameter and outdegree

<https://www.stats.ox.ac.uk/~snijders/siena/RSiena_Manual.pdf>

In the package RsienaTwoStep there are functions for the following
network statistics ***s*** :

degree: `ts_degree()`

reciprocity: `ts_recip()`

outdegree activity: `ts_outAct()`

indegree activity: `ts_inAct()`

outdegree popularity: `ts_outPop()`

indegree popularity: `ts_inPop()`

transitivity: `ts_transTrip()`

mediated transitivity: `ts_transMedTrip()`

transitive reciprocated triplets: `ts_transRecTrip()`

number of three-cycles: `ts_cycle3()`
-->
<!-- ### test 3: Add Effects -->
<!-- 


hint FOR MY OWN PROJECT: interaction effect of these statistics and the
effect of gender

THE "X" in altX and eogX refer to the "interaction 1" variable, so it's eg. ego x gender_RS and alter x gender_RS!

altX - egos send more ties who have more on gender (aka. gender =1) 
(iiiish look at egoX explanantion, this is basically the same but in "reverse", aka about receiving rather than sending)

-   covariate-alter or covariate-related popularity (altX), defined by
    the sum of the covariate over all actors to whom ***i*** has a tie,
-   same as egoX but RECEIVING ties

egoX - [definition?]

-   covariate-ego or covariate-related activity (egoX), defined by i’s
    out-degree weighted by his covariate value,
-   since male = 1 egoX only "looks at" men's ties 
-   if egoX significant then men's ties sign. diff. based on whether its to a man or woman (look at direction of effect to know which gender) 


"interaction1" HAS NOTHING TO DO WITH AN INTERACTION EFFECT

-   If there are several dependent variables (networks and/or behavioral
    variables), the name of the dependent variable (name) also is
    required to specify the effect, and will be given in the column
    interaction1 (etc.) of the effects object.

-   It should be mentioned that the keywords interaction1, interaction2,
    and interaction3 in functions such as includeEffects do not point to
    interactions between effects. These keywords are used only to
    exactly specify an effect. They point to the covariate or other
    dependent variable used in the effect; this name was chosen for the
    keyword because this other variable may be said to be interacting
    with the dependent variable (network or behavior).

-->
<!-- ### test 4: Specify model/algorithm -->
<!-- ### test 5: Estimate model -->
<!-- 
output:  convergence ration NA probably bc we chose all ties to be included (type = "all") earlier
we can go back and change that or change it here in the myAlgorithm function

convergence ratio should be <.25   !!!
- if above, run model again
- if stays above .25, remove some of the netw. stats
- if close to threshold (e.g. 0.2584) add prevAns = model1  to the siena07 command and rerun then
      model1 <- siena07(myAlgorithm, data = mydata, effects = myeff, prevAns= model1, returnDeps = TRUE)

-->
<!-- ### test 6: GOF - Goodness of Fit -->
<!-- 

Make it a directed network:  ties from "all" to "first"
focus: writing,
model interpretation


### Questions

-   Is the use of RSiena different for people who look at 1 vs 2 waves.
    I need to look at one, made 2 anyways bc RSiena needs waves to do
    it's thing but:\
    Doesn't it look at ministeps over time? How can I interpret the
    output in a way that pertains to only one wave when the process
    seems to consider it within the construct of 'future change'?

    -   How does my model interpretation potentially differ from peeps
        who looked at two waves (or more)?

-   not looking at TWoStep! diff. modelling process. 
RSiena works with ministeps indeed not just Twosteps (that works with two steps lol)


- diff. betweeen wave 1 and wave 2 model -> convergence 
- default recip. and degree: estimates the putput based on a certain reciproc. and degree "assumption"
 
-->
<div id="model-0---null-model" class="section level2" number="4.1">
<h2><span class="header-section-number">4.1</span> &lt;&gt; Model 0 -
Null Model</h2>
<p>First, I estimate a null model with only reciprocity and degree.</p>
<p>The maximum convergence ratio of the model is 0.084. The GOF on the
Indegree Distribution is zero<strong>.</strong> This indicates that the
model is a very bad fit for the data. This is not suprising since we ran
a null model without any network effects.ffects.</p>
<p>For all GOF plots compiled in one place, see here: <a
href="https://treesdude.github.io/labjournal/finalGOF.html"
class="uri">https://treesdude.github.io/labjournal/finalGOF.html</a></p>
<p>CHANGE Both reciprocity and density are significant for an alpha of
<strong>NUMBER</strong>.</p>
<p>Estimates and standard errors</p>
<p>Rate parameters:</p>
<p>0. Rate parameter 2.117 ( 0.3561)</p>
<p>Other parameters:</p>
<p>1. eval: outdegree (density) -2.6388 ( 0.1460) convergence t ratio:
0.0182</p>
<p>2. eval: reciprocity 1.8035 ( 0.4343) convergence t ratio:
-0.0668</p>
<p><strong>meaning of significance in RSiena</strong> “It is important
to mention that significance in RSiena means something different than in
conventional statistics. In normal statistics, such as OLS-regression,
significance of estimates refers to the fact that they are not 0
(<strong>RELEVANT?</strong>). In RSiena, however, it refers to the fact
that the estimates were precisely determined (Ripley et al. 2011). Going
forward with this chapter, significance will refer to this definition of
significance.” - Niels Vullings</p>
<p>This model has a density parameter of <strong>NUMBER</strong>,
suggesting that “people generally do not want to have a dense
network”.</p>
<p>The reciprocity parameter of <strong>NUMBER</strong> indicates that
“people like to send ties back to people who have sent a tie to
them.”</p>
<div id="step-1-define-siena-data-variables" class="section level3"
number="4.1.1">
<h3><span class="header-section-number">4.1.1</span> —Step 1: Define
Siena Data &amp; Variables</h3>
<pre class="r test"><code># dependent variable
nets &lt;- sienaDependent(net_array)

# define data object
mydata_M0 &lt;- sienaDataCreate(nets)</code></pre>
<p>Print short descriptive report</p>
<pre class="r test"><code>ifelse(!dir.exists(&quot;results&quot;), dir.create(&quot;results&quot;), FALSE)</code></pre>
<pre class="test2"><code>#&gt; [1] FALSE</code></pre>
<pre class="r test"><code>print01Report(mydata_M0, modelname = &quot;./results/results_M0&quot;)  # create file with report in results folder </code></pre>
</div>
<div id="step-2-make-effects-objectstructure" class="section level3"
number="4.1.2">
<h3><span class="header-section-number">4.1.2</span> —Step 2: Make
effects object/structure</h3>
<pre class="r test"><code># define effects structure
myeff_M0 &lt;- getEffects(mydata_M0)</code></pre>
</div>
<div id="step-3-add-effects" class="section level3" number="4.1.3">
<h3><span class="header-section-number">4.1.3</span> —Step 3: Add
Effects</h3>
<p>Null model: none.</p>
</div>
<div id="step-4-specify-modelalgorithm" class="section level3"
number="4.1.4">
<h3><span class="header-section-number">4.1.4</span> —Step 4: Specify
model/algorithm</h3>
<pre class="r test"><code>myAlgorithm_M0 &lt;- sienaAlgorithmCreate(projname = &quot;results_M0&quot;)</code></pre>
<pre class="test2"><code>#&gt; If you use this algorithm object, siena07 will create/use an output file results_M0.txt .</code></pre>
</div>
<div id="step-5-estimate-model" class="section level3" number="4.1.5">
<h3><span class="header-section-number">4.1.5</span> —Step 5: Estimate
model</h3>
<pre class="r test"><code># estimate the model
Model0 &lt;- siena07(myAlgorithm_M0, data = mydata_M0, effects = myeff_M0, returnDeps = TRUE)
Model0

fsave(Model0, file = &quot;estimated_M0&quot;)</code></pre>
<pre class="test2"><code>#&gt; Estimates, standard errors and convergence t-ratios
#&gt; 
#&gt;                               Estimate   Standard   Convergence 
#&gt;                                            Error      t-ratio   
#&gt; 
#&gt; Rate parameters: 
#&gt;   0       Rate parameter       2.1170  ( 0.3561   )             
#&gt; 
#&gt; Other parameters: 
#&gt;   1. eval outdegree (density) -2.6388  ( 0.1460   )    0.0182   
#&gt;   2. eval reciprocity          1.8035  ( 0.4343   )   -0.0668   
#&gt; 
#&gt; Overall maximum convergence ratio:    0.0843 
#&gt; 
#&gt; 
#&gt; Total of 2012 iteration steps.</code></pre>
<pre class="r test"><code>GOF_M0 &lt;- sienaGOF(Model0, IndegreeDistribution, verbose = FALSE, join = TRUE, varName = &quot;nets&quot;)

plot(GOF_M0, main = &quot;GOF - \&quot;Null\&quot; Model 0 \n Indegree Distribution&quot;)</code></pre>
<p><img src="modelestimate_files/figure-html/GOF%20M0-1.png" width="672" /></p>
<hr />
</div>
</div>
<div id="model-1---structural-effects" class="section level2"
number="4.2">
<h2><span class="header-section-number">4.2</span> &lt;&gt; Model 1 -
Structural Effects</h2>
<p>This model additionally entails InPop, outAct, isolateNet as network
statistics.</p>
<p>“The model has a maximum convergence ratio of <strong>0.17</strong>
and a Goodness of Fit on the indegree distribution of
<strong>.002.</strong>”</p>
<p>“Indegree Popularity (inPop) is defined as the extent to which people
who have a lot of indegrees are more popular to connect with. This
parameter is NUMBER, meaning that actors have a preference to connect
with actors who have a lot of indegrees. The parameter is significant
for an alpha of <strong>NUMBER</strong>.”</p>
<p>“Outdegree Activity (outAct) has a value of <strong>NUMBER</strong>,
but is not significant. IsolateNet is significant andhas a value of
NUMBER and refers to the preference of remaining an isolate. As this
value is positive (*IS IT??!**), it means that people prefer to be an
isolate in the network.”</p>
<hr />
<p>Estimates and standard errors</p>
<p>Rate parameters:</p>
<p>0. Rate parameter 3.3566 ( 0.5773)</p>
<p>Other parameters:</p>
<p>1. eval: outdegree (density) -2.0862 ( 0.7050)</p>
<p>2. eval: reciprocity 1.0894 ( 0.4144)</p>
<p>3. eval: indegree - popularity 0.2549 ( 0.0439)</p>
<p>4. eval: outdegree - activity -0.0936 ( 0.1301)</p>
<p>5. eval: network-isolate 4.9645 ( 1.1146)</p>
<p>convergence t ratio:</p>
<pre><code>1
0.0232</code></pre>
<pre><code>2
0.0467</code></pre>
<pre><code>3
-0.0195</code></pre>
<pre><code>4
-0.0423</code></pre>
<pre><code>5
-0.061</code></pre>
<pre><code>6
-0.0617</code></pre>
<div id="step-1-define-siena-data-variables-1" class="section level3"
number="4.2.1">
<h3><span class="header-section-number">4.2.1</span> —Step 1: Define
Siena Data &amp; Variables</h3>
<pre class="r test"><code># dependent variable
nets &lt;- sienaDependent(net_array)

# define data object
mydata_M1 &lt;- sienaDataCreate(nets)</code></pre>
<p>Print short descriptive report</p>
<pre class="r test"><code>ifelse(!dir.exists(&quot;results&quot;), dir.create(&quot;results&quot;), FALSE)</code></pre>
<pre class="test2"><code>#&gt; [1] FALSE</code></pre>
<pre class="r test"><code>print01Report(mydata_M1, modelname = &quot;./results/results_M1&quot;)  # create file with report in results folder </code></pre>
</div>
<div id="step-2-make-effects-objectstructure-1" class="section level3"
number="4.2.2">
<h3><span class="header-section-number">4.2.2</span> —Step 2: Make
effects object/structure</h3>
<pre class="r test"><code># define effects structure
myeff_M1 &lt;- getEffects(mydata_M1)</code></pre>
</div>
<div id="step-3-add-effects-1" class="section level3" number="4.2.3">
<h3><span class="header-section-number">4.2.3</span> —Step 3: Add
Effects</h3>
<pre class="r test"><code>myeff_M1 &lt;- includeEffects(myeff_M1, isolateNet, inPop, outAct)</code></pre>
<pre class="test2"><code>#&gt;   effectName            include fix   test  initialValue parm
#&gt; 1 indegree - popularity TRUE    FALSE FALSE          0   0   
#&gt; 2 outdegree - activity  TRUE    FALSE FALSE          0   0   
#&gt; 3 network-isolate       TRUE    FALSE FALSE          0   0</code></pre>
</div>
<div id="step-4-specify-modelalgorithm-1" class="section level3"
number="4.2.4">
<h3><span class="header-section-number">4.2.4</span> —Step 4: Specify
model/algorithm</h3>
<pre class="r test"><code>myAlgorithm_M1 &lt;- sienaAlgorithmCreate(projname = &quot;results_M1&quot;)</code></pre>
<pre class="test2"><code>#&gt; If you use this algorithm object, siena07 will create/use an output file results_M1.txt .</code></pre>
</div>
<div id="step-5-estimate-model-1" class="section level3" number="4.2.5">
<h3><span class="header-section-number">4.2.5</span> —Step 5: Estimate
model</h3>
<pre class="r test"><code># estimate the model
Model1 &lt;- siena07(myAlgorithm_M1, data = mydata_M1, effects = myeff_M1, returnDeps = TRUE)
Model1
# maximum convergence &gt;.25 run again:
Model1.1 &lt;- siena07(myAlgorithm_M1, data = mydata_M1, effects = myeff_M1, prevAns = Model1, returnDeps = TRUE)
Model1.1

# fsave(Model1, file =&#39;estimated_M1&#39;) fsave(Model1.1, file = &#39;estimated_M1.1&#39;)</code></pre>
<pre class="test2"><code>#&gt; Estimates, standard errors and convergence t-ratios
#&gt; 
#&gt;                                 Estimate   Standard   Convergence 
#&gt;                                              Error      t-ratio   
#&gt; 
#&gt; Rate parameters: 
#&gt;   0       Rate parameter         3.1828  ( 0.5998   )             
#&gt; 
#&gt; Other parameters: 
#&gt;   1. eval outdegree (density)   -2.1969  ( 0.6803   )    0.2455   
#&gt;   2. eval reciprocity            1.0939  ( 0.4500   )    0.0324   
#&gt;   3. eval indegree - popularity  0.2778  ( 0.0441   )    0.3761   
#&gt;   4. eval outdegree - activity  -0.0820  ( 0.1208   )    0.1302   
#&gt;   5. eval network-isolate        4.7886  ( 1.1409   )   -0.1993   
#&gt; 
#&gt; Overall maximum convergence ratio:    0.3834 
#&gt; 
#&gt; 
#&gt; Total of 2569 iteration steps.</code></pre>
<pre class="test2"><code>#&gt; Estimates, standard errors and convergence t-ratios
#&gt; 
#&gt;                                 Estimate   Standard   Convergence 
#&gt;                                              Error      t-ratio   
#&gt; 
#&gt; Rate parameters: 
#&gt;   0       Rate parameter         3.3690  ( 0.5713   )             
#&gt; 
#&gt; Other parameters: 
#&gt;   1. eval outdegree (density)   -2.1194  ( 0.7764   )    0.0455   
#&gt;   2. eval reciprocity            1.0930  ( 0.4241   )    0.0532   
#&gt;   3. eval indegree - popularity  0.2564  ( 0.0459   )   -0.0039   
#&gt;   4. eval outdegree - activity  -0.0863  ( 0.1370   )    0.0526   
#&gt;   5. eval network-isolate        4.9560  ( 1.4674   )    0.0066   
#&gt; 
#&gt; Overall maximum convergence ratio:    0.0710 
#&gt; 
#&gt; 
#&gt; Total of 2372 iteration steps.</code></pre>
</div>
<div id="step-6-gof---goodness-of-fit" class="section level3"
number="4.2.6">
<h3><span class="header-section-number">4.2.6</span> —Step 6: GOF -
Goodness of Fit</h3>
<pre class="r test"><code>GOF_M1.1 &lt;- sienaGOF(Model1.1, IndegreeDistribution, verbose = FALSE, join = TRUE, varName = &quot;nets&quot;)

plot(GOF_M1.1, main = &quot;GOF - Model 1 \n Indegree Distribution&quot;)</code></pre>
<p><img src="modelestimate_files/figure-html/GOF%20M1-1.png" width="672" /></p>
<hr />
</div>
</div>
<div id="model-2---gender" class="section level2" number="4.3">
<h2><span class="header-section-number">4.3</span> &lt;&gt; Model 2 -
Gender</h2>
<p>This model is partly similar to Model 1 but additionally holds the
network statistics sameX, diffXTransTrip, egoX &amp; altX of the
covariate gender.</p>
<pre><code>Estimates, standard errors and convergence t-ratios                                                
                                            Estimate   Standard   Convergence
                                                        Error      t-ratio     
Rate parameters:    
0       Rate parameter                       2.9204  ( 0.4617   )               

Other parameters:    
1. eval outdegree (density)                 -1.8628  ( 1.1060   )    0.0703      
2. eval reciprocity                          1.3341  ( 0.4543   )   -0.0152      
3. eval indegree - popularity                0.2209  ( 0.0470   )   -0.0083      
4. eval outdegree - activity                -0.3017  ( 0.2287   )    0.0806      
5. eval network-isolate                      4.7507  ( 1.5194   )   -0.0379      
6. eval gender_RS alter                      0.3254  ( 0.2701   )    0.0411      
7. eval gender_RS ego                       -1.0642  ( 0.6055   )   -0.0400      
8. eval same gender_RS                       0.6637  ( 0.2685   )    0.0308      
9. eval transitive triplets diff. gender_RS  2.1787  ( 0.6027   )    0.0416   </code></pre>
<p>The maximum convergence ratio for model 2 is <strong>0.132</strong>
and the Goodness of Fit on the indegree distribution is
<strong>0.096</strong>.</p>
<p><strong>CHANGE!!</strong></p>
<p>“For the structural network statistics we find similar results, in
terms of estimate size and significance, as in Model 1. However, the
outdegree activity parameter almost reaches significance
(<strong>-1.7135484</strong>).</p>
<p>With regard to the covariate network statistics, we find that the
gender of ego (egoX), the gender of alter (altX) <strong>are not
significant and thus the estimate cannot be trusted</strong>.”</p>
<p>egoX and altX: model whether male or female scholars are more likely
to initiate or receive ties.</p>
<p><strong>sameX (Gender)</strong>: Tests whether scholars prefer
same-gender collaborators (direct measure of gender homophily).<br />
model the general tendency for scholars to collaborate with same-gender
peers.</p>
<p><strong>Confirmation</strong>:</p>
<ul>
<li><p>Significant and positive coefficient for <code>sameX</code> in
the RSiena output would confirm that gender homophily exists.</p></li>
<li><p>A non-significant or negative coefficient would disconfirm this
hypothesis.</p></li>
</ul>
<p><strong>Confirmation</strong>:</p>
<ul>
<li><p>Significant and positive coefficient for <code>sameX</code> in
the RSiena output would confirm that gender homophily exists.</p></li>
<li><p>A non-significant or negative coefficient would disconfirm this
hypothesis.</p></li>
</ul>
<p>Hypothesis about structural effects</p>
<ul>
<li><p><strong>Network Statistics</strong>:</p>
<ul>
<li><p><strong>sameX (Gender)</strong>: Tests for gender homophily
directly.</p></li>
<li><p>Structural statistics like <strong>reciprocity</strong>,
<strong>inPop</strong>, <strong>outAct</strong>, and
<strong>isolateNet</strong> are control variables to account for
network-level dynamics.</p></li>
</ul></li>
<li><p><strong>Confirmation</strong>:</p>
<ul>
<li><p>A significant <code>sameX</code> coefficient, even after
including structural controls, would confirm that gender homophily
exists at the dyadic level.</p></li>
<li><p>If <code>sameX</code> becomes non-significant after controls, it
suggests structural factors, not individual preferences, explain gender
clustering.</p></li>
</ul></li>
</ul>
<div id="step-1-define-siena-data-variables-2" class="section level3"
number="4.3.1">
<h3><span class="header-section-number">4.3.1</span> —Step 1: Define
Siena Data &amp; Variables</h3>
<pre class="r test"><code># dependent variable
nets &lt;- sienaDependent(net_array)

# put gender in object
gender &lt;- df_ego$gender

# covariate 1
gender_RS &lt;- coCovar(gender)  # gender as covariate in Rsiena

# define data object
mydata_M2 &lt;- sienaDataCreate(nets, gender_RS)</code></pre>
<p>Print short descriptive report</p>
<pre class="r test"><code>ifelse(!dir.exists(&quot;results&quot;), dir.create(&quot;results&quot;), FALSE)</code></pre>
<pre class="test2"><code>#&gt; [1] FALSE</code></pre>
<pre class="r test"><code>print01Report(mydata_M2, modelname = &quot;./results/results_M2&quot;)  # create file with report in results folder </code></pre>
</div>
<div id="step-2-make-effects-objectstructure-2" class="section level3"
number="4.3.2">
<h3><span class="header-section-number">4.3.2</span> —Step 2: Make
effects object/structure</h3>
<pre class="r test"><code># define effects structure
myeff_M2 &lt;- getEffects(mydata_M2)</code></pre>
</div>
<div id="step-3-add-effects-2" class="section level3" number="4.3.3">
<h3><span class="header-section-number">4.3.3</span> —Step 3: Add
Effects</h3>
<pre class="r test"><code>myeff_M2 &lt;- includeEffects(myeff_M2, isolateNet, inPop, outAct)</code></pre>
<pre class="test2"><code>#&gt;   effectName            include fix   test  initialValue parm
#&gt; 1 indegree - popularity TRUE    FALSE FALSE          0   0   
#&gt; 2 outdegree - activity  TRUE    FALSE FALSE          0   0   
#&gt; 3 network-isolate       TRUE    FALSE FALSE          0   0</code></pre>
<pre class="r test"><code>myeff_M2 &lt;- includeEffects(myeff_M2, egoX, altX, diffXTransTrip, sameX, interaction1 = &quot;gender_RS&quot;)</code></pre>
<pre class="test2"><code>#&gt;   effectName                          include fix   test  initialValue parm
#&gt; 1 gender_RS alter                     TRUE    FALSE FALSE          0   0   
#&gt; 2 gender_RS ego                       TRUE    FALSE FALSE          0   0   
#&gt; 3 same gender_RS                      TRUE    FALSE FALSE          0   0   
#&gt; 4 transitive triplets diff. gender_RS TRUE    FALSE FALSE          0   0</code></pre>
<!--
# isolatenet: if individual is alone they "like to/tend to stay alone"
# inPop: ppl like to collaborate with people who are popular

# sameX
# same covariate, which can also be called covariate-related identity (sameX), defined by the number of ties of i to all other actors j who have exactly the same value on the covariate, s net i95(x) = P jxij I{vi = vj},
# where the indicator function I{vi = vj} is 1 if the condition {vi = vj} is satisfied, and 0 if it is not;


#diffXTransTrip
different covariate × transitive triplets (diffXTransTrip), defined by the number
of transitive triplets i → h → j ← i that have different covariate values for i and j,
diff. cov. values = diff gender

-->
</div>
<div id="step-4-specify-modelalgorithm-2" class="section level3"
number="4.3.4">
<h3><span class="header-section-number">4.3.4</span> —Step 4: Specify
model/algorithm</h3>
<pre class="r test"><code>myAlgorithm_M2 &lt;- sienaAlgorithmCreate(projname = &quot;results_M2&quot;)</code></pre>
<pre class="test2"><code>#&gt; If you use this algorithm object, siena07 will create/use an output file results_M2.txt .</code></pre>
</div>
<div id="step-5-estimate-model-2" class="section level3" number="4.3.5">
<h3><span class="header-section-number">4.3.5</span> —Step 5: Estimate
model</h3>
<pre class="r test"><code># estimate the model
Model2 &lt;- siena07(myAlgorithm_M2, data = mydata_M2, effects = myeff_M2, returnDeps = TRUE)
Model2
# maximum convergence &gt;.25 run again:
Model2.1 &lt;- siena07(myAlgorithm_M2, data = mydata_M2, effects = myeff_M2, prevAns = Model2, returnDeps = TRUE)
Model2.1

# fsave(Model2, file =&#39;estimated_M2&#39;) fsave(Model2.1, file = &#39;estimated_M2.1&#39;)</code></pre>
<pre class="test2"><code>#&gt; Estimates, standard errors and convergence t-ratios
#&gt; 
#&gt;                                 Estimate   Standard   Convergence 
#&gt;                                              Error      t-ratio   
#&gt; 
#&gt; Rate parameters: 
#&gt;   0       Rate parameter         3.1029  ( 0.5490   )             
#&gt; 
#&gt; Other parameters: 
#&gt;   1. eval outdegree (density)   -1.7742  ( 1.1441   )    0.0988   
#&gt;   2. eval reciprocity            1.4275  ( 0.4218   )   -0.0194   
#&gt;   3. eval indegree - popularity  0.2565  ( 0.0484   )    0.2281   
#&gt;   4. eval outdegree - activity  -0.2088  ( 0.2242   )    0.0696   
#&gt;   5. eval network-isolate        5.6769  ( 1.5077   )   -0.0236   
#&gt;   6. eval gender_RS alter        0.4139  ( 0.2485   )    0.1751   
#&gt;   7. eval gender_RS ego         -1.6507  ( 0.8049   )    0.1058   
#&gt;   8. eval same gender_RS         0.4483  ( 0.2370   )    0.0775   
#&gt; 
#&gt; Overall maximum convergence ratio:    0.2534 
#&gt; 
#&gt; 
#&gt; Total of 2704 iteration steps.</code></pre>
<pre class="test2"><code>#&gt; Estimates, standard errors and convergence t-ratios
#&gt; 
#&gt;                                 Estimate   Standard   Convergence 
#&gt;                                              Error      t-ratio   
#&gt; 
#&gt; Rate parameters: 
#&gt;   0       Rate parameter         3.1864  ( 0.5236   )             
#&gt; 
#&gt; Other parameters: 
#&gt;   1. eval outdegree (density)   -1.6312  ( 1.7196   )   0.0438    
#&gt;   2. eval reciprocity            1.4395  ( 0.4535   )   0.0647    
#&gt;   3. eval indegree - popularity  0.2441  ( 0.0525   )   0.0333    
#&gt;   4. eval outdegree - activity  -0.2295  ( 0.3252   )   0.0789    
#&gt;   5. eval network-isolate        5.8919  ( 2.6335   )   0.1210    
#&gt;   6. eval gender_RS alter        0.4354  ( 0.2526   )   0.0831    
#&gt;   7. eval gender_RS ego         -1.7360  ( 1.0777   )   0.0151    
#&gt;   8. eval same gender_RS         0.4464  ( 0.2389   )   0.0267    
#&gt; 
#&gt; Overall maximum convergence ratio:    0.1816 
#&gt; 
#&gt; 
#&gt; Total of 2753 iteration steps.</code></pre>
</div>
<div id="step-6-gof---goodness-of-fit-1" class="section level3"
number="4.3.6">
<h3><span class="header-section-number">4.3.6</span> —Step 6: GOF -
Goodness of Fit</h3>
<pre class="r test"><code>GOF_M2.1 &lt;- sienaGOF(Model2.1, IndegreeDistribution, verbose = FALSE, join = TRUE, varName = &quot;nets&quot;)

plot(GOF_M2.1, main = &quot;GOF - Model 2 \n Indegree Distribution&quot;)</code></pre>
<p><img src="modelestimate_files/figure-html/GOF%20M2-1.png" width="672" /></p>
<hr />
</div>
</div>
<div id="model-3---department" class="section level2" number="4.4">
<h2><span class="header-section-number">4.4</span> &lt;&gt; Model 3 -
Department</h2>
<p>This model is partly similar to Model 2 but additionally holds the
network statistics egoX and altX for the main effect of department, to
control for differences in collaboration patterns between the two
departments.</p>
<p>Model 3 has a maximum convergence ratio of <strong>0.182</strong> and
a Goodness of Fit on the indegree distribution of
<strong>0.108</strong>.</p>
<p><strong>CHANGE</strong> !!!!</p>
<p>For the structural network statistics we find similar results, in
terms of estimate size and significance, as in Model 1. However, the
outdegree activity parameter almost reaches significance
(<strong>-1.7135484</strong>).</p>
<p>With regard to the covariate network statistics, we find that the
gender of ego (egoX), the gender of alter (altX) <strong>are not
significant and thus the estimate cannot be trusted</strong>.”</p>
<p>Estimates and standard errors</p>
<p>Rate parameters:</p>
<p>0. Rate parameter 3.1013 ( 0.5186)</p>
<p>Other parameters:</p>
<p>1. eval: outdegree (density) -4.3233 ( 1.0871)</p>
<p>2. eval: reciprocity 1.0725 ( 0.4174)</p>
<p>3. eval: indegree - popularity 0.2122 ( 0.0517)</p>
<p>4. eval: outdegree - activity -0.3364 ( 0.2182)</p>
<p>5. eval: network-isolate 4.2006 ( 1.3007)</p>
<p>6. eval: gender_RS alter 0.3356 ( 0.2659)</p>
<p>7. eval: gender_RS ego -1.0066 ( 0.5121)</p>
<p>8. eval: same gender_RS 0.6632 ( 0.2623)</p>
<p>9. eval: transitive triplets diff. gender_RS 1.5479 ( 0.5403)</p>
<p>10. eval: departm_RS alter 0.4141 ( 0.7546)</p>
<p>11. eval: departm_RS ego -1.1573 ( 0.9148)</p>
<p>12. eval: same departm_RS 2.7240 ( 0.7277)</p>
<ul>
<li><p><strong>Network Statistics</strong>:</p>
<ul>
<li><strong>sameX (Gender)</strong>: Compute and compare the size and
significance of the coefficient for each department. This requires
separate models for each department or interaction terms that allow the
effect to vary by department.</li>
</ul></li>
<li><p><strong>Confirmation</strong>:</p>
<ul>
<li><p>A significantly stronger positive coefficient for
<code>sameX</code> in Political Science compared to Sociology would
confirm the hypothesis.</p></li>
<li><p>Similar coefficients or reversed patterns would disconfirm the
hypothesis.</p></li>
</ul></li>
</ul>
<div id="step-1-define-siena-data-variables-3" class="section level3"
number="4.4.1">
<h3><span class="header-section-number">4.4.1</span> —Step 1: Define
Siena Data &amp; Variables</h3>
<pre class="r test"><code># dependent variable
nets &lt;- sienaDependent(net_array)

# put gender in object
gender &lt;- df_ego$gender

# covariate 1
gender_RS &lt;- coCovar(gender)  # gender as covariate in Rsiena

# put department in object
department &lt;- factor(df_ego$discipline.24, levels = c(&quot;sociology&quot;, &quot;political science&quot;))
# make numeric
department_numeric &lt;- as.numeric(department) - 1  # sociology = 0, political science = 1
# covariate 2
departm_RS &lt;- coCovar(department_numeric)

# define data object
mydata_M3 &lt;- sienaDataCreate(nets, gender_RS, departm_RS)</code></pre>
<p>Print short descriptive report</p>
<pre class="r test"><code>ifelse(!dir.exists(&quot;results&quot;), dir.create(&quot;results&quot;), FALSE)</code></pre>
<pre class="test2"><code>#&gt; [1] FALSE</code></pre>
<pre class="r test"><code>print01Report(mydata_M3, modelname = &quot;./results/results_M3&quot;)  # create file with report in results folder </code></pre>
</div>
<div id="step-2-make-effects-objectstructure-3" class="section level3"
number="4.4.2">
<h3><span class="header-section-number">4.4.2</span> —Step 2: Make
effects object/structure</h3>
<pre class="r test"><code># define effects structure
myeff_M3 &lt;- getEffects(mydata_M3)</code></pre>
</div>
<div id="step-3-add-effects-3" class="section level3" number="4.4.3">
<h3><span class="header-section-number">4.4.3</span> —Step 3: Add
Effects</h3>
<pre class="r test"><code>myeff_M3 &lt;- includeEffects(myeff_M3, isolateNet, inPop, outAct)  # model 1</code></pre>
<pre class="test2"><code>#&gt;   effectName            include fix   test  initialValue parm
#&gt; 1 indegree - popularity TRUE    FALSE FALSE          0   0   
#&gt; 2 outdegree - activity  TRUE    FALSE FALSE          0   0   
#&gt; 3 network-isolate       TRUE    FALSE FALSE          0   0</code></pre>
<pre class="r test"><code>myeff_M3 &lt;- includeEffects(myeff_M3, egoX, altX, diffXTransTrip, sameX, interaction1 = &quot;gender_RS&quot;)  #model 2</code></pre>
<pre class="test2"><code>#&gt;   effectName                          include fix   test  initialValue parm
#&gt; 1 gender_RS alter                     TRUE    FALSE FALSE          0   0   
#&gt; 2 gender_RS ego                       TRUE    FALSE FALSE          0   0   
#&gt; 3 same gender_RS                      TRUE    FALSE FALSE          0   0   
#&gt; 4 transitive triplets diff. gender_RS TRUE    FALSE FALSE          0   0</code></pre>
<pre class="r test"><code>myeff_M3 &lt;- includeEffects(myeff_M3, egoX, altX, sameX, interaction1 = &quot;departm_RS&quot;)  #model 3</code></pre>
<pre class="test2"><code>#&gt;   effectName       include fix   test  initialValue parm
#&gt; 1 departm_RS alter TRUE    FALSE FALSE          0   0   
#&gt; 2 departm_RS ego   TRUE    FALSE FALSE          0   0   
#&gt; 3 same departm_RS  TRUE    FALSE FALSE          0   0</code></pre>
<!--
# isolatenet: if individual is alone they "like to/tend to stay alone"
# inPop: ppl like to collaborate with people who are popular

# sameX
# same covariate, which can also be called covariate-related identity (sameX), defined by the number of ties of i to all other actors j who have exactly the same value on the covariate, s net i95(x) = P jxij I{vi = vj},
# where the indicator function I{vi = vj} is 1 if the condition {vi = vj} is satisfied, and 0 if it is not;


#diffXTransTrip
different covariate × transitive triplets (diffXTransTrip), defined by the number
of transitive triplets i → h → j ← i that have different covariate values for i and j,
diff. cov. values = diff gender

-->
</div>
<div id="step-4-specify-modelalgorithm-3" class="section level3"
number="4.4.4">
<h3><span class="header-section-number">4.4.4</span> —Step 4: Specify
model/algorithm</h3>
<pre class="r test"><code>myAlgorithm_M3 &lt;- sienaAlgorithmCreate(projname = &quot;results_M3&quot;)</code></pre>
<pre class="test2"><code>#&gt; If you use this algorithm object, siena07 will create/use an output file results_M3.txt .</code></pre>
</div>
<div id="step-5-estimate-model-3" class="section level3" number="4.4.5">
<h3><span class="header-section-number">4.4.5</span> —Step 5: Estimate
model</h3>
<pre class="r test"><code># estimate the model
Model3 &lt;- siena07(myAlgorithm_M3, data = mydata_M3, effects = myeff_M3, returnDeps = TRUE)
Model3

# if maximum convergence &gt;.25: run again
Model3.1 &lt;- siena07(myAlgorithm_M3, data = mydata_M3, effects = myeff_M3, prevAns = Model3, returnDeps = TRUE)
Model3.1

# fsave(Model3, file =&#39;estimated_M3&#39;) fsave(Model3.1, file = &#39;estimated_M3.1&#39;)</code></pre>
<pre class="test2"><code>#&gt; Estimates, standard errors and convergence t-ratios
#&gt; 
#&gt;                                                Estimate   Standard   Convergence 
#&gt;                                                             Error      t-ratio   
#&gt; 
#&gt; Rate parameters: 
#&gt;   0        Rate parameter                       3.0283  ( 0.4540   )             
#&gt; 
#&gt; Other parameters: 
#&gt;    1. eval outdegree (density)                 -4.5069  ( 1.0796   )    0.1107   
#&gt;    2. eval reciprocity                          1.0472  ( 0.4463   )   -0.0419   
#&gt;    3. eval indegree - popularity                0.2142  ( 0.0496   )    0.1107   
#&gt;    4. eval outdegree - activity                -0.3423  ( 0.1745   )    0.1165   
#&gt;    5. eval network-isolate                      4.1968  ( 1.0825   )    0.0149   
#&gt;    6. eval gender_RS alter                      0.3511  ( 0.2602   )    0.1186   
#&gt;    7. eval gender_RS ego                       -1.0285  ( 0.4820   )   -0.1188   
#&gt;    8. eval same gender_RS                       0.6650  ( 0.2666   )   -0.0002   
#&gt;    9. eval transitive triplets diff. gender_RS  1.5836  ( 0.5367   )    0.1694   
#&gt;   10. eval departm_RS alter                     0.5620  ( 0.6890   )   -0.0668   
#&gt;   11. eval departm_RS ego                      -1.3124  ( 0.8647   )   -0.0906   
#&gt;   12. eval same departm_RS                      2.9231  ( 0.7430   )    0.1732   
#&gt; 
#&gt; Overall maximum convergence ratio:    0.4454 
#&gt; 
#&gt; 
#&gt; Total of 2660 iteration steps.</code></pre>
<pre class="test2"><code>#&gt; Estimates, standard errors and convergence t-ratios
#&gt; 
#&gt;                                                Estimate   Standard   Convergence 
#&gt;                                                             Error      t-ratio   
#&gt; 
#&gt; Rate parameters: 
#&gt;   0        Rate parameter                       3.1013  ( 0.5186   )             
#&gt; 
#&gt; Other parameters: 
#&gt;    1. eval outdegree (density)                 -4.3233  ( 1.0871   )   -0.0034   
#&gt;    2. eval reciprocity                          1.0725  ( 0.4174   )    0.0126   
#&gt;    3. eval indegree - popularity                0.2122  ( 0.0517   )   -0.0042   
#&gt;    4. eval outdegree - activity                -0.3364  ( 0.2182   )    0.0027   
#&gt;    5. eval network-isolate                      4.2006  ( 1.3007   )    0.0526   
#&gt;    6. eval gender_RS alter                      0.3356  ( 0.2659   )   -0.0145   
#&gt;    7. eval gender_RS ego                       -1.0066  ( 0.5121   )    0.0453   
#&gt;    8. eval same gender_RS                       0.6632  ( 0.2623   )    0.0938   
#&gt;    9. eval transitive triplets diff. gender_RS  1.5479  ( 0.5403   )    0.0086   
#&gt;   10. eval departm_RS alter                     0.4141  ( 0.7546   )    0.0077   
#&gt;   11. eval departm_RS ego                      -1.1573  ( 0.9148   )    0.0144   
#&gt;   12. eval same departm_RS                      2.7240  ( 0.7277   )    0.0072   
#&gt; 
#&gt; Overall maximum convergence ratio:    0.1817 
#&gt; 
#&gt; 
#&gt; Total of 2859 iteration steps.</code></pre>
</div>
<div id="step-6-gof---goodness-of-fit-2" class="section level3"
number="4.4.6">
<h3><span class="header-section-number">4.4.6</span> —Step 6: GOF -
Goodness of Fit</h3>
<pre class="r test"><code>GOF_M3.1 &lt;- sienaGOF(Model3.1, IndegreeDistribution, verbose = FALSE, join = TRUE, varName = &quot;nets&quot;)

plot(GOF_M3.1, main = &quot;GOF - Model 3 \n Indegree Distribution&quot;)</code></pre>
<p><img src="modelestimate_files/figure-html/GOF%20M3-1.png" width="672" /></p>
<hr />
</div>
</div>
<div id="model-4---h-index" class="section level2" number="4.5">
<h2><span class="header-section-number">4.5</span> &lt;&gt; Model 4 -
H-Index</h2>
<p>This model further builds on the prior model and also includes the
network statistics of the covariat H-index, namely <strong>egoX, altX
and inPopX</strong>.</p>
<p>“The last model has a maximum convergence ratio of
<strong>0.23</strong> and a a Goodness of Fit on the indegree
distribution of <strong>0.197</strong>.</p>
<pre><code>Estimates, standard errors and convergence t-ratios
                                               Estimate   Standard   Convergence
                                                          Error      t-ratio
Rate parameters:  
  0      Rate parameter                       2.6891  ( 0.3675   )               

Other parameters:     
   1. eval outdegree (density)                 -2.7693  ( 1.9205   )    0.0698       
   2. eval reciprocity                          2.1770  ( 0.5960   )    0.0919       
   3. eval indegree - popularity               -0.0653  ( 0.1654   )   -0.0104       
   4. eval outdegree - activity                -0.6851  ( 0.4029   )    0.0527       
   5. eval network-isolate                      5.4634  ( 2.2770   )    0.0028       
   6. eval gender_RS alter                     -0.0903  ( 0.3372   )    0.0129       
   7. eval gender_RS ego                        0.2993  ( 0.4934   )   -0.0503       
   8. eval same gender_RS                       0.6820  ( 0.2804   )    0.0201       
   9. eval transitive triplets diff. gender_RS  2.4871  ( 0.6670   )    0.0505      
  10. eval departm_RS alter                     0.3929  ( 0.6128   )   -0.0061      
  11. eval departm_RS ego                      -1.4652  ( 0.6963   )   -0.0115      
  12. eval same departm_RS                      2.6327  ( 0.6080   )    0.0173      
  13. eval h_index_RS alter                     0.0829  ( 0.0364   )   -0.0031      
  14. eval h_index_RS ego                      -0.1591  ( 0.0744   )    0.0161      
  15. eval ind. pop.^(1/1) weighted h_index_RS -0.0287  ( 0.0570   )   -0.0129</code></pre>
<p><strong>CHANGE!!!</strong></p>
<p>“In this model, the parameters for density and reciprocity are still
significant, with values of <strong>-1.98</strong> (se =
<strong>0.71</strong>) and <strong>2.59</strong> (se =
<strong>0.38</strong>) respectively, meaning that actors prefer sparse
networks, but do prefer to send ties to alters who have sent ties to
them.</p>
<p>IsolateNet is still significant with a value of <strong>3.23</strong>
(se = <strong>1.06</strong>), implying that actors prefer to be
isolates.</p>
<p>In this model, <strong>indegree popularity squared</strong> (b =
<strong>0.17</strong>, se = <strong>0.21</strong>) is no longer
significant, implying that this might be explained by other network
statistics in the model.</p>
<p>The covariate statistics for gender show similar findings as Model 2,
namely that actors prefer to close triads with alters that have a
different score for gender (b = <strong>1.51</strong>, se =
<strong>0.44</strong>).</p>
<p>The ego effect and alter effect for gender are
<strong>non-significant</strong>, as was the case in Model 2.</p>
<p>Lastly, Model 3 shows some significant results with regards to the
covariate network statistics for prestige. The prestige effect for
alters is positive, implying that people prefer to send ties to people
who have a higher amount of prestige (b = <strong>0.042</strong>, se =
<strong>0.0089</strong>).</p>
<p>Additionally, the prestige effect for egos is negative, which
indicates that people who have higher prestige send less ties (b =
<strong>-0.030</strong>, se = <strong>0.015</strong>). <strong>This is
in line with theories of preferential attachment and upward mobility,
because as egos with higher prestige will are more likely to receive
request for collaboration rather then sending request for
collaboration.</strong></p>
<p>Interestingly enough, the indegree popularity statistic for prestige
is not significant (b = <strong>-0.012</strong>, se =
<strong>0.023</strong>), implying that actors who are more prestigious
do not receive more indegrees.”</p>
<p>About Hypothesis 4</p>
<p>modeling how the department of the actor (Sociology or Political
Science) influences their collaboration choices in terms of gender.</p>
<p><strong>Interaction1 = “departm_RS”</strong>: This allows you to test
how department (Sociology vs Political Science) influences the
probability of forming collaborations, potentially differing by gender.
This means that gender homophily (whether a person collaborates more
often with same-gender peers) might be different in the two
departments.</p>
<p>allows you to explore how <strong>department</strong> influences the
likelihood of <strong>same-gender</strong> collaborations
(<code>sameX</code>), which is central to your research question. If the
<strong>department variable</strong> is acting as an important covariate
influencing collaboration patterns, this line captures that effect.</p>
<p>testing how being in a particular department influences the
likelihood of collaborating with someone of the same gender. In other
words, it checks if the department modifies the strength of gender
homophily (<code>sameX</code>).</p>
<p><strong>Network Statistics</strong>:</p>
<ul>
<li><p><strong>egoX (h-index)</strong>: Examines how the h-index of the
focal scholar affects their collaboration behavior.</p></li>
<li><p><strong>altX (h-index)</strong>: Examines how the h-index of
potential collaborators affects their attractiveness as partners.</p>
<p>Add <code>egoX</code> and <code>altX</code> effects for
<code>HIndex_RS</code> to test if prestigious scholars are more likely
to initiate or receive ties.</p></li>
<li><p><strong>inPopX (h-index)</strong>: Assesses whether prestige
increases the likelihood of being sought out as a collaborator.</p></li>
</ul>
<p><strong>Confirmation</strong>:</p>
<ul>
<li><p>A significant negative interaction term between
<code>sameX</code> and h-index statistics would confirm that prestige
reduces the strength of gender homophily.</p></li>
<li><p>If h-index variables do not significantly influence
<code>sameX</code>, this would disconfirm H3.</p></li>
</ul>
<div id="step-1-define-siena-data-variables-4" class="section level3"
number="4.5.1">
<h3><span class="header-section-number">4.5.1</span> —Step 1: Define
Siena Data &amp; Variables</h3>
<pre class="r test"><code># dependent variable
nets &lt;- sienaDependent(net_array)

# put gender in object
gender &lt;- df_ego$gender
# covariate 1
gender_RS &lt;- coCovar(gender)  # gender as covariate in Rsiena

# put department in object
department &lt;- factor(df_ego$discipline.24, levels = c(&quot;sociology&quot;, &quot;political science&quot;))
# make numeric
department_numeric &lt;- as.numeric(department) - 1  # sociology = 0, political science = 1
# covariate 2
departm_RS &lt;- coCovar(department_numeric)

# put h-index in object
h_index &lt;- df_ego$h_index
df_ego$h_index</code></pre>
<pre class="test2"><code>#&gt;   [1]  5 26 12  9  4 10 27 23  5  9 10 12 11  8 42 11 11 51 25 22 23 11 26  4 11  6  3  3  3  2  3
#&gt;  [32]  2  2  2  1  4  3  2  3  1  1  2 17 15  2 37  2  2  4  9  1  0  1 17 16 13  0  2  0  1 12 18
#&gt;  [63]  6  1  1  6  8 10 12  8  1  1 15 12 10  1  3 13 11  6  6  0  2  7 16 12 29 12 15  6 13 18 21
#&gt;  [94]  1 10  3  2  7  0  5  8</code></pre>
<pre class="r test"><code># covariate 3
h_index_RS &lt;- coCovar(h_index)  # h_index as covariate in RSiena

# define data object
mydata_M4 &lt;- sienaDataCreate(nets, gender_RS, departm_RS, h_index_RS)</code></pre>
<p>Print short descriptive report</p>
<pre class="r test"><code>ifelse(!dir.exists(&quot;results&quot;), dir.create(&quot;results&quot;), FALSE)</code></pre>
<pre class="test2"><code>#&gt; [1] FALSE</code></pre>
<pre class="r test"><code>print01Report(mydata_M4, modelname = &quot;./results/results_M4&quot;)  # create file with report in results folder </code></pre>
</div>
<div id="step-2-make-effects-objectstructure-4" class="section level3"
number="4.5.2">
<h3><span class="header-section-number">4.5.2</span> —Step 2: Make
effects object/structure</h3>
<pre class="r test"><code># define effects structure
myeff_M4 &lt;- getEffects(mydata_M4)</code></pre>
</div>
<div id="step-3-add-effects-4" class="section level3" number="4.5.3">
<h3><span class="header-section-number">4.5.3</span> —Step 3: Add
Effects</h3>
<pre class="r test"><code>myeff_M4 &lt;- includeEffects(myeff_M4, isolateNet, inPop, outAct)  # model 1</code></pre>
<pre class="test2"><code>#&gt;   effectName            include fix   test  initialValue parm
#&gt; 1 indegree - popularity TRUE    FALSE FALSE          0   0   
#&gt; 2 outdegree - activity  TRUE    FALSE FALSE          0   0   
#&gt; 3 network-isolate       TRUE    FALSE FALSE          0   0</code></pre>
<pre class="r test"><code>myeff_M4 &lt;- includeEffects(myeff_M4, egoX, altX, diffXTransTrip, sameX, interaction1 = &quot;gender_RS&quot;)  #model 2</code></pre>
<pre class="test2"><code>#&gt;   effectName                          include fix   test  initialValue parm
#&gt; 1 gender_RS alter                     TRUE    FALSE FALSE          0   0   
#&gt; 2 gender_RS ego                       TRUE    FALSE FALSE          0   0   
#&gt; 3 same gender_RS                      TRUE    FALSE FALSE          0   0   
#&gt; 4 transitive triplets diff. gender_RS TRUE    FALSE FALSE          0   0</code></pre>
<pre class="r test"><code>myeff_M4 &lt;- includeEffects(myeff_M4, egoX, altX, sameX, interaction1 = &quot;departm_RS&quot;)  #model 3</code></pre>
<pre class="test2"><code>#&gt;   effectName       include fix   test  initialValue parm
#&gt; 1 departm_RS alter TRUE    FALSE FALSE          0   0   
#&gt; 2 departm_RS ego   TRUE    FALSE FALSE          0   0   
#&gt; 3 same departm_RS  TRUE    FALSE FALSE          0   0</code></pre>
<pre class="r test"><code>myeff_M4 &lt;- includeEffects(myeff_M4, egoX, altX, inPopX, interaction1 = &quot;h_index_RS&quot;)  # model 4</code></pre>
<pre class="test2"><code>#&gt;   effectName                          include fix   test  initialValue parm
#&gt; 1 h_index_RS alter                    TRUE    FALSE FALSE          0   0   
#&gt; 2 h_index_RS ego                      TRUE    FALSE FALSE          0   0   
#&gt; 3 ind. pop.^(1/#) weighted h_index_RS TRUE    FALSE FALSE          0   1</code></pre>
<!--
# isolatenet: if individual is alone they "like to/tend to stay alone"
# inPop: ppl like to collab with people who are popular

# sameX
# same covariate, which can also be called covariate-related identity (sameX), defined by the number of ties of i to all other actors j who have exactly the same value on the covariate, s net i95(x) = P jxij I{vi = vj},
# where the indicator function I{vi = vj} is 1 if the condition {vi = vj} is satisfied, and 0 if it is not;

# look up inPopX: preferential attachment (cf. Koen lel), higher h-index more popular 
  # cf. Fridas modeling process (Jochem told her that )

-->
</div>
<div id="step-4-specify-modelalgorithm-4" class="section level3"
number="4.5.4">
<h3><span class="header-section-number">4.5.4</span> —Step 4: Specify
model/algorithm</h3>
<pre class="r test"><code>myAlgorithm_M4 &lt;- sienaAlgorithmCreate(projname = &quot;results_M4&quot;)</code></pre>
<pre class="test2"><code>#&gt; If you use this algorithm object, siena07 will create/use an output file results_M4.txt .</code></pre>
</div>
<div id="step-5-estimate-model-4" class="section level3" number="4.5.5">
<h3><span class="header-section-number">4.5.5</span> —Step 5: Estimate
model</h3>
<pre class="r test"><code># estimate the model
Model4 &lt;- siena07(myAlgorithm_M4, data = mydata_M4, effects = myeff_M4, returnDeps = TRUE)
Model4

# fsave(Model4, file =&#39;estimated_M4&#39;)</code></pre>
<pre class="test2"><code>#&gt; Estimates, standard errors and convergence t-ratios
#&gt; 
#&gt;                                               Estimate   Standard   Convergence 
#&gt;                                                            Error      t-ratio   
#&gt; 
#&gt; Rate parameters: 
#&gt;   0       Rate parameter                       2.1021  ( 0.3399   )             
#&gt; 
#&gt; Other parameters: 
#&gt;   1. eval outdegree (density)                 -3.3787  ( 0.2606   )   -0.0783   
#&gt;   2. eval reciprocity                          3.0814  ( 0.5381   )   -0.1007   
#&gt;   3. eval h_index_RS alter                     0.0644  ( 0.0092   )   -0.0444   
#&gt;   4. eval h_index_RS ego                      -0.0903  ( 0.0506   )   -0.0432   
#&gt;   5. eval ind. pop.^(1/1) weighted h_index_RS  0.0139  ( 0.0637   )   -0.1012   
#&gt; 
#&gt; Overall maximum convergence ratio:    0.1610 
#&gt; 
#&gt; 
#&gt; Total of 2277 iteration steps.</code></pre>
</div>
<div id="step-6-gof---goodness-of-fit-3" class="section level3"
number="4.5.6">
<h3><span class="header-section-number">4.5.6</span> —Step 6: GOF -
Goodness of Fit</h3>
<pre class="r test"><code>GOF_M4 &lt;- sienaGOF(Model4, IndegreeDistribution, verbose = FALSE, join = TRUE, varName = &quot;nets&quot;)

plot(GOF_M4, main = &quot;GOF - Model 4 \n Indegree Distribution&quot;)</code></pre>
<p><img src="modelestimate_files/figure-html/GOF%20M4-1.png" width="672" /></p>
</div>
</div>
</div>

<div id="rmd-source-code">LS0tDQp0aXRsZTogIk1vZGVsIGVzdGltYXRpb24iDQphdXRob3I6ICJWZXJvb28iDQpkYXRlOiAiMjAyNC0xMS0yMCINCm91dHB1dDogaHRtbF9kb2N1bWVudA0KZWRpdG9yX29wdGlvbnM6IA0KICBtYXJrZG93bjogDQogICAgd3JhcDogNzINCi0tLQ0KDQo8aHRtbCBsYW5nPSJlbiI+DQoNCjxoZWFkPg0KDQo8bWV0YSBjaGFyc2V0PSJVVEYtOCI+DQoNCjxtZXRhIG5hbWU9InZpZXdwb3J0IiBjb250ZW50PSJ3aWR0aD1kZXZpY2Utd2lkdGgsIGluaXRpYWwtc2NhbGU9MS4wIj4NCg0KPHRpdGxlPk15IERlc2NyaXB0aXZlczwvdGl0bGU+DQoNCjxsaW5rIHJlbD0ic3R5bGVzaGVldCIgaHJlZj0ic3R5bGVzLmNzcyI+DQo8IS0tIExpbmsgdG8gdGhlIENTUyBmaWxlIEkgY3JlYXRlZCBmb3IgZGFyayBtb2RlIGNvZGUgY2h1bmtzIC0tPg0KDQo8L2hlYWQ+DQoNCjwvaHRtbD4NCg0KYGBge3Igc2V0dXAsIGluY2x1ZGU9RkFMU0V9DQprbml0cjo6b3B0c19jaHVuayRzZXQoZWNobyA9IFRSVUUpDQpgYGANCg0KYGBge3IsIGdsb2JhbHNldHRpbmdzLCBlY2hvPUZBTFNFLCB3YXJuaW5nPUZBTFNFLCByZXN1bHRzPSdoaWRlJ30NCmxpYnJhcnkoa25pdHIpDQoNCmtuaXRyOjpvcHRzX2NodW5rJHNldChlY2hvID0gVFJVRSkNCm9wdHNfY2h1bmskc2V0KHRpZHkub3B0cz1saXN0KHdpZHRoLmN1dG9mZj0xMDApLHRpZHk9VFJVRSwgd2FybmluZyA9IEZBTFNFLCBtZXNzYWdlID0gRkFMU0UsY29tbWVudCA9ICIjPiIsIGNhY2hlPVRSVUUsIGNsYXNzLnNvdXJjZT1jKCJ0ZXN0IiksIGNsYXNzLm91dHB1dD1jKCJ0ZXN0MiIpKQ0Kb3B0aW9ucyh3aWR0aCA9IDEwMCkNCnJnbDo6c2V0dXBLbml0cigpDQoNCmNvbG9yaXplIDwtIGZ1bmN0aW9uKHgsIGNvbG9yKSB7c3ByaW50ZigiPHNwYW4gc3R5bGU9J2NvbG9yOiAlczsnPiVzPC9zcGFuPiIsIGNvbG9yLCB4KSB9DQoNCmBgYA0KDQpgYGB7ciBrbGlwcHksIGVjaG89RkFMU0UsIGluY2x1ZGU9VFJVRX0NCmtsaXBweTo6a2xpcHB5KHBvc2l0aW9uID0gYygndG9wJywgJ3JpZ2h0JykpDQoja2xpcHB5OjprbGlwcHkoY29sb3IgPSAnZGFya3JlZCcpDQoja2xpcHB5OjprbGlwcHkodG9vbHRpcF9tZXNzYWdlID0gJ0NsaWNrIHRvIGNvcHknLCB0b29sdGlwX3N1Y2Nlc3MgPSAnRG9uZScpDQpgYGANCg0KIyBTZXR1cA0KDQpDbGVhbiB3b3Jrc3BhY2UuIEFzIGFsd2F5cy4NCg0KYGBge3IgY2xlYW59DQpybShsaXN0ID0gbHMoKSkNCmBgYA0KDQojIyBQYWNrYWdlcw0KDQpgYGB7ciBwYWNrYWdlLCBpbmNsdWRlPVRSVUUsIGhpZGU9VFJVRSwgZXZhbD1UUlVFfQ0KcmVxdWlyZSh0aWR5dmVyc2UpDQpyZXF1aXJlKFJTaWVuYSkNCnJlcXVpcmUoUnNpZW5hVHdvU3RlcCkNCg0KI2luc3RhbGwucGFja2FnZXMoImRhdGEudGFibGUiKQ0KcmVxdWlyZShkYXRhLnRhYmxlKSAgIyBtYWlubHkgZm9yIGZhc3RlciBkYXRhIGhhbmRsaW5nDQojIGluc3RhbGwucGFja2FnZXMoJ3htbDInKQ0KcmVxdWlyZSh4bWwyKQ0KIyBpbnN0YWxsLnBhY2thZ2VzKCdydmVzdCcpDQpyZXF1aXJlKHJ2ZXN0KQ0KcmVxdWlyZShpZ3JhcGgpDQpyZXF1aXJlKGdncmFwaCkNCg0KDQojaW5zdGFsbC5wYWNrYWdlcygndmlzTmV0d29yaycpDQpyZXF1aXJlKHZpc05ldHdvcmspDQojaW5zdGFsbC5wYWNrYWdlcygndGhyZWVqcycpDQpyZXF1aXJlKHRocmVlanMpDQojaW5zdGFsbC5wYWNrYWdlcygnbmV0d29ya0QzJykNCnJlcXVpcmUobmV0d29ya0QzKQ0KDQoNCmBgYA0KDQojIyBGdW5jdGlvbnMNCg0KRnVuY3Rpb25zIGNodW5rOg0KDQpgYGB7ciBmdW5jdGlvbnMgMSwgaGlkZT1UUlVFfQ0KZnBhY2thZ2UuY2hlY2sgPC0gZnVuY3Rpb24ocGFja2FnZXMpIHsNCiAgICBsYXBwbHkocGFja2FnZXMsIEZVTiA9IGZ1bmN0aW9uKHgpIHsNCiAgICAgICAgaWYgKCFyZXF1aXJlKHgsIGNoYXJhY3Rlci5vbmx5ID0gVFJVRSkpIHsNCiAgICAgICAgICAgIGluc3RhbGwucGFja2FnZXMoeCwgZGVwZW5kZW5jaWVzID0gVFJVRSkNCiAgICAgICAgICAgIGxpYnJhcnkoeCwgY2hhcmFjdGVyLm9ubHkgPSBUUlVFKQ0KICAgICAgICB9DQogICAgfSkNCn0NCg0KZnNhdmUgPC0gZnVuY3Rpb24oeCwgZmlsZSA9IE5VTEwsIGxvY2F0aW9uID0gIi4vZGF0YS9wcm9jZXNzZWQvIikgew0KICAgIGlmZWxzZSghZGlyLmV4aXN0cygiZGF0YSIpLCBkaXIuY3JlYXRlKCJkYXRhIiksIEZBTFNFKQ0KICAgIGlmZWxzZSghZGlyLmV4aXN0cygiZGF0YS9wcm9jZXNzZWQiKSwgZGlyLmNyZWF0ZSgiZGF0YS9wcm9jZXNzZWQiKSwgRkFMU0UpDQogICAgaWYgKGlzLm51bGwoZmlsZSkpDQogICAgICAgIGZpbGUgPSBkZXBhcnNlKHN1YnN0aXR1dGUoeCkpDQogICAgZGF0ZW5hbWUgPC0gc3Vic3RyKGdzdWIoIls6LV0iLCAiIiwgU3lzLnRpbWUoKSksIDEsIDgpDQogICAgdG90YWxuYW1lIDwtIHBhc3RlKGxvY2F0aW9uLCBmaWxlLCAiXyIsIGRhdGVuYW1lLCAiLnJkYSIsIHNlcCA9ICIiKQ0KICAgIHNhdmUoeCwgZmlsZSA9IHRvdGFsbmFtZSkgICNuZWVkIHRvIGZpeCBpZiBmaWxlIGlzIHJlbG9hZGVkIGFzIGlucHV0IG5hbWUsIG5vdCBhcyB4LiANCn0NCg0KZmxvYWQgPC0gZnVuY3Rpb24oZmlsZW5hbWUpIHsNCiAgICBsb2FkKGZpbGVuYW1lKQ0KICAgIGdldChscygpW2xzKCkgIT0gImZpbGVuYW1lIl0pDQp9DQoNCmZzaG93ZGYgPC0gZnVuY3Rpb24oeCwgLi4uKSB7DQogICAga25pdHI6OmthYmxlKHgsIGRpZ2l0cyA9IDIsICJodG1sIiwgLi4uKSAlPiUNCiAgICAgICAga2FibGVFeHRyYTo6a2FibGVfc3R5bGluZyhib290c3RyYXBfb3B0aW9ucyA9IGMoInN0cmlwZWQiLCAiaG92ZXIiKSkgJT4lDQogICAgICAgIGthYmxlRXh0cmE6OnNjcm9sbF9ib3god2lkdGggPSAiMTAwJSIsIGhlaWdodCA9ICIzMDBweCIpDQp9DQoNCg0KIyB0aGlzIGlzIHRoZSBtb3N0IGltcG9ydGFudCBvbmUuIFdlIGNyZWF0ZWQgaXQgaW4gdGhlIHByZXZpb3VzIHNjcmlwdA0KDQpmX3B1Ym5ldHMgPC0gZnVuY3Rpb24oZGZfc2Nob2xhcnMgPSBkZiwgbGlzdF9wdWJsaWNhdGlvbnMgPSBwdWJsaWNhdGlvbnMsIGRpc2NpcCA9ICJzb2Npb2xvZ3kiKyJwb2xpdGljYWwgc2NpZW5jZSIsIGFmZmlsaWF0aW9uID0gIlJVIiwNCiAgICB3YXZlcyA9IGxpc3Qod2F2ZTEgPSBjKDIwMTgsIDIwMTksIDIwMjApLCB3YXZlMiA9IGMoMjAyMSwgMjAyMiwgMjAyMykpKSB7DQoNCiAgICBwdWJsaWNhdGlvbnMgPC0gbGlzdF9wdWJsaWNhdGlvbnMgJT4lDQogICAgICAgIGJpbmRfcm93cygpICU+JQ0KICAgICAgICBkaXN0aW5jdCh0aXRsZSwgLmtlZXBfYWxsID0gVFJVRSkNCg0KICAgIGRmX3NjaG9sYXJzICU+JQ0KICAgICAgICBmaWx0ZXIoYWZmaWwxID09IGFmZmlsaWF0aW9uIHwgYWZmaWwyID09IGFmZmlsaWF0aW9uKSAlPiUNCiAgICAgICAgZmlsdGVyKGRpc2NpcGxpbmUgPT0gZGlzY2lwKSAtPiBkZl9zZWwNCg0KICAgIG5ldHdvcmtsaXN0IDwtIGxpc3QoKQ0KICAgIGZvciAod2F2ZSBpbiAxOmxlbmd0aCh3YXZlcykpIHsNCiAgICAgICAgbmV0d29ya2xpc3RbW3dhdmVdXSA8LSBtYXRyaXgoMCwgbnJvdyA9IG5yb3coZGZfc2VsKSwgbmNvbCA9IG5yb3coZGZfc2VsKSkNCiAgICB9DQoNCiAgICBwdWJsaWNhdGlvbmxpc3QgPC0gbGlzdCgpDQogICAgZm9yICh3YXZlIGluIDE6bGVuZ3RoKHdhdmVzKSkgew0KICAgICAgICBwdWJsaWNhdGlvbmxpc3RbW3dhdmVdXSA8LSBwdWJsaWNhdGlvbnMgJT4lDQogICAgICAgICAgICBmaWx0ZXIoZ3NfaWQgJWluJSBkZl9zZWwkZ3NfaWQpICU+JQ0KICAgICAgICAgICAgZmlsdGVyKHllYXIgJWluJSB3YXZlc1tbd2F2ZV1dKSAlPiUNCiAgICAgICAgICAgIHNlbGVjdChhdXRob3IpICU+JQ0KICAgICAgICAgICAgbGFwcGx5KHN0cl9zcGxpdCwgcGF0dGVybiA9ICIsIikNCiAgICB9DQoNCiAgICBwdWJsaWNhdGlvbmxpc3QyIDwtIGxpc3QoKQ0KICAgIGZvciAod2F2ZSBpbiAxOmxlbmd0aCh3YXZlcykpIHsNCiAgICAgICAgcHVibGljYXRpb25saXN0Mltbd2F2ZV1dIDwtIHB1YmxpY2F0aW9ubGlzdFtbd2F2ZV1dJGF1dGhvciAlPiUNCiAgICAgICAgICAgICMgbG93ZXJjYXNlDQogICAgICAgIGxhcHBseSh0b2xvd2VyKSAlPiUNCiAgICAgICAgICAgICMgUmVtb3ZpbmcgZGlhY3JpdGljcw0KICAgICAgICBsYXBwbHkoc3RyaV90cmFuc19nZW5lcmFsLCBpZCA9ICJsYXRpbi1hc2NpaSIpICU+JQ0KICAgICAgICAgICAgIyBvbmx5IGxhc3QgbmFtZQ0KICAgICAgICBsYXBwbHkod29yZCwgc3RhcnQgPSAtMSwgc2VwID0gIiAiKSAlPiUNCiAgICAgICAgICAgICMgb25seSBsYXN0IGxhc3QgbmFtZQ0KICAgICAgICBsYXBwbHkod29yZCwgc3RhcnQgPSAtMSwgc2VwID0gIi0iKQ0KICAgIH0NCg0KICAgIGZvciAod2F2ZSBpbiAxOmxlbmd0aCh3YXZlcykpIHsNCiAgICAgICAgIyBsZXQgdXMgcmVtb3ZlIGFsbCBwdWJsaWNhdGlvbnMgd2l0aCBvbmx5IG9uZSBhdXRob3INCiAgICAgICAgcmVtb3ZlIDwtIHdoaWNoKHNhcHBseShwdWJsaWNhdGlvbmxpc3QyW1t3YXZlXV0sIEZVTiA9IGZ1bmN0aW9uKHgpIGxlbmd0aCh4KSA9PSAxKSA9PSBUUlVFKQ0KICAgICAgICBwdWJsaWNhdGlvbmxpc3QyW1t3YXZlXV0gPC0gcHVibGljYXRpb25saXN0Mltbd2F2ZV1dWy1yZW1vdmVdDQogICAgfQ0KDQogICAgZm9yICh3YXZlIGluIDE6bGVuZ3RoKHdhdmVzKSkgew0KICAgICAgICBwdWJzIDwtIHB1YmxpY2F0aW9ubGlzdDJbW3dhdmVdXQ0KICAgICAgICBmb3IgKGVnbyBpbiAxOm5yb3coZGZfc2VsKSkgew0KICAgICAgICAgICAgIyB3aGljaCBlZ28/DQogICAgICAgICAgICBsYXN0bmFtZV9lZ28gPC0gZGZfc2VsJGxhc3RuYW1lW2Vnb10NCiAgICAgICAgICAgICMgZm9yIGFsbCBwdWJsaWNhdGlvbnMNCiAgICAgICAgICAgIGZvciAocHViIGluIDE6bGVuZ3RoKHB1YnMpKSB7DQogICAgICAgICAgICAgICAgIyBvbmx5IGNvbnRpbnVlIGlmIGVnbyBpcyBhdXRob3Igb2YgcHViDQogICAgICAgICAgICAgICAgaWYgKGxhc3RuYW1lX2VnbyAlaW4lIHB1YnNbW3B1Yl1dKSB7DQogICAgICAgICAgICAgICAgICBhdXRfcG90IDwtIHdoaWNoLm1heChwdWJzW1twdWJdXSAlaW4lIGxhc3RuYW1lX2VnbykNCiAgICAgICAgICAgICAgICAgICMgb25seSBjb250aW51ZSBpZiBlZ28gaXMgZmlyc3QgYXV0aG9yIG9mIHB1Yg0KICAgICAgICAgICAgICAgICAgaWYgKGF1dF9wb3QgPT0gMSkgew0KICAgICAgICAgICAgICAgICAgICAjIGNoZWNrIGFsbCBhbHRlcnMvY28tYXV0aG9ycw0KICAgICAgICAgICAgICAgICAgICBmb3IgKGFsdGVyIGluIDE6bnJvdyhkZl9zZWwpKSB7DQogICAgICAgICAgICAgICAgICAgICAgIyB3aGljaCBhbHRlcg0KICAgICAgICAgICAgICAgICAgICAgIGxhc3RuYW1lX2FsdGVyIDwtIGRmX3NlbCRsYXN0bmFtZVthbHRlcl0NCiAgICAgICAgICAgICAgICAgICAgICBpZiAobGFzdG5hbWVfYWx0ZXIgJWluJSBwdWJzW1twdWJdXSkgew0KICAgICAgICAgICAgICAgICAgICAgICAgbmV0d29ya2xpc3RbW3dhdmVdXVtlZ28sIGFsdGVyXSA8LSBuZXR3b3JrbGlzdFtbd2F2ZV1dW2VnbywgYWx0ZXJdICsgMQ0KICAgICAgICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgIH0NCiAgICAgICAgfQ0KICAgIH0NCiAgICByZXR1cm4obGlzdChkZiA9IGRmX3NlbCwgbmV0d29yayA9IG5ldHdvcmtsaXN0KSkNCn0NCg0KYGBgDQoNCk1vcmUgZnVuY3Rpb25zOg0KDQpgYGB7ciBmdW5jdGlvbnMgMiwgaGlkZT0gVFJVRX0NCmZjb2xuZXQgPC0gZnVuY3Rpb24oZGF0YSA9IHNjaG9sYXJzLCB1bml2ZXJzaXR5ID0gIlJVIiwgZGlzY2lwbGluZSA9ICJzb2Npb2xvZ3kiKyJwb2xpdGljYWwgc2NpZW5jZSIsIHdhdmVzID0gbGlzdChjKDIwMTUsDQogICAgMjAxOCksIGMoMjAxOSwgMjAyMykpLCB0eXBlID0gYygiZmlyc3QiKSkgew0KDQogICAgIyBzdGVwIDENCiAgICBkZW1vZ3JhcGhpY3MgPC0gZG8uY2FsbChyYmluZC5kYXRhLmZyYW1lLCBkYXRhJGRlbW9ncmFwaGljcykNCiAgICBkZW1vZ3JhcGhpY3MgPC0gZGVtb2dyYXBoaWNzICU+JQ0KICAgICAgICBtdXRhdGUoVW5pdmVyc2l0ZWl0MS4yMiA9IHJlcGxhY2UoVW5pdmVyc2l0ZWl0MS4yMiwgaXMubmEoVW5pdmVyc2l0ZWl0MS4yMiksICIiKSwgVW5pdmVyc2l0ZWl0Mi4yMiA9IHJlcGxhY2UoVW5pdmVyc2l0ZWl0Mi4yMiwNCiAgICAgICAgICAgIGlzLm5hKFVuaXZlcnNpdGVpdDIuMjIpLCAiIiksIFVuaXZlcnNpdGVpdDEuMjQgPSByZXBsYWNlKFVuaXZlcnNpdGVpdDEuMjQsIGlzLm5hKFVuaXZlcnNpdGVpdDEuMjQpLA0KICAgICAgICAgICAgIiIpLCBVbml2ZXJzaXRlaXQyLjI0ID0gcmVwbGFjZShVbml2ZXJzaXRlaXQyLjI0LCBpcy5uYShVbml2ZXJzaXRlaXQyLjI0KSwgIiIpLCBkaXNjaXBsaW5lLjIyID0gcmVwbGFjZShkaXNjaXBsaW5lLjIyLA0KICAgICAgICAgICAgaXMubmEoZGlzY2lwbGluZS4yMiksICIiKSwgZGlzY2lwbGluZS4yNCA9IHJlcGxhY2UoZGlzY2lwbGluZS4yNCwgaXMubmEoZGlzY2lwbGluZS4yNCksICIiKSkNCg0KICAgIHNhbXBsZSA8LSB3aGljaCgoZGVtb2dyYXBoaWNzJFVuaXZlcnNpdGVpdDEuMjIgJWluJSB1bml2ZXJzaXR5IHwgZGVtb2dyYXBoaWNzJFVuaXZlcnNpdGVpdDIuMjIgJWluJQ0KICAgICAgICB1bml2ZXJzaXR5IHwgZGVtb2dyYXBoaWNzJFVuaXZlcnNpdGVpdDEuMjQgJWluJSB1bml2ZXJzaXR5IHwgZGVtb2dyYXBoaWNzJFVuaXZlcnNpdGVpdDIuMjQgJWluJQ0KICAgICAgICB1bml2ZXJzaXR5KSAmIChkZW1vZ3JhcGhpY3MkZGlzY2lwbGluZS4yMiAlaW4lIGRpc2NpcGxpbmUgfCBkZW1vZ3JhcGhpY3MkZGlzY2lwbGluZS4yNCAlaW4lIGRpc2NpcGxpbmUpKQ0KDQogICAgZGVtb2dyYXBoaWNzX3NvYyA8LSBkZW1vZ3JhcGhpY3Nbc2FtcGxlLCBdDQogICAgc2Nob2xhcnNfc2VsIDwtIGxhcHBseShzY2hvbGFycywgIlsiLCBzYW1wbGUpDQoNCiAgICAjIHN0ZXAgMg0KICAgIGlkcyA8LSBkZW1vZ3JhcGhpY3Nfc29jJGF1X2lkDQogICAgbndhdmVzIDwtIGxlbmd0aCh3YXZlcykNCiAgICBuZXRzIDwtIGFycmF5KDAsIGRpbSA9IGMobndhdmVzLCBsZW5ndGgoaWRzKSwgbGVuZ3RoKGlkcykpLCBkaW1uYW1lcyA9IGxpc3Qod2F2ZSA9IDE6bndhdmVzLCBpZHMsDQogICAgICAgIGlkcykpDQogICAgZGltbmFtZXMobmV0cykNCg0KICAgICMgc3RlcCAzDQogICAgZGZfd29ya3MgPC0gdGliYmxlKHdvcmtzX2lkID0gdW5saXN0KGxhcHBseShzY2hvbGFyc19zZWwkd29yaywgZnVuY3Rpb24obCkgbCRpZCkpLCB3b3Jrc19hdXRob3IgPSB1bmxpc3QobGFwcGx5KHNjaG9sYXJzX3NlbCR3b3JrLA0KICAgICAgICBmdW5jdGlvbihsKSBsJGF1dGhvciksIHJlY3Vyc2l2ZSA9IEZBTFNFKSwgd29ya3NfeWVhciA9IHVubGlzdChsYXBwbHkoc2Nob2xhcnNfc2VsJHdvcmssIGZ1bmN0aW9uKGwpIGwkcHVibGljYXRpb25feWVhciksDQogICAgICAgIHJlY3Vyc2l2ZSA9IEZBTFNFKSkNCg0KICAgIGRmX3dvcmtzIDwtIGRmX3dvcmtzWyFkdXBsaWNhdGVkKGRmX3dvcmtzKSwgXQ0KDQogICAgIyBzdGVwIDQNCiAgICBpZiAodHlwZSA9PSAiZmlyc3QiKSB7DQogICAgICAgIGZvciAoaiBpbiAxOm53YXZlcykgew0KICAgICAgICAgICAgZGZfd29ya3NfdyA8LSBkZl93b3Jrc1tkZl93b3JrcyR3b3Jrc195ZWFyID49IHdhdmVzW1tqXV1bMV0gJiBkZl93b3JrcyR3b3Jrc195ZWFyIDw9IHdhdmVzW1tqXV1bMl0sDQogICAgICAgICAgICAgICAgXQ0KICAgICAgICAgICAgZm9yIChpIGluIDE6bnJvdyhkZl93b3Jrc193KSkgew0KICAgICAgICAgICAgICAgIGVnbyA8LSBkZl93b3Jrc193JHdvcmtzX2F1dGhvcltpXVtbMV1dJGF1X2lkWzFdDQogICAgICAgICAgICAgICAgYWx0ZXJzIDwtIGRmX3dvcmtzX3ckd29ya3NfYXV0aG9yW2ldW1sxXV0kYXVfaWRbLTFdDQogICAgICAgICAgICAgICAgaWYgKHN1bShpZHMgJWluJSBlZ28pID4gMCAmIHN1bShpZHMgJWluJSBhbHRlcnMpID4gMCkgew0KICAgICAgICAgICAgICAgICAgbmV0c1tqLCB3aGljaChpZHMgJWluJSBlZ28pLCB3aGljaChpZHMgJWluJSBhbHRlcnMpXSA8LSAxDQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgfQ0KICAgICAgICB9DQogICAgfQ0KDQogICAgaWYgKHR5cGUgPT0gImxhc3QiKSB7DQogICAgICAgIGZvciAoaiBpbiAxOm53YXZlcykgew0KICAgICAgICAgICAgZGZfd29ya3NfdyA8LSBkZl93b3Jrc1tkZl93b3JrcyR3b3Jrc195ZWFyID49IHdhdmVzW1tqXV1bMV0gJiBkZl93b3JrcyR3b3Jrc195ZWFyIDw9IHdhdmVzW1tqXV1bMl0sDQogICAgICAgICAgICAgICAgXQ0KICAgICAgICAgICAgZm9yIChpIGluIDE6bnJvdyhkZl93b3Jrc193KSkgew0KICAgICAgICAgICAgICAgIGVnbyA8LSByZXYoZGZfd29ya3NfdyR3b3Jrc19hdXRob3JbaV1bWzFdXSRhdV9pZClbMV0NCiAgICAgICAgICAgICAgICBhbHRlcnMgPC0gcmV2KGRmX3dvcmtzX3ckd29ya3NfYXV0aG9yW2ldW1sxXV0kYXVfaWQpWy0xXQ0KICAgICAgICAgICAgICAgIGlmIChzdW0oaWRzICVpbiUgZWdvKSA+IDAgJiBzdW0oaWRzICVpbiUgYWx0ZXJzKSA+IDApIHsNCiAgICAgICAgICAgICAgICAgIG5ldHNbaiwgd2hpY2goaWRzICVpbiUgZWdvKSwgd2hpY2goaWRzICVpbiUgYWx0ZXJzKV0gPC0gMQ0KICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgIH0NCiAgICAgICAgfQ0KICAgIH0NCg0KICAgIGlmICh0eXBlID09ICJhbGwiKSB7DQogICAgICAgIGZvciAoaiBpbiAxOm53YXZlcykgew0KICAgICAgICAgICAgZGZfd29ya3NfdyA8LSBkZl93b3Jrc1tkZl93b3JrcyR3b3Jrc195ZWFyID49IHdhdmVzW1tqXV1bMV0gJiBkZl93b3JrcyR3b3Jrc195ZWFyIDw9IHdhdmVzW1tqXV1bMl0sDQogICAgICAgICAgICAgICAgXQ0KICAgICAgICAgICAgZm9yIChpIGluIDE6bnJvdyhkZl93b3Jrc193KSkgew0KICAgICAgICAgICAgICAgIGVnb3MgPC0gZGZfd29ya3NfdyR3b3Jrc19hdXRob3JbaV1bWzFdXSRhdV9pZA0KICAgICAgICAgICAgICAgIGlmIChzdW0oaWRzICVpbiUgZWdvcykgPiAwKSB7DQogICAgICAgICAgICAgICAgICBuZXRzW2osIHdoaWNoKGlkcyAlaW4lIGVnb3MpLCB3aGljaChpZHMgJWluJSBlZ29zKV0gPC0gMQ0KICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgIH0NCiAgICAgICAgfQ0KICAgIH0NCiAgICBvdXRwdXQgPC0gbGlzdCgpDQogICAgb3V0cHV0JGRhdGEgPC0gc2Nob2xhcnNfc2VsDQogICAgb3V0cHV0JG5ldHMgPC0gbmV0cw0KICAgIHJldHVybihvdXRwdXQpDQp9DQpgYGANCg0KIyBHZXQgRGF0YQ0KDQpMb2FkIFNjaG9sYXIgRGF0YQ0KDQpgYGB7ciBzY2hvbGFyIGRhdGF9DQpzY2hvbGFycyA8LSBmbG9hZCgiLi9kYXRhL3Byb2Nlc3NlZC9zY2hvbGFyc18yMDI0MDkyNC5yZGEiKSANCmBgYA0KDQpTYXZlIHRoZSBvdXRwdXQgb2YgdGhlIGZ1bmN0aW9uLg0KDQpgYGB7ciBzYXZpbmcgb3V0cHV0fQ0KIyBzYXZlIHRoZSBvdXRwdXQgb2YgeW91ciBmdW5jdGlvbg0KdGVzdCAgPC0gZmNvbG5ldChkYXRhID0gc2Nob2xhcnMsIA0KICAgICAgICAgICAgICAgIHVuaXZlcnNpdHkgPSAiUlUiLCANCiAgICAgICAgICAgICAgICBkaXNjaXBsaW5lID0gYygic29jaW9sb2d5IiwgInBvbGl0aWNhbCBzY2llbmNlIiksDQogICAgICAgICAgICAgICAgd2F2ZXMgPSBsaXN0KGMoMjAxNSwgMjAxOCksIGMoMjAxOSwgMjAyMykpLCANCiAgICAgICAgICAgICAgICB0eXBlID0gYygiZmlyc3QiKSkNCmBgYA0KDQpMb2FkIEVnbyBEYXRhDQoNCmBgYHtyIGRmX2VnbyBkYXRhLCBpbmNsdWRlPSBGQUxTRX0NCmRmX2VnbyA8LSBmbG9hZCgiLi9kYXRhL3Byb2Nlc3NlZC9kZl9lZ29fMjAyNDExMDgucmRhIikNCg0KYGBgDQoNCiMgTWFrZSBOZXR3b3JrIERhdGENCg0KYGBge3IgUlNpZW5hIG5ldHdvcmsgZGF0YX0NCiNzdGVwMSBkYXRhDQp3YXZlMSA8LSB0ZXN0JG5ldHNbMSwsXQ0Kd2F2ZTIgPC0gdGVzdCRuZXRzWzIsLF0NCg0KIyBwdXQgbmV0cyBpbiBhbiBhcnJheQ0KbmV0X2FycmF5IDwtIGFycmF5KGRhdGEgPSBjKHdhdmUxLCB3YXZlMiksIGRpbSA9IGMoZGltKHdhdmUxKSwgMikpDQoNCmBgYA0KDQotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0NCg0KIyBBbmFseXNpcw0KDQpgYGB7PWh0bWx9DQo8IS0tDQojIyBURVNUIE1PREVMDQoNCiMjIyB0ZXN0IDE6IERlZmluZSBTaWVuYSBEYXRhICYgVmFyaWFibGVzDQotLT4NCmBgYA0KYGBge3IgUlNpZW5hIGRlZmluZSwgaGlkZSA9VFJVRSwgZWNobz1GQUxTRSwgZXZhbD1GQUxTRX0NCiMgZGVwZW5kZW50IHZhcmlhYmxlIA0KbmV0cyA8LSBzaWVuYURlcGVuZGVudChuZXRfYXJyYXkpDQoNCiMgcHV0IGdlbmRlciBpbiBvYmplY3QgDQpnZW5kZXIgPC0gZGZfZWdvJGdlbmRlcg0KDQojIGNvdmFyaWF0ZSAxDQpnZW5kZXJfUlMgPC0gY29Db3ZhcihnZW5kZXIpICMgZ2VuZGVyIGFzIGNvdmFyaWF0ZSBpbiBSc2llbmENCg0KDQojIHB1dCBoLWluZGV4IGluIG9iamVjdCANCmhfaW5kZXggPC0gZGZfZWdvJGhfaW5kZXgNCmRmX2VnbyRoX2luZGV4DQoNCiMgY292YXJpYXRlIDINCmhfaW5kZXhfUlMgPC0gY29Db3ZhcihoX2luZGV4KSAjIGhfaW5kZXggYXMgY292YXJpYXRlIGluIFJTaWVuYQ0KDQojIGRlZmluZSBkYXRhIG9iamVjdCANCm15ZGF0YSA8LSBzaWVuYURhdGFDcmVhdGUobmV0cywgZ2VuZGVyX1JTLCBoX2luZGV4X1JTKQ0KDQpgYGANCg0KPCEtLSBQcmludCBzaG9ydCBkZXNjcmlwdGl2ZSByZXBvcnQtLT4NCg0KYGBge3IsIGhpZGUgPVRSVUUsIGVjaG89RkFMU0UsIGV2YWw9RkFMU0V9DQppZmVsc2UoIWRpci5leGlzdHMoInJlc3VsdHMiKSwgZGlyLmNyZWF0ZSgicmVzdWx0cyIpLCBGQUxTRSkNCg0KI2lmIHRoZXJlIGlzIG5vdCBhIGZvbGRlciBjYWxsZWQgInJlc3VsdHMiIGluIHlvdXIgcmVwb3NpdG9yeTogbWFrZSBvbmUNCg0KYGBgDQoNCmBgYHtyLCBoaWRlID1UUlVFLCBlY2hvPUZBTFNFLCBldmFsPUZBTFNFfQ0KcHJpbnQwMVJlcG9ydChteWRhdGEsIG1vZGVsbmFtZSA9ICIuL3Jlc3VsdHMvdHJ5IikgIyBjcmVhdGUgZmlsZSB3aXRoIHJlcG9ydCBpbiByZXN1bHRzIGZvbGRlciANCmBgYA0KDQo8IS0tICMjIyB0ZXN0IDI6IE1ha2UgZWZmZWN0cyBvYmplY3Qvc3RydWN0dXJlIC0tPg0KDQpgYGB7ciBSU2llbmEgbXllZmYsIGhpZGUgPVRSVUUsIGVjaG89RkFMU0UsIGV2YWw9RkFMU0V9DQoNCiMgZGVmaW5lIGVmZmVjdHMgc3RydWN0dXJlIA0KbXllZmYgPC0gZ2V0RWZmZWN0cyhteWRhdGEpDQoNCmBgYA0KDQpgYGB7PWh0bWx9DQo8IS0tDQoNCmUuZy4gb3V0ZGVncmVlIChkZW5zaXR5KSwgY2FsbGVkIGRlbnNpdHksIHRocmVlIHRoaW5nczogZXZhbHVhdGlvbiwNCmVuZG93bWVudCwgYW5kIGNyZWF0aW9uIHlvdSBjYW4gb25seSBpbmNsdWRlIHR3byBvZiB0aGUgdGhyZWUgKHRpZQ0KY3JlYXRpb24sIGJyZWFraW5nIGFuZCBtYWludGFpbmluZykNCg0KVGhlIGFzc3VtcHRpb24gaXM6IG1lY2hhbmlzbXMgdG8gbWFrZSBhbmQgYnJlYWsgYSBhIHRpZSBhcmUgdGhlIHNhbWUgc28NCldFIE9OTFkgVVNFIFRIRSBFVkFMVUFUSU9OIHBhcnQNCg0KQWxsIHRoZXNlIGVmZmVjdHMgYXJlIGRlc2NyaWJlZCBpbiB0aGUgbWFudWFsIG9mIFJTaWVuYSBDaGFwdGVyIDEyIQ0KDQotLT4NCmBgYA0KYGBgez1odG1sfQ0KPCEtLSAgDQojIyMgU3RlcCBYOiBJbml0aWFsIGRlc2NyaXB0aW9uDQotLT4NCmBgYA0KYGBgez1odG1sfQ0KPCEtLQ0KSGFzIGEgbG90IG9mIGluZm9ybWF0aW9uIGluIHRoZXJlIEFsc286IGhvdyB0aWUgQ0hBTkdFRCBBbHNvOiBKYWNjYXJkDQppbmRleCAobWVhc3VyZSBvZiBzdGFiaWxpdHkpIEFsc28gcmF0ZSBwYXJhbWV0ZXIgYW5kIG91dGRlZ3JlZQ0KDQo8aHR0cHM6Ly93d3cuc3RhdHMub3guYWMudWsvfnNuaWpkZXJzL3NpZW5hL1JTaWVuYV9NYW51YWwucGRmPg0KDQpJbiB0aGUgcGFja2FnZSBSc2llbmFUd29TdGVwIHRoZXJlIGFyZSBmdW5jdGlvbnMgZm9yIHRoZSBmb2xsb3dpbmcNCm5ldHdvcmsgc3RhdGlzdGljcyAqKipzKioqIDoNCg0KZGVncmVlOiBgdHNfZGVncmVlKClgDQoNCnJlY2lwcm9jaXR5OiBgdHNfcmVjaXAoKWANCg0Kb3V0ZGVncmVlIGFjdGl2aXR5OiBgdHNfb3V0QWN0KClgDQoNCmluZGVncmVlIGFjdGl2aXR5OiBgdHNfaW5BY3QoKWANCg0Kb3V0ZGVncmVlIHBvcHVsYXJpdHk6IGB0c19vdXRQb3AoKWANCg0KaW5kZWdyZWUgcG9wdWxhcml0eTogYHRzX2luUG9wKClgDQoNCnRyYW5zaXRpdml0eTogYHRzX3RyYW5zVHJpcCgpYA0KDQptZWRpYXRlZCB0cmFuc2l0aXZpdHk6IGB0c190cmFuc01lZFRyaXAoKWANCg0KdHJhbnNpdGl2ZSByZWNpcHJvY2F0ZWQgdHJpcGxldHM6IGB0c190cmFuc1JlY1RyaXAoKWANCg0KbnVtYmVyIG9mIHRocmVlLWN5Y2xlczogYHRzX2N5Y2xlMygpYA0KLS0+DQpgYGANCjwhLS0gIyMjIHRlc3QgMzogQWRkIEVmZmVjdHMgLS0+DQoNCmBgYHtyIGVmZmVjdHMsIGhpZGUgPVRSVUUsIGVjaG89RkFMU0UsIGV2YWw9RkFMU0V9DQoNCiMgTnVsbCBtb2RlbDoganVzdCBteWVmZiAoanVzdCBkZWdyZWUgYW5kIHJlY2lwcm9jaXR5IGJ5IGRlZmF1bHQpICMgbW9kZWwwICAjZm9yIHRoaXMgd2hlbiB5b3UgY3JlYXRlIFNpZW5hIERhdGEsIGRvIG5vdCBhZGQgdGhlIGdlbmRlciB2YXJpYWJsZSANCg0KbXllZmYgPC0gaW5jbHVkZUVmZmVjdHMobXllZmYsIGlzb2xhdGVOZXQsIGluUG9wLCBvdXRBY3QpIA0KIyBpc29sYXRlbmV0OiBpZiBpbmRpdmlkdWFsIGlzIGFsb25lIHRoZXkgImxpa2UgdG8vdGVuZCB0byBzdGF5IGFsb25lIg0KIyBpblBvcDogcHBsIGxpa2UgdG8gY29sbGFiIHdpdGggcGVvcGxlIHdobyBhcmUgcG9wdWxhcg0KICAjIG92ZXIgdGltZTogaW5wb3A6IHBwbCB3aXRoIGxvdHMgb2YgaW5kZWdyZWVzIHdpbGwgaGF2ZWxvdCBvZiBpbmRlZ3JlZXMNCg0KI24tZGVncmVlIHJlbGF0ZWQgcG9wdWxhcml0eSBlZmZlY3QgKGluUG9wKSAoZWFybGllciBjYWxsZWQgcG9wdWxhcml0eSBvciBwb3B1bGFyaXR5IG9mIGFsdGVyIGVmZmVjdCksIGRlZmluZWQgYnkgdGhlIHN1bSBvZiB0aGUgaW4tZGVncmVlcyBvZiB0aGUgb3RoZXJzIHRvIHdob20gaSBpcyB0aWVkLA0KDQojIGxhdGVyIChpbiBwb3B1bGF0aW9uKSBvdXRBY3Q6IHBwbCB3aXRoIGxvdHMgb2Ygb3V0ZGVncmVlcyB3aWxsIGhhdmUgbG90DQojIG9mIGluZGVncmVlcyBsYXRlcg0KDQoNCm15ZWZmIDwtIGluY2x1ZGVFZmZlY3RzKG15ZWZmLCBlZ29YLCBhbHRYLCBzYW1lWCwgaW50ZXJhY3Rpb24xID0gImdlbmRlcl9SUyIpICMgbW9kZWwxDQojIGluY2x1ZGUgZWZmZWN0IG9mIGggaW5kZXggbGF0ZXIgdG9vIGV0Yw0KIyBsb29rIHVwIHdoaWNoIGVmZmVjdHMgdG8gaW5jbHVkZQ0KDQoNCg0KDQpteWVmZiA8LSBpbmNsdWRlRWZmZWN0cyhteWVmZiwgZWdvWCwgYWx0WCwgaW5Qb3BYLCBpbnRlcmFjdGlvbjEgPSAiaF9pbmRleF9SUyIpICMgbW9kZWwgMiAoYXMgbG9uZyBhcyBteWVmZiBpcyBlaXRoaW4gdGhlIGJyYWNrZXRzIHRvbywgdGhlIG90aGVyIHRoaW5ncyBnZXQgYWRkZWQgdG8gdGhlIG15ZWZmIG9iamVjdCkNCg0KDQojIGNoYW5nZSBzdGF0aXN0aWNzIHRvIGZpdCB3aGF0ZXZlciBJIHdhbnQgdG8ga25vdyBhYm91dCBoLWluZGV4IA0KIyBub3Qgc2FtZVggDQojIGxvb2sgdXAgaW5Qb3BYOiBwcmVmZXJlbnRpYWwgYXR0YWNobWVudCAoY2YuIEtvZW4gbGVsKSwgaGlnaGVyIGgtaW5kZXggbW9yZSBwb3B1bGFyIA0KICAjIGNmLiBGcmlkYXMgbW9kZWxpbmcgcHJvY2VzcyAoSm9jaGVtIHRvbGQgaGVyIHRoYXQgKQ0KDQojZGlmZlhUcmFuc1RyaXANCiNkaWZmZXJlbnQgY292YXJpYXRlIMOXIHRyYW5zaXRpdmUgdHJpcGxldHMgKGRpZmZYVHJhbnNUcmlwKSwgZGVmaW5lZCBieSB0aGUgbnVtYmVyIG9mIHRyYW5zaXRpdmUgdHJpcGxldHMgaSDihpIgaCDihpIgaiDihpAgaSB0aGF0IGhhdmUgZGlmZmVyZW50IGNvdmFyaWF0ZSB2YWx1ZXMgZm9yIGkgYW5kIGosIGRpZmYuIGNvdi4gdmFsdWVzID0gZGlmZiBnZW5kZXIgLVJTaWVuYSBtYW51YWwgDQoNCiMgIlRoZSB0cmFuc3RyaXAgZm9yIGRpZmZlcmVudCBnZW5kZXIgKGRpZmZYVHJhbnNUcmlwKSBpcyBwb3NpdGl2ZSBhbmQgc2lnbmlmaWNhbnQsIHdoaWNoIGltcGxpZXMgdGhhdCBhbiBlZ28gcHJlZmVycyB0byBjbG9zZSB0cmlhZHMgd2l0aCBhbHRlcnMgd2hvIGhhdmUgYSBkaWZmZXJlbnQgZ2VuZGVyIHNjb3JlIHRoYW4gdGhlaXJzLiBUaGlzIGlzIGFuIGludGVyZXN0aW5nIGZpbmRpbmcsIGJlY2F1c2UgaXQgaW1wbGllcyB0aGF0IHRoZWlyIGlzIGEgdGVuZGVuY3kgdG93YXJkcyBkaXZlcnNlIGNvbGxhYm9yYXRpb24uIEhvd2V2ZXIsIHdoZW4gY29tcGFyZWQgdG8gdGhlIGxldmVsIG9mIGdlbmRlciBjbHVzdGVyaW5nIGFuZCB0aGUgZmFjdCB0aGF0IHRoaXMgY2x1c3RlcmluZyBkZWNyZWFzZWQsIHRoaXMgZmluZGluZyBkb2VzIG1ha2Ugc2Vuc2UuIiAtIE5pZWxzDQoNCg0KYGBgDQoNCmBgYHs9aHRtbH0NCjwhLS0gDQoNCg0KaGludCBGT1IgTVkgT1dOIFBST0pFQ1Q6IGludGVyYWN0aW9uIGVmZmVjdCBvZiB0aGVzZSBzdGF0aXN0aWNzIGFuZCB0aGUNCmVmZmVjdCBvZiBnZW5kZXINCg0KVEhFICJYIiBpbiBhbHRYIGFuZCBlb2dYIHJlZmVyIHRvIHRoZSAiaW50ZXJhY3Rpb24gMSIgdmFyaWFibGUsIHNvIGl0J3MgZWcuIGVnbyB4IGdlbmRlcl9SUyBhbmQgYWx0ZXIgeCBnZW5kZXJfUlMhDQoNCmFsdFggLSBlZ29zIHNlbmQgbW9yZSB0aWVzIHdobyBoYXZlIG1vcmUgb24gZ2VuZGVyIChha2EuIGdlbmRlciA9MSkgDQooaWlpaXNoIGxvb2sgYXQgZWdvWCBleHBsYW5hbnRpb24sIHRoaXMgaXMgYmFzaWNhbGx5IHRoZSBzYW1lIGJ1dCBpbiAicmV2ZXJzZSIsIGFrYSBhYm91dCByZWNlaXZpbmcgcmF0aGVyIHRoYW4gc2VuZGluZykNCg0KLSAgIGNvdmFyaWF0ZS1hbHRlciBvciBjb3ZhcmlhdGUtcmVsYXRlZCBwb3B1bGFyaXR5IChhbHRYKSwgZGVmaW5lZCBieQ0KICAgIHRoZSBzdW0gb2YgdGhlIGNvdmFyaWF0ZSBvdmVyIGFsbCBhY3RvcnMgdG8gd2hvbSAqKippKioqIGhhcyBhIHRpZSwNCi0gICBzYW1lIGFzIGVnb1ggYnV0IFJFQ0VJVklORyB0aWVzDQoNCmVnb1ggLSBbZGVmaW5pdGlvbj9dDQoNCi0gICBjb3ZhcmlhdGUtZWdvIG9yIGNvdmFyaWF0ZS1yZWxhdGVkIGFjdGl2aXR5IChlZ29YKSwgZGVmaW5lZCBieSBp4oCZcw0KICAgIG91dC1kZWdyZWUgd2VpZ2h0ZWQgYnkgaGlzIGNvdmFyaWF0ZSB2YWx1ZSwNCi0gICBzaW5jZSBtYWxlID0gMSBlZ29YIG9ubHkgImxvb2tzIGF0IiBtZW4ncyB0aWVzIA0KLSAgIGlmIGVnb1ggc2lnbmlmaWNhbnQgdGhlbiBtZW4ncyB0aWVzIHNpZ24uIGRpZmYuIGJhc2VkIG9uIHdoZXRoZXIgaXRzIHRvIGEgbWFuIG9yIHdvbWFuIChsb29rIGF0IGRpcmVjdGlvbiBvZiBlZmZlY3QgdG8ga25vdyB3aGljaCBnZW5kZXIpIA0KDQoNCiJpbnRlcmFjdGlvbjEiIEhBUyBOT1RISU5HIFRPIERPIFdJVEggQU4gSU5URVJBQ1RJT04gRUZGRUNUDQoNCi0gICBJZiB0aGVyZSBhcmUgc2V2ZXJhbCBkZXBlbmRlbnQgdmFyaWFibGVzIChuZXR3b3JrcyBhbmQvb3IgYmVoYXZpb3JhbA0KICAgIHZhcmlhYmxlcyksIHRoZSBuYW1lIG9mIHRoZSBkZXBlbmRlbnQgdmFyaWFibGUgKG5hbWUpIGFsc28gaXMNCiAgICByZXF1aXJlZCB0byBzcGVjaWZ5IHRoZSBlZmZlY3QsIGFuZCB3aWxsIGJlIGdpdmVuIGluIHRoZSBjb2x1bW4NCiAgICBpbnRlcmFjdGlvbjEgKGV0Yy4pIG9mIHRoZSBlZmZlY3RzIG9iamVjdC4NCg0KLSAgIEl0IHNob3VsZCBiZSBtZW50aW9uZWQgdGhhdCB0aGUga2V5d29yZHMgaW50ZXJhY3Rpb24xLCBpbnRlcmFjdGlvbjIsDQogICAgYW5kIGludGVyYWN0aW9uMyBpbiBmdW5jdGlvbnMgc3VjaCBhcyBpbmNsdWRlRWZmZWN0cyBkbyBub3QgcG9pbnQgdG8NCiAgICBpbnRlcmFjdGlvbnMgYmV0d2VlbiBlZmZlY3RzLiBUaGVzZSBrZXl3b3JkcyBhcmUgdXNlZCBvbmx5IHRvDQogICAgZXhhY3RseSBzcGVjaWZ5IGFuIGVmZmVjdC4gVGhleSBwb2ludCB0byB0aGUgY292YXJpYXRlIG9yIG90aGVyDQogICAgZGVwZW5kZW50IHZhcmlhYmxlIHVzZWQgaW4gdGhlIGVmZmVjdDsgdGhpcyBuYW1lIHdhcyBjaG9zZW4gZm9yIHRoZQ0KICAgIGtleXdvcmQgYmVjYXVzZSB0aGlzIG90aGVyIHZhcmlhYmxlIG1heSBiZSBzYWlkIHRvIGJlIGludGVyYWN0aW5nDQogICAgd2l0aCB0aGUgZGVwZW5kZW50IHZhcmlhYmxlIChuZXR3b3JrIG9yIGJlaGF2aW9yKS4NCg0KLS0+DQpgYGANCjwhLS0gIyMjIHRlc3QgNDogU3BlY2lmeSBtb2RlbC9hbGdvcml0aG0gLS0+DQoNCmBgYHtyIGFsZ28sIGhpZGUgPVRSVUUsIGVjaG89RkFMU0UsIGV2YWw9RkFMU0V9DQojIEFsZ29yaXRobSBmcm9tIHdoZW4gSm9jaGVtIGFuZCBJIHNhdCB0b2dldGhlciBidXQgaXQncyBub3QgZml0dGluZyBhbnltb3JlIGJjIG1vZGVsIHR5cGUgaXMgZm9yIHVuZGlyZWN0ZWQgdGllcyANCiMgbXlBbGdvcml0aG0gPC0gc2llbmFBbGdvcml0aG1DcmVhdGUobW9kZWxUeXBlID0gYyhuZXRzPTYpLCBwcm9qbmFtZSA9ICJwcm9Qcm9qZWN0IikNCiMgdW5kaXJlY3RlZDogbW9kZWwgNiAiYWRkaXRpdmUgbW9kZWwiLCAjY2hlY2sgbWFudWFsIGZvciB0aGlzIE5PVyBJVCdTIFVORElSRUNURUQhISEgDQoNCiMgTmllbHMgYWR2aWNlOiB0YWtlIGhpcyBhbGdvcml0aG0gaW5zdGVhZC4gaGFoYSBvaywgbm8gcXVlc3Rpb25zIGFza2VkIG15IGd1eSwgeW91IGdvdCBpdC4gDQpteUFsZ29yaXRobV90ZXN0IDwtIHNpZW5hQWxnb3JpdGhtQ3JlYXRlIChwcm9qbmFtZSA9ICJyZXN1bHRzX3Rlc3QiKQ0KDQpgYGANCg0KPCEtLSAjIyMgdGVzdCA1OiBFc3RpbWF0ZSBtb2RlbCAtLT4NCg0KYGBge3IgZXN0aW1hdGUsIGhpZGUgPVRSVUUsIGVjaG89RkFMU0UsIGV2YWw9RkFMU0V9DQojIGVzdGltYXRlIHRoZSBtb2RlbCANCm1vZGVsX3Rlc3QgPC0gc2llbmEwNyhteUFsZ29yaXRobV90ZXN0LCBkYXRhID0gbXlkYXRhLCBlZmZlY3RzID0gbXllZmYsIHJldHVybkRlcHMgPSBUUlVFKQ0KI2xhdHRlciBuZWVkZWQgZm9yIEdPRiBsYXRlcm9uDQoNCm1vZGVsX3Rlc3QNCg0KYGBgDQoNCmBgYHs9aHRtbH0NCjwhLS0gDQpvdXRwdXQ6ICBjb252ZXJnZW5jZSByYXRpb24gTkEgcHJvYmFibHkgYmMgd2UgY2hvc2UgYWxsIHRpZXMgdG8gYmUgaW5jbHVkZWQgKHR5cGUgPSAiYWxsIikgZWFybGllcg0Kd2UgY2FuIGdvIGJhY2sgYW5kIGNoYW5nZSB0aGF0IG9yIGNoYW5nZSBpdCBoZXJlIGluIHRoZSBteUFsZ29yaXRobSBmdW5jdGlvbg0KDQpjb252ZXJnZW5jZSByYXRpbyBzaG91bGQgYmUgPC4yNSAgICEhIQ0KLSBpZiBhYm92ZSwgcnVuIG1vZGVsIGFnYWluDQotIGlmIHN0YXlzIGFib3ZlIC4yNSwgcmVtb3ZlIHNvbWUgb2YgdGhlIG5ldHcuIHN0YXRzDQotIGlmIGNsb3NlIHRvIHRocmVzaG9sZCAoZS5nLiAwLjI1ODQpIGFkZCBwcmV2QW5zID0gbW9kZWwxICB0byB0aGUgc2llbmEwNyBjb21tYW5kIGFuZCByZXJ1biB0aGVuDQogICAgICBtb2RlbDEgPC0gc2llbmEwNyhteUFsZ29yaXRobSwgZGF0YSA9IG15ZGF0YSwgZWZmZWN0cyA9IG15ZWZmLCBwcmV2QW5zPSBtb2RlbDEsIHJldHVybkRlcHMgPSBUUlVFKQ0KDQotLT4NCmBgYA0KPCEtLSAjIyMgdGVzdCA2OiBHT0YgLSBHb29kbmVzcyBvZiBGaXQgLS0+DQoNCmBgYHtyIEdPRiB0ZXN0LCBoaWRlID1UUlVFLCBlY2hvPUZBTFNFLCBldmFsPUZBTFNFfQ0KR09GIDwtIHNpZW5hR09GKG1vZGVsX3Rlc3QsIEluZGVncmVlRGlzdHJpYnV0aW9uLCB2ZXJib3NlID0gRkFMU0UsIGpvaW4gPSBUUlVFLCB2YXJOYW1lID0gIm5ldHMiKQ0KDQpwbG90KEdPRiwgbWFpbiA9ICJUZXN0IEluZGVncmVlIERpc3RyIikNCg0KDQojICJFcnJvciB1c2luZyBwYWNrZXQgMSAiYnciIGlzIG5vdCBwb3NpdGl2ZSINCg0KIy0tLS0tLS0tLSBUcnkgdG8gZml4IGVycm9yOiAgLS0tLS0tLSAgDQojIy0tLS0tLS0tLSBJbnNwZWN0IEdPRiBvYmplY3QgIC0tLS0tLS0gDQojIHN0cihHT0YpDQogICMgc3VtbWFyeShHT0YkSm9pbnQkU2ltdWxhdGVkVGVzdFN0YXQpDQoNCiMjLS0tLS0tLS0tIENoZWNrIGZvciBpbnZhbGlkIC9pbmZpbnRlIHZhbHVlcyAtLS0tLS0tIA0KICAgICMgYW55TkEoR09GJEpvaW50JFNpbXVsYXRlZFRlc3RTdGF0KSAgIyBTaG91bGQgcmV0dXJuIEZBTFNFDQogICAgIyBhbnkoIWlzLmZpbml0ZShHT0YkSm9pbnQkU2ltdWxhdGVkVGVzdFN0YXQpKSAgIyBTaG91bGQgcmV0dXJuIEZBTFNFDQogICAgIyBzdW1tYXJ5KEdPRiRKb2ludCRTaW11bGF0ZWRUZXN0U3RhdCkgICMgSW5zcGVjdCB0aGUgcmFuZ2Ugb2YgdmFsdWVzDQoNCg0KICAgICMgR2V0IHJpZCBvZiBpbnZhbGlkIG9yIGluZmluaXRlIHZhbHVlcw0KICAgICAgICAjIEdPRiRKb2ludCRTaW11bGF0ZWRUZXN0U3RhdCA8LSBuYS5vbWl0KEdPRiRKb2ludCRTaW11bGF0ZWRUZXN0U3RhdCkNCiAgICAgICAgIyBHT0YkSm9pbnQkU2ltdWxhdGVkVGVzdFN0YXQgPC0gICBHT0YkSm9pbnQkU2ltdWxhdGVkVGVzdFN0YXRbaXMuZmluaXRlKEdPRiRKb2ludCRTaW11bGF0ZWRUZXN0U3RhdCldDQoNCiAgIyB2YXIoR09GJEpvaW50JFNpbXVsYXRlZFRlc3RTdGF0KSAgIyBTaG91bGQgcmV0dXJuIGEgcG9zaXRpdmUgdmFsdWUNCg0KDQojIy0tLS0tLS0tLSBEZW5zaXR5IHNpbXVsYXRpb24gIC0tLS0tLS0gDQogICAgIyBzaW11bGF0ZWQgPC0gR09GJEpvaW50JFNpbXVsYXRlZFRlc3RTdGF0DQogICAgIyAjIFRyeSBkZW5zaXR5IGVzdGltYXRpb24gd2l0aCBkZWZhdWx0IGJhbmR3aWR0aA0KICAgICMgICBkZW5zaXR5X2VzdCA8LSB0cnlDYXRjaChkZW5zaXR5KHNpbXVsYXRlZCksIGVycm9yID0gZnVuY3Rpb24oZSkgZSkNCiAgICAjICAgaWYgKGluaGVyaXRzKGRlbnNpdHlfZXN0LCAiZXJyb3IiKSkgew0KICAgICMgICBwcmludCgiRGVuc2l0eSBlc3RpbWF0aW9uIGZhaWxlZC4iKQ0KICAgICMgICAgIH0gZWxzZSB7DQogICAgIyAgICAgICAgICAgICBwcmludCgiRGVuc2l0eSBlc3RpbWF0aW9uIHN1Y2NlZWRlZC4iKQ0KICAgICMgICAgICAgICAgICAgcGxvdChkZW5zaXR5X2VzdCwgbWFpbiA9ICJTaW11bGF0ZWQgVGVzdCBTdGF0aXN0aWNzIikNCiAgICAjICAgICB9DQogICAgIyAgIA0KIyMtLS0tLS0tLS0gRm9yY2UgYmFuZHdpZHRoIC0tLS0tLS0gICAgIA0KICAgICAgIyBGb3JjZSB0aGUgQmFuZHdpZHRoIGluIHBsb3Quc2llbmFHT0YNCiAgICAgICMgcGxvdChHT0YsIG1haW4gPSAiSW5kZWdyZWUgRGlzdHJpYnV0aW9uIEdvb2RuZXNzIG9mIEZpdCIsIGJ3ID0gMC41KQ0KICAgICAgIyAjbm9wZSBkb2VzIG5vdCB3b3JrIA0KDQojIy0tLS0tLS0tLSBDdXN0b20gZnVuY3Rpb24gLS0tLS0tLSAgDQogICAgICAjIGN1c3RvbV9wbG90X3NpZW5hR09GIDwtIGZ1bmN0aW9uKGdvZiwgYncgPSAwLjUsIC4uLikgew0KICAgICAgIyBzaW11bGF0ZWQgPC0gZ29mJEpvaW50JFNpbXVsYXRlZFRlc3RTdGF0DQogICAgICAjIG9ic2VydmVkIDwtIGdvZiRKb2ludCRPYnNlcnZlZFRlc3RTdGF0DQogICAgICAjIA0KICAgICAgIyAjIFBlcmZvcm0gZGVuc2l0eSBlc3RpbWF0aW9uIHdpdGggZm9yY2VkIGJhbmR3aWR0aA0KICAgICAgIyBkZW5zaXR5X2VzdCA8LSBkZW5zaXR5KHNpbXVsYXRlZCwgYncgPSBidykNCiAgICAgICMgDQogICAgICAjICMgUGxvdCB0aGUgZGVuc2l0eQ0KICAgICAgIyBwbG90KGRlbnNpdHlfZXN0LCBtYWluID0gIkN1c3RvbSBJbmRlZ3JlZSBEaXN0ci4tIEdPRiIsIC4uLikNCiAgICAgICMgYWJsaW5lKHYgPSBvYnNlcnZlZCwgY29sID0gInJlZCIsIGx0eSA9IDIsIGx3ZCA9IDIpIA0KICAgICAgIyB9DQogICAgICAjIA0KICAgICAgIyAgI3J1biBjdXN0b20gZnVuY3Rpb24gICAgICANCiAgICAgICMgY3VzdG9tX3Bsb3Rfc2llbmFHT0YoR09GLCBidyA9IDAuNSkNCiAgICAgICMgIyB3b3JrcyBidXQgbm90IHRoZSBzYW1lIGF0IGFsbCANCiAgICAgICMgDQojIy0tLS0tLS0tLSBHZ3Bsb3QyIC0tLS0tLS0gDQojIEZ1Y2sgdGhpcyBzaGl0LiBJIHVzaW5nIGdncGxvdCANCiAgICAjIGxpYnJhcnkoZ2dwbG90MikNCiAgICAjIA0KICAgICMgIyBQcmVwYXJlIGRhdGENCiAgICAjIGRhdGEgPC0gZGF0YS5mcmFtZSgNCiAgICAjICAgdmFsdWUgPSBHT0YkSm9pbnQkU2ltdWxhdGVkVGVzdFN0YXQsDQogICAgIyAgIHR5cGUgPSAiU2ltdWxhdGVkIg0KICAgICMgKQ0KICAgICMgZGF0YSA8LSByYmluZChkYXRhLCBkYXRhLmZyYW1lKHZhbHVlID0gR09GJEpvaW50JE9ic2VydmVkVGVzdFN0YXQsIHR5cGUgPSAiT2JzZXJ2ZWQiKSkNCiAgICAjIA0KICAgICMgIyBQbG90IGRlbnNpdHkNCiAgICAjIGdncGxvdChkYXRhLCBhZXMoeCA9IHZhbHVlLCBmaWxsID0gdHlwZSkpICsNCiAgICAjICAgZ2VvbV9kZW5zaXR5KGFscGhhID0gMC41LCBhZGp1c3QgPSAxLCBidyA9IDAuNSkgKw0KICAgICMgICBnZW9tX3ZsaW5lKHhpbnRlcmNlcHQgPSBHT0YkSm9pbnQkT2JzZXJ2ZWRUZXN0U3RhdCwgY29sb3IgPSAicmVkIiwgbGluZXR5cGUgPSAiZGFzaGVkIikgKw0KICAgICMgICBnZ3RpdGxlKCJJbmRlZ3JlZSBEaXN0cmlidXRpb24gR29vZG5lc3Mgb2YgRml0IikgKw0KICAgICMgICB0aGVtZV9taW5pbWFsKCkNCg0KIyB3b3JrcyBidXQgaXQncyB0aGUgc2FtZSB0aGluZyBhcyB3aXRoIHRoZSBjdXN0b20gZnVuY3Rpb24uLi4gSXQgbm90IGEgdmlvbGluLXBsb3QgYW5kIGp1c3QgZG9lcyBub3QgaGl0IHRoZSBzcG90LiANCiMgVGhlIG9ubHkgdmlvbGlucyBJIGhhdmUgYXJlIHRoZSBvbmVzIHBsYXlpbmcgdGhlIHNhZCBzZWxmLXBpdHkgbXVzaWMgaW4gbXkgYnJhaW4gcmlnaHQgbm93LiANCg0KIyMtLS0tLS0tLS0gcmVpbnN0YWxsIFJTaWVuYSAtLS0tLS0tIA0KDQojIEkuLi4uIA0KICAgICMgLi4uLg0KICAgICAgIyAuLi4uIA0KICAgICAgICAjIC4uLi4gc3VyZS4gIA0KDQoNCiMgLS0tLS0tLS0tIEkgaGF0ZSBteXNlbGYgYW5kIGJhY2sgd2UgZ28gdG8gR09GIC0tLS0tDQojIG90aGVyIHNpZW5hIEdPRiBmdW5jdGlvbnMgKG91dGRlZ3JlZSBkb2VzIG5vdCB3b3JrIGVpdGhlciwgR2VvZGVzaWNEaXN0cmlidXRpb24gd2VpcmRseSBlbm91Z2ggd29ya3MuKQ0KDQojZ29mbzAgPC0gc2llbmFHT0YobW9kZWxfdGVzdCwgT3V0ZGVncmVlRGlzdHJpYnV0aW9uLCB2ZXJib3NlID0gRkFMU0UsIGpvaW4gPSBUUlVFLCBsZXZscyA9IGMoMDoxMCwgMTUsIDIwKSwgdmFyTmFtZSA9ICJuZXRzIikNCiNwbG90KGdvZm8wLCBtYWluID0iVGVzdCBPdXRkZWdyZWUgRGlzdHIiKQ0KDQojZ29mMC5nZCA8LSBzaWVuYUdPRihtb2RlbF90ZXN0LCBHZW9kZXNpY0Rpc3RyaWJ1dGlvbiwgY3VtdWxhdGl2ZSA9IEZBTFNFLCB2ZXJib3NlID0gRkFMU0UsIGpvaW4gPSBUUlVFLCB2YXJOYW1lID0gIm5ldHMiKQ0KI3Bsb3QoZ29mMC5nZCwgbWFpbiA9IlRlc3QgR2VvZGVzaWMiKQ0KDQoNCmBgYA0KDQpgYGB7PWh0bWx9DQo8IS0tIA0KDQpNYWtlIGl0IGEgZGlyZWN0ZWQgbmV0d29yazogIHRpZXMgZnJvbSAiYWxsIiB0byAiZmlyc3QiDQpmb2N1czogd3JpdGluZywNCm1vZGVsIGludGVycHJldGF0aW9uDQoNCg0KIyMjIFF1ZXN0aW9ucw0KDQotICAgSXMgdGhlIHVzZSBvZiBSU2llbmEgZGlmZmVyZW50IGZvciBwZW9wbGUgd2hvIGxvb2sgYXQgMSB2cyAyIHdhdmVzLg0KICAgIEkgbmVlZCB0byBsb29rIGF0IG9uZSwgbWFkZSAyIGFueXdheXMgYmMgUlNpZW5hIG5lZWRzIHdhdmVzIHRvIGRvDQogICAgaXQncyB0aGluZyBidXQ6XA0KICAgIERvZXNuJ3QgaXQgbG9vayBhdCBtaW5pc3RlcHMgb3ZlciB0aW1lPyBIb3cgY2FuIEkgaW50ZXJwcmV0IHRoZQ0KICAgIG91dHB1dCBpbiBhIHdheSB0aGF0IHBlcnRhaW5zIHRvIG9ubHkgb25lIHdhdmUgd2hlbiB0aGUgcHJvY2Vzcw0KICAgIHNlZW1zIHRvIGNvbnNpZGVyIGl0IHdpdGhpbiB0aGUgY29uc3RydWN0IG9mICdmdXR1cmUgY2hhbmdlJz8NCg0KICAgIC0gICBIb3cgZG9lcyBteSBtb2RlbCBpbnRlcnByZXRhdGlvbiBwb3RlbnRpYWxseSBkaWZmZXIgZnJvbSBwZWVwcw0KICAgICAgICB3aG8gbG9va2VkIGF0IHR3byB3YXZlcyAob3IgbW9yZSk/DQoNCi0gICBub3QgbG9va2luZyBhdCBUV29TdGVwISBkaWZmLiBtb2RlbGxpbmcgcHJvY2Vzcy4gDQpSU2llbmEgd29ya3Mgd2l0aCBtaW5pc3RlcHMgaW5kZWVkIG5vdCBqdXN0IFR3b3N0ZXBzICh0aGF0IHdvcmtzIHdpdGggdHdvIHN0ZXBzIGxvbCkNCg0KDQotIGRpZmYuIGJldHdlZWVuIHdhdmUgMSBhbmQgd2F2ZSAyIG1vZGVsIC0+IGNvbnZlcmdlbmNlIA0KLSBkZWZhdWx0IHJlY2lwLiBhbmQgZGVncmVlOiBlc3RpbWF0ZXMgdGhlIHB1dHB1dCBiYXNlZCBvbiBhIGNlcnRhaW4gcmVjaXByb2MuIGFuZCBkZWdyZWUgImFzc3VtcHRpb24iDQogDQotLT4NCmBgYA0KIyMgXDxcPiBNb2RlbCAwIC0gTnVsbCBNb2RlbA0KDQpGaXJzdCwgSSBlc3RpbWF0ZSBhIG51bGwgbW9kZWwgd2l0aCBvbmx5IHJlY2lwcm9jaXR5IGFuZCBkZWdyZWUuDQoNClRoZSBtYXhpbXVtIGNvbnZlcmdlbmNlIHJhdGlvIG9mIHRoZSBtb2RlbCBpcyAwLjA4NC4gVGhlIEdPRiBvbiB0aGUNCkluZGVncmVlIERpc3RyaWJ1dGlvbiBpcyB6ZXJvKiouKiogVGhpcyBpbmRpY2F0ZXMgdGhhdCB0aGUgbW9kZWwgaXMgYQ0KdmVyeSBiYWQgZml0IGZvciB0aGUgZGF0YS4gVGhpcyBpcyBub3Qgc3VwcmlzaW5nIHNpbmNlIHdlIHJhbiBhIG51bGwNCm1vZGVsIHdpdGhvdXQgYW55IG5ldHdvcmsgZWZmZWN0cy5mZmVjdHMuDQoNCkZvciBhbGwgR09GIHBsb3RzIGNvbXBpbGVkIGluIG9uZSBwbGFjZSwgc2VlIGhlcmU6DQo8aHR0cHM6Ly90cmVlc2R1ZGUuZ2l0aHViLmlvL2xhYmpvdXJuYWwvZmluYWxHT0YuaHRtbD4NCg0KQ0hBTkdFIEJvdGggcmVjaXByb2NpdHkgYW5kIGRlbnNpdHkgYXJlIHNpZ25pZmljYW50IGZvciBhbiBhbHBoYSBvZg0KKipOVU1CRVIqKi4NCg0KRXN0aW1hdGVzIGFuZCBzdGFuZGFyZCBlcnJvcnMNCg0KUmF0ZSBwYXJhbWV0ZXJzOg0KDQowXC4gUmF0ZSBwYXJhbWV0ZXIgMi4xMTcgKCAwLjM1NjEpDQoNCk90aGVyIHBhcmFtZXRlcnM6DQoNCjFcLiBldmFsOiBvdXRkZWdyZWUgKGRlbnNpdHkpIC0yLjYzODggKCAwLjE0NjApIGNvbnZlcmdlbmNlIHQgcmF0aW86DQowLjAxODINCg0KMlwuIGV2YWw6IHJlY2lwcm9jaXR5IDEuODAzNSAoIDAuNDM0MykgY29udmVyZ2VuY2UgdCByYXRpbzogLTAuMDY2OA0KDQoqKm1lYW5pbmcgb2Ygc2lnbmlmaWNhbmNlIGluIFJTaWVuYSoqICJJdCBpcyBpbXBvcnRhbnQgdG8gbWVudGlvbiB0aGF0DQpzaWduaWZpY2FuY2UgaW4gUlNpZW5hIG1lYW5zIHNvbWV0aGluZyBkaWZmZXJlbnQgdGhhbiBpbiBjb252ZW50aW9uYWwNCnN0YXRpc3RpY3MuIEluIG5vcm1hbCBzdGF0aXN0aWNzLCBzdWNoIGFzIE9MUy1yZWdyZXNzaW9uLCBzaWduaWZpY2FuY2UNCm9mIGVzdGltYXRlcyByZWZlcnMgdG8gdGhlIGZhY3QgdGhhdCB0aGV5IGFyZSBub3QgMCAoKipSRUxFVkFOVD8qKikuIEluDQpSU2llbmEsIGhvd2V2ZXIsIGl0IHJlZmVycyB0byB0aGUgZmFjdCB0aGF0IHRoZSBlc3RpbWF0ZXMgd2VyZSBwcmVjaXNlbHkNCmRldGVybWluZWQgKFJpcGxleSBldCBhbC4gMjAxMSkuIEdvaW5nIGZvcndhcmQgd2l0aCB0aGlzIGNoYXB0ZXIsDQpzaWduaWZpY2FuY2Ugd2lsbCByZWZlciB0byB0aGlzIGRlZmluaXRpb24gb2Ygc2lnbmlmaWNhbmNlLiIgLSBOaWVscw0KVnVsbGluZ3MNCg0KVGhpcyBtb2RlbCBoYXMgYSBkZW5zaXR5IHBhcmFtZXRlciBvZiAqKk5VTUJFUioqLCBzdWdnZXN0aW5nIHRoYXQNCiJwZW9wbGUgZ2VuZXJhbGx5IGRvIG5vdCB3YW50IHRvIGhhdmUgYSBkZW5zZSBuZXR3b3JrIi4NCg0KVGhlIHJlY2lwcm9jaXR5IHBhcmFtZXRlciBvZiAqKk5VTUJFUioqIGluZGljYXRlcyB0aGF0ICJwZW9wbGUgbGlrZSB0bw0Kc2VuZCB0aWVzIGJhY2sgdG8gcGVvcGxlIHdobyBoYXZlIHNlbnQgYSB0aWUgdG8gdGhlbS4iDQoNCiMjIyAtLS1TdGVwIDE6IERlZmluZSBTaWVuYSBEYXRhICYgVmFyaWFibGVzDQoNCmBgYHtyIFJTaWVuYSBkZWZpbmUgbTB9DQojIGRlcGVuZGVudCB2YXJpYWJsZSANCm5ldHMgPC0gc2llbmFEZXBlbmRlbnQobmV0X2FycmF5KQ0KDQojIGRlZmluZSBkYXRhIG9iamVjdCANCm15ZGF0YV9NMCA8LSBzaWVuYURhdGFDcmVhdGUobmV0cykNCg0KYGBgDQoNClByaW50IHNob3J0IGRlc2NyaXB0aXZlIHJlcG9ydA0KDQpgYGB7cn0NCmlmZWxzZSghZGlyLmV4aXN0cygicmVzdWx0cyIpLCBkaXIuY3JlYXRlKCJyZXN1bHRzIiksIEZBTFNFKQ0KDQpgYGANCg0KYGBge3J9DQpwcmludDAxUmVwb3J0KG15ZGF0YV9NMCwgbW9kZWxuYW1lID0gIi4vcmVzdWx0cy9yZXN1bHRzX00wIikgIyBjcmVhdGUgZmlsZSB3aXRoIHJlcG9ydCBpbiByZXN1bHRzIGZvbGRlciANCmBgYA0KDQojIyMgLS0tU3RlcCAyOiBNYWtlIGVmZmVjdHMgb2JqZWN0L3N0cnVjdHVyZQ0KDQpgYGB7ciBSU2llbmEgbXllZmYgTTB9DQojIGRlZmluZSBlZmZlY3RzIHN0cnVjdHVyZSANCm15ZWZmX00wIDwtIGdldEVmZmVjdHMobXlkYXRhX00wKQ0KDQpgYGANCg0KIyMjIC0tLVN0ZXAgMzogQWRkIEVmZmVjdHMNCg0KTnVsbCBtb2RlbDogbm9uZS4NCg0KIyMjIC0tLVN0ZXAgNDogU3BlY2lmeSBtb2RlbC9hbGdvcml0aG0NCg0KYGBge3IgYWxnbyBNMH0NCg0KbXlBbGdvcml0aG1fTTAgPC0gc2llbmFBbGdvcml0aG1DcmVhdGUgKHByb2puYW1lID0gInJlc3VsdHNfTTAiKQ0KDQpgYGANCg0KIyMjIC0tLVN0ZXAgNTogRXN0aW1hdGUgbW9kZWwNCg0KYGBge3IgZXN0aW1hdGUgTTAsIGV2YWw9RkFMU0V9DQojIGVzdGltYXRlIHRoZSBtb2RlbCANCk1vZGVsMCA8LSBzaWVuYTA3KG15QWxnb3JpdGhtX00wLCBkYXRhID0gbXlkYXRhX00wLCBlZmZlY3RzID0gbXllZmZfTTAsIHJldHVybkRlcHMgPSBUUlVFKQ0KTW9kZWwwDQoNCmZzYXZlKE1vZGVsMCwgZmlsZSA9ImVzdGltYXRlZF9NMCIpDQoNCg0KYGBgDQoNCmBgYHtyIGxvYWQgTTAgb3V0cHV0LCBlY2hvPUZBTFNFfQ0KTW9kZWwwIDwtIGZsb2FkKCIuL2RhdGEvcHJvY2Vzc2VkL2VzdGltYXRlZF9NMF8yMDI0MTEyMy5yZGEiKQ0KTW9kZWwwDQoNCg0KYGBgDQoNCmBgYHtyIEdPRiBNMH0NCkdPRl9NMCA8LSBzaWVuYUdPRihNb2RlbDAsIEluZGVncmVlRGlzdHJpYnV0aW9uLCB2ZXJib3NlID0gRkFMU0UsIGpvaW4gPSBUUlVFLCB2YXJOYW1lID0gIm5ldHMiKQ0KDQpwbG90KEdPRl9NMCwgbWFpbiA9ICdHT0YgLSAiTnVsbCIgTW9kZWwgMCBcbiBJbmRlZ3JlZSBEaXN0cmlidXRpb24nKQ0KYGBgDQoNCi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQ0KDQojIyBcPFw+IE1vZGVsIDEgLSBTdHJ1Y3R1cmFsIEVmZmVjdHMNCg0KVGhpcyBtb2RlbCBhZGRpdGlvbmFsbHkgZW50YWlscyBJblBvcCwgb3V0QWN0LCBpc29sYXRlTmV0IGFzIG5ldHdvcmsNCnN0YXRpc3RpY3MuDQoNCiJUaGUgbW9kZWwgaGFzIGEgbWF4aW11bSBjb252ZXJnZW5jZSByYXRpbyBvZiAqKjAuMTcqKiBhbmQgYSBHb29kbmVzcyBvZg0KRml0IG9uIHRoZSBpbmRlZ3JlZSBkaXN0cmlidXRpb24gb2YgKiouMDAyLioqIg0KDQoiSW5kZWdyZWUgUG9wdWxhcml0eSAoaW5Qb3ApIGlzIGRlZmluZWQgYXMgdGhlIGV4dGVudCB0byB3aGljaCBwZW9wbGUNCndobyBoYXZlIGEgbG90IG9mIGluZGVncmVlcyBhcmUgbW9yZSBwb3B1bGFyIHRvIGNvbm5lY3Qgd2l0aC4gVGhpcw0KcGFyYW1ldGVyIGlzIE5VTUJFUiwgbWVhbmluZyB0aGF0IGFjdG9ycyBoYXZlIGEgcHJlZmVyZW5jZSB0byBjb25uZWN0DQp3aXRoIGFjdG9ycyB3aG8gaGF2ZSBhIGxvdCBvZiBpbmRlZ3JlZXMuIFRoZSBwYXJhbWV0ZXIgaXMgc2lnbmlmaWNhbnQNCmZvciBhbiBhbHBoYSBvZiAqKk5VTUJFUioqLiINCg0KIk91dGRlZ3JlZSBBY3Rpdml0eSAob3V0QWN0KSBoYXMgYSB2YWx1ZSBvZiAqKk5VTUJFUioqLCBidXQgaXMgbm90DQpzaWduaWZpY2FudC4gSXNvbGF0ZU5ldCBpcyBzaWduaWZpY2FudCBhbmRoYXMgYSB2YWx1ZSBvZiBOVU1CRVIgYW5kDQpyZWZlcnMgdG8gdGhlIHByZWZlcmVuY2Ugb2YgcmVtYWluaW5nIGFuIGlzb2xhdGUuIEFzIHRoaXMgdmFsdWUgaXMNCnBvc2l0aXZlIChcKklTIElUPz8hXCpcKiksIGl0IG1lYW5zIHRoYXQgcGVvcGxlIHByZWZlciB0byBiZSBhbiBpc29sYXRlDQppbiB0aGUgbmV0d29yay4iDQoNCi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQ0KDQpFc3RpbWF0ZXMgYW5kIHN0YW5kYXJkIGVycm9ycw0KDQpSYXRlIHBhcmFtZXRlcnM6DQoNCjBcLiBSYXRlIHBhcmFtZXRlciAzLjM1NjYgKCAwLjU3NzMpDQoNCk90aGVyIHBhcmFtZXRlcnM6DQoNCjFcLiBldmFsOiBvdXRkZWdyZWUgKGRlbnNpdHkpIC0yLjA4NjIgKCAwLjcwNTApDQoNCjJcLiBldmFsOiByZWNpcHJvY2l0eSAxLjA4OTQgKCAwLjQxNDQpDQoNCjNcLiBldmFsOiBpbmRlZ3JlZSAtIHBvcHVsYXJpdHkgMC4yNTQ5ICggMC4wNDM5KQ0KDQo0XC4gZXZhbDogb3V0ZGVncmVlIC0gYWN0aXZpdHkgLTAuMDkzNiAoIDAuMTMwMSkNCg0KNVwuIGV2YWw6IG5ldHdvcmstaXNvbGF0ZSA0Ljk2NDUgKCAxLjExNDYpDQoNCmNvbnZlcmdlbmNlIHQgcmF0aW86DQoNCmBgYCAgICAgICAgIA0KMQ0KMC4wMjMyDQpgYGANCg0KYGBgICAgICAgICAgDQoyDQowLjA0NjcNCmBgYA0KDQpgYGAgICAgICAgICANCjMNCi0wLjAxOTUNCmBgYA0KDQpgYGAgICAgICAgICANCjQNCi0wLjA0MjMNCmBgYA0KDQpgYGAgICAgICAgICANCjUNCi0wLjA2MQ0KYGBgDQoNCmBgYCAgICAgICAgIA0KNg0KLTAuMDYxNw0KYGBgDQoNCiMjIyAtLS1TdGVwIDE6IERlZmluZSBTaWVuYSBEYXRhICYgVmFyaWFibGVzDQoNCmBgYHtyIFJTaWVuYSBkZWZpbmUgTTF9DQojIGRlcGVuZGVudCB2YXJpYWJsZSANCm5ldHMgPC0gc2llbmFEZXBlbmRlbnQobmV0X2FycmF5KQ0KDQojIGRlZmluZSBkYXRhIG9iamVjdCANCm15ZGF0YV9NMSA8LSBzaWVuYURhdGFDcmVhdGUobmV0cykNCg0KYGBgDQoNClByaW50IHNob3J0IGRlc2NyaXB0aXZlIHJlcG9ydA0KDQpgYGB7cn0NCmlmZWxzZSghZGlyLmV4aXN0cygicmVzdWx0cyIpLCBkaXIuY3JlYXRlKCJyZXN1bHRzIiksIEZBTFNFKQ0KDQpgYGANCg0KYGBge3J9DQpwcmludDAxUmVwb3J0KG15ZGF0YV9NMSwgbW9kZWxuYW1lID0gIi4vcmVzdWx0cy9yZXN1bHRzX00xIikgIyBjcmVhdGUgZmlsZSB3aXRoIHJlcG9ydCBpbiByZXN1bHRzIGZvbGRlciANCmBgYA0KDQojIyMgLS0tU3RlcCAyOiBNYWtlIGVmZmVjdHMgb2JqZWN0L3N0cnVjdHVyZQ0KDQpgYGB7ciBSU2llbmEgbXllZmYgbTF9DQojIGRlZmluZSBlZmZlY3RzIHN0cnVjdHVyZSANCm15ZWZmX00xIDwtIGdldEVmZmVjdHMobXlkYXRhX00xKQ0KDQpgYGANCg0KIyMjIC0tLVN0ZXAgMzogQWRkIEVmZmVjdHMNCg0KYGBge3IgZWZmZWN0cyBtMX0NCg0KbXllZmZfTTEgPC0gaW5jbHVkZUVmZmVjdHMobXllZmZfTTEsIGlzb2xhdGVOZXQsIGluUG9wLCBvdXRBY3QpDQoNCmBgYA0KDQojIyMgLS0tU3RlcCA0OiBTcGVjaWZ5IG1vZGVsL2FsZ29yaXRobQ0KDQpgYGB7ciBhbGdvIG0xfQ0KDQpteUFsZ29yaXRobV9NMSA8LSBzaWVuYUFsZ29yaXRobUNyZWF0ZSAocHJvam5hbWUgPSAicmVzdWx0c19NMSIpDQoNCmBgYA0KDQojIyMgLS0tU3RlcCA1OiBFc3RpbWF0ZSBtb2RlbA0KDQpgYGB7ciBlc3RpbWF0ZSBtMSwgZXZhbCA9IEZBTFNFfQ0KIyBlc3RpbWF0ZSB0aGUgbW9kZWwgDQpNb2RlbDEgPC0gc2llbmEwNyhteUFsZ29yaXRobV9NMSwgZGF0YSA9IG15ZGF0YV9NMSwgZWZmZWN0cyA9IG15ZWZmX00xLCByZXR1cm5EZXBzID0gVFJVRSkNCk1vZGVsMQ0KIyBtYXhpbXVtIGNvbnZlcmdlbmNlID4uMjUNCiMgcnVuIGFnYWluOg0KTW9kZWwxLjEgPC0gc2llbmEwNyhteUFsZ29yaXRobV9NMSwgZGF0YSA9IG15ZGF0YV9NMSwgZWZmZWN0cyA9IG15ZWZmX00xLCBwcmV2QW5zPSBNb2RlbDEsIHJldHVybkRlcHMgPSBUUlVFKQ0KTW9kZWwxLjENCg0KI2ZzYXZlKE1vZGVsMSwgZmlsZSA9ImVzdGltYXRlZF9NMSIpDQojZnNhdmUoTW9kZWwxLjEsIGZpbGUgPSAiZXN0aW1hdGVkX00xLjEiKQ0KDQpgYGANCg0KYGBge3IgbG9hZCBNMSBvdXRwdXQsIGVjaG89RkFMU0V9DQoNCk1vZGVsMSA8LSBmbG9hZCgiLi9kYXRhL3Byb2Nlc3NlZC9lc3RpbWF0ZWRfTTFfMjAyNDExMjMucmRhIikNCk1vZGVsMQ0KDQpNb2RlbDEuMSA8LSBmbG9hZCgiLi9kYXRhL3Byb2Nlc3NlZC9lc3RpbWF0ZWRfTTEuMV8yMDI0MTEyMy5yZGEiKQ0KTW9kZWwxLjENCmBgYA0KDQojIyMgLS0tU3RlcCA2OiBHT0YgLSBHb29kbmVzcyBvZiBGaXQNCg0KYGBge3IgR09GIE0xfQ0KR09GX00xLjEgPC0gc2llbmFHT0YoTW9kZWwxLjEsIEluZGVncmVlRGlzdHJpYnV0aW9uLCB2ZXJib3NlID0gRkFMU0UsIGpvaW4gPSBUUlVFLCB2YXJOYW1lID0gIm5ldHMiKQ0KDQpwbG90KEdPRl9NMS4xLCBtYWluID0gIkdPRiAtIE1vZGVsIDEgXG4gSW5kZWdyZWUgRGlzdHJpYnV0aW9uIikNCmBgYA0KDQotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0NCg0KIyMgXDxcPiBNb2RlbCAyIC0gR2VuZGVyDQoNClRoaXMgbW9kZWwgaXMgcGFydGx5IHNpbWlsYXIgdG8gTW9kZWwgMSBidXQgYWRkaXRpb25hbGx5IGhvbGRzIHRoZQ0KbmV0d29yayBzdGF0aXN0aWNzIHNhbWVYLCBkaWZmWFRyYW5zVHJpcCwgZWdvWCAmIGFsdFggb2YgdGhlIGNvdmFyaWF0ZQ0KZ2VuZGVyLg0KDQpgYGAgICAgICAgICANCkVzdGltYXRlcywgc3RhbmRhcmQgZXJyb3JzIGFuZCBjb252ZXJnZW5jZSB0LXJhdGlvcyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBFc3RpbWF0ZSAgIFN0YW5kYXJkICAgQ29udmVyZ2VuY2UNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRXJyb3IgICAgICB0LXJhdGlvICAgICANClJhdGUgcGFyYW1ldGVyczogICAgDQowICAgICAgIFJhdGUgcGFyYW1ldGVyICAgICAgICAgICAgICAgICAgICAgICAyLjkyMDQgICggMC40NjE3ICAgKSAgICAgICAgICAgICAgIA0KDQpPdGhlciBwYXJhbWV0ZXJzOiAgICANCjEuIGV2YWwgb3V0ZGVncmVlIChkZW5zaXR5KSAgICAgICAgICAgICAgICAgLTEuODYyOCAgKCAxLjEwNjAgICApICAgIDAuMDcwMyAgICAgIA0KMi4gZXZhbCByZWNpcHJvY2l0eSAgICAgICAgICAgICAgICAgICAgICAgICAgMS4zMzQxICAoIDAuNDU0MyAgICkgICAtMC4wMTUyICAgICAgDQozLiBldmFsIGluZGVncmVlIC0gcG9wdWxhcml0eSAgICAgICAgICAgICAgICAwLjIyMDkgICggMC4wNDcwICAgKSAgIC0wLjAwODMgICAgICANCjQuIGV2YWwgb3V0ZGVncmVlIC0gYWN0aXZpdHkgICAgICAgICAgICAgICAgLTAuMzAxNyAgKCAwLjIyODcgICApICAgIDAuMDgwNiAgICAgIA0KNS4gZXZhbCBuZXR3b3JrLWlzb2xhdGUgICAgICAgICAgICAgICAgICAgICAgNC43NTA3ICAoIDEuNTE5NCAgICkgICAtMC4wMzc5ICAgICAgDQo2LiBldmFsIGdlbmRlcl9SUyBhbHRlciAgICAgICAgICAgICAgICAgICAgICAwLjMyNTQgICggMC4yNzAxICAgKSAgICAwLjA0MTEgICAgICANCjcuIGV2YWwgZ2VuZGVyX1JTIGVnbyAgICAgICAgICAgICAgICAgICAgICAgLTEuMDY0MiAgKCAwLjYwNTUgICApICAgLTAuMDQwMCAgICAgIA0KOC4gZXZhbCBzYW1lIGdlbmRlcl9SUyAgICAgICAgICAgICAgICAgICAgICAgMC42NjM3ICAoIDAuMjY4NSAgICkgICAgMC4wMzA4ICAgICAgDQo5LiBldmFsIHRyYW5zaXRpdmUgdHJpcGxldHMgZGlmZi4gZ2VuZGVyX1JTICAyLjE3ODcgICggMC42MDI3ICAgKSAgICAwLjA0MTYgICANCmBgYA0KDQpUaGUgbWF4aW11bSBjb252ZXJnZW5jZSByYXRpbyBmb3IgbW9kZWwgMiBpcyAqKjAuMTMyKiogYW5kIHRoZSBHb29kbmVzcw0Kb2YgRml0IG9uIHRoZSBpbmRlZ3JlZSBkaXN0cmlidXRpb24gaXMgKiowLjA5NioqLg0KDQoqKkNIQU5HRSEhKioNCg0KIkZvciB0aGUgc3RydWN0dXJhbCBuZXR3b3JrIHN0YXRpc3RpY3Mgd2UgZmluZCBzaW1pbGFyIHJlc3VsdHMsIGluIHRlcm1zDQpvZiBlc3RpbWF0ZSBzaXplIGFuZCBzaWduaWZpY2FuY2UsIGFzIGluIE1vZGVsIDEuIEhvd2V2ZXIsIHRoZSBvdXRkZWdyZWUNCmFjdGl2aXR5IHBhcmFtZXRlciBhbG1vc3QgcmVhY2hlcyBzaWduaWZpY2FuY2UgKCoqLTEuNzEzNTQ4NCoqKS4NCg0KV2l0aCByZWdhcmQgdG8gdGhlIGNvdmFyaWF0ZSBuZXR3b3JrIHN0YXRpc3RpY3MsIHdlIGZpbmQgdGhhdCB0aGUgZ2VuZGVyDQpvZiBlZ28gKGVnb1gpLCB0aGUgZ2VuZGVyIG9mIGFsdGVyIChhbHRYKSAqKmFyZSBub3Qgc2lnbmlmaWNhbnQgYW5kIHRodXMNCnRoZSBlc3RpbWF0ZSBjYW5ub3QgYmUgdHJ1c3RlZCoqLiINCg0KZWdvWCBhbmQgYWx0WDogbW9kZWwgd2hldGhlciBtYWxlIG9yIGZlbWFsZSBzY2hvbGFycyBhcmUgbW9yZSBsaWtlbHkgdG8NCmluaXRpYXRlIG9yIHJlY2VpdmUgdGllcy4NCg0KKipzYW1lWCAoR2VuZGVyKSoqOiBUZXN0cyB3aGV0aGVyIHNjaG9sYXJzIHByZWZlciBzYW1lLWdlbmRlcg0KY29sbGFib3JhdG9ycyAoZGlyZWN0IG1lYXN1cmUgb2YgZ2VuZGVyIGhvbW9waGlseSkuXA0KbW9kZWwgdGhlIGdlbmVyYWwgdGVuZGVuY3kgZm9yIHNjaG9sYXJzIHRvIGNvbGxhYm9yYXRlIHdpdGggc2FtZS1nZW5kZXINCnBlZXJzLg0KDQoqKkNvbmZpcm1hdGlvbioqOg0KDQotICAgU2lnbmlmaWNhbnQgYW5kIHBvc2l0aXZlIGNvZWZmaWNpZW50IGZvciBgc2FtZVhgIGluIHRoZSBSU2llbmENCiAgICBvdXRwdXQgd291bGQgY29uZmlybSB0aGF0IGdlbmRlciBob21vcGhpbHkgZXhpc3RzLg0KDQotICAgQSBub24tc2lnbmlmaWNhbnQgb3IgbmVnYXRpdmUgY29lZmZpY2llbnQgd291bGQgZGlzY29uZmlybSB0aGlzDQogICAgaHlwb3RoZXNpcy4NCg0KKipDb25maXJtYXRpb24qKjoNCg0KLSAgIFNpZ25pZmljYW50IGFuZCBwb3NpdGl2ZSBjb2VmZmljaWVudCBmb3IgYHNhbWVYYCBpbiB0aGUgUlNpZW5hDQogICAgb3V0cHV0IHdvdWxkIGNvbmZpcm0gdGhhdCBnZW5kZXIgaG9tb3BoaWx5IGV4aXN0cy4NCg0KLSAgIEEgbm9uLXNpZ25pZmljYW50IG9yIG5lZ2F0aXZlIGNvZWZmaWNpZW50IHdvdWxkIGRpc2NvbmZpcm0gdGhpcw0KICAgIGh5cG90aGVzaXMuDQoNCkh5cG90aGVzaXMgYWJvdXQgc3RydWN0dXJhbCBlZmZlY3RzDQoNCi0gICAqKk5ldHdvcmsgU3RhdGlzdGljcyoqOg0KDQogICAgLSAgICoqc2FtZVggKEdlbmRlcikqKjogVGVzdHMgZm9yIGdlbmRlciBob21vcGhpbHkgZGlyZWN0bHkuDQoNCiAgICAtICAgU3RydWN0dXJhbCBzdGF0aXN0aWNzIGxpa2UgKipyZWNpcHJvY2l0eSoqLCAqKmluUG9wKiosDQogICAgICAgICoqb3V0QWN0KiosIGFuZCAqKmlzb2xhdGVOZXQqKiBhcmUgY29udHJvbCB2YXJpYWJsZXMgdG8gYWNjb3VudA0KICAgICAgICBmb3IgbmV0d29yay1sZXZlbCBkeW5hbWljcy4NCg0KLSAgICoqQ29uZmlybWF0aW9uKio6DQoNCiAgICAtICAgQSBzaWduaWZpY2FudCBgc2FtZVhgIGNvZWZmaWNpZW50LCBldmVuIGFmdGVyIGluY2x1ZGluZw0KICAgICAgICBzdHJ1Y3R1cmFsIGNvbnRyb2xzLCB3b3VsZCBjb25maXJtIHRoYXQgZ2VuZGVyIGhvbW9waGlseSBleGlzdHMNCiAgICAgICAgYXQgdGhlIGR5YWRpYyBsZXZlbC4NCg0KICAgIC0gICBJZiBgc2FtZVhgIGJlY29tZXMgbm9uLXNpZ25pZmljYW50IGFmdGVyIGNvbnRyb2xzLCBpdCBzdWdnZXN0cw0KICAgICAgICBzdHJ1Y3R1cmFsIGZhY3RvcnMsIG5vdCBpbmRpdmlkdWFsIHByZWZlcmVuY2VzLCBleHBsYWluIGdlbmRlcg0KICAgICAgICBjbHVzdGVyaW5nLg0KDQojIyMgLS0tU3RlcCAxOiBEZWZpbmUgU2llbmEgRGF0YSAmIFZhcmlhYmxlcw0KDQpgYGB7ciBSU2llbmEgZGVmaW5lIG0yfQ0KIyBkZXBlbmRlbnQgdmFyaWFibGUgDQpuZXRzIDwtIHNpZW5hRGVwZW5kZW50KG5ldF9hcnJheSkNCg0KIyBwdXQgZ2VuZGVyIGluIG9iamVjdCANCmdlbmRlciA8LSBkZl9lZ28kZ2VuZGVyDQoNCiMgY292YXJpYXRlIDENCmdlbmRlcl9SUyA8LSBjb0NvdmFyKGdlbmRlcikgIyBnZW5kZXIgYXMgY292YXJpYXRlIGluIFJzaWVuYQ0KDQojIGRlZmluZSBkYXRhIG9iamVjdCANCm15ZGF0YV9NMiA8LSBzaWVuYURhdGFDcmVhdGUobmV0cywgZ2VuZGVyX1JTKQ0KDQpgYGANCg0KUHJpbnQgc2hvcnQgZGVzY3JpcHRpdmUgcmVwb3J0DQoNCmBgYHtyfQ0KaWZlbHNlKCFkaXIuZXhpc3RzKCJyZXN1bHRzIiksIGRpci5jcmVhdGUoInJlc3VsdHMiKSwgRkFMU0UpDQoNCmBgYA0KDQpgYGB7cn0NCnByaW50MDFSZXBvcnQobXlkYXRhX00yLCBtb2RlbG5hbWUgPSAiLi9yZXN1bHRzL3Jlc3VsdHNfTTIiKSAjIGNyZWF0ZSBmaWxlIHdpdGggcmVwb3J0IGluIHJlc3VsdHMgZm9sZGVyIA0KYGBgDQoNCiMjIyAtLS1TdGVwIDI6IE1ha2UgZWZmZWN0cyBvYmplY3Qvc3RydWN0dXJlDQoNCmBgYHtyIFJTaWVuYSBteWVmZiBtMn0NCiMgZGVmaW5lIGVmZmVjdHMgc3RydWN0dXJlIA0KbXllZmZfTTIgPC0gZ2V0RWZmZWN0cyhteWRhdGFfTTIpDQpgYGANCg0KIyMjIC0tLVN0ZXAgMzogQWRkIEVmZmVjdHMNCg0KYGBge3IgZWZmZWN0cyBtMn0NCm15ZWZmX00yIDwtIGluY2x1ZGVFZmZlY3RzKG15ZWZmX00yLCBpc29sYXRlTmV0LCBpblBvcCwgb3V0QWN0KSANCg0KbXllZmZfTTIgPC0gaW5jbHVkZUVmZmVjdHMobXllZmZfTTIsIGVnb1gsIGFsdFgsIGRpZmZYVHJhbnNUcmlwLCBzYW1lWCwgaW50ZXJhY3Rpb24xID0gImdlbmRlcl9SUyIpIA0KYGBgDQoNCmBgYHs9aHRtbH0NCjwhLS0NCiMgaXNvbGF0ZW5ldDogaWYgaW5kaXZpZHVhbCBpcyBhbG9uZSB0aGV5ICJsaWtlIHRvL3RlbmQgdG8gc3RheSBhbG9uZSINCiMgaW5Qb3A6IHBwbCBsaWtlIHRvIGNvbGxhYm9yYXRlIHdpdGggcGVvcGxlIHdobyBhcmUgcG9wdWxhcg0KDQojIHNhbWVYDQojIHNhbWUgY292YXJpYXRlLCB3aGljaCBjYW4gYWxzbyBiZSBjYWxsZWQgY292YXJpYXRlLXJlbGF0ZWQgaWRlbnRpdHkgKHNhbWVYKSwgZGVmaW5lZCBieSB0aGUgbnVtYmVyIG9mIHRpZXMgb2YgaSB0byBhbGwgb3RoZXIgYWN0b3JzIGogd2hvIGhhdmUgZXhhY3RseSB0aGUgc2FtZSB2YWx1ZSBvbiB0aGUgY292YXJpYXRlLCBzIG5ldCBpOTUoeCkgPSBQIGp4aWogSXt2aSA9IHZqfSwNCiMgd2hlcmUgdGhlIGluZGljYXRvciBmdW5jdGlvbiBJe3ZpID0gdmp9IGlzIDEgaWYgdGhlIGNvbmRpdGlvbiB7dmkgPSB2an0gaXMgc2F0aXNmaWVkLCBhbmQgMCBpZiBpdCBpcyBub3Q7DQoNCg0KI2RpZmZYVHJhbnNUcmlwDQpkaWZmZXJlbnQgY292YXJpYXRlIMOXIHRyYW5zaXRpdmUgdHJpcGxldHMgKGRpZmZYVHJhbnNUcmlwKSwgZGVmaW5lZCBieSB0aGUgbnVtYmVyDQpvZiB0cmFuc2l0aXZlIHRyaXBsZXRzIGkg4oaSIGgg4oaSIGog4oaQIGkgdGhhdCBoYXZlIGRpZmZlcmVudCBjb3ZhcmlhdGUgdmFsdWVzIGZvciBpIGFuZCBqLA0KZGlmZi4gY292LiB2YWx1ZXMgPSBkaWZmIGdlbmRlcg0KDQotLT4NCmBgYA0KIyMjIC0tLVN0ZXAgNDogU3BlY2lmeSBtb2RlbC9hbGdvcml0aG0NCg0KYGBge3IgYWxnbyBtMn0NCg0KbXlBbGdvcml0aG1fTTIgPC0gc2llbmFBbGdvcml0aG1DcmVhdGUgKHByb2puYW1lID0gInJlc3VsdHNfTTIiKQ0KDQpgYGANCg0KIyMjIC0tLVN0ZXAgNTogRXN0aW1hdGUgbW9kZWwNCg0KYGBge3IgZXN0aW1hdGUgbTIsIGV2YWwgPUZBTFNFfQ0KIyBlc3RpbWF0ZSB0aGUgbW9kZWwgDQpNb2RlbDIgPC0gc2llbmEwNyhteUFsZ29yaXRobV9NMiwgZGF0YSA9IG15ZGF0YV9NMiwgZWZmZWN0cyA9IG15ZWZmX00yLCByZXR1cm5EZXBzID0gVFJVRSkNCk1vZGVsMg0KIyBtYXhpbXVtIGNvbnZlcmdlbmNlID4uMjUNCiMgcnVuIGFnYWluOg0KTW9kZWwyLjEgPC0gc2llbmEwNyhteUFsZ29yaXRobV9NMiwgZGF0YSA9IG15ZGF0YV9NMiwgZWZmZWN0cyA9IG15ZWZmX00yLCBwcmV2QW5zPSBNb2RlbDIsIHJldHVybkRlcHMgPSBUUlVFKQ0KTW9kZWwyLjEgDQoNCiNmc2F2ZShNb2RlbDIsIGZpbGUgPSJlc3RpbWF0ZWRfTTIiKQ0KI2ZzYXZlKE1vZGVsMi4xLCBmaWxlID0gImVzdGltYXRlZF9NMi4xIikNCg0KYGBgDQoNCmBgYHtyIGxvYWQgTTIgb3V0cHV0LCBlY2hvPUZBTFNFfQ0KDQpNb2RlbDIgPC0gZmxvYWQoIi4vZGF0YS9wcm9jZXNzZWQvZXN0aW1hdGVkX00yXzIwMjQxMTIzLnJkYSIpDQpNb2RlbDINCg0KTW9kZWwyLjEgPC0gZmxvYWQgKCIuL2RhdGEvcHJvY2Vzc2VkL2VzdGltYXRlZF9NMi4xXzIwMjQxMTIzLnJkYSIpDQpNb2RlbDIuMQ0KYGBgDQoNCiMjIyAtLS1TdGVwIDY6IEdPRiAtIEdvb2RuZXNzIG9mIEZpdA0KDQpgYGB7ciBHT0YgTTJ9DQpHT0ZfTTIuMSA8LSBzaWVuYUdPRihNb2RlbDIuMSwgSW5kZWdyZWVEaXN0cmlidXRpb24sIHZlcmJvc2UgPSBGQUxTRSwgam9pbiA9IFRSVUUsIHZhck5hbWUgPSAibmV0cyIpDQoNCnBsb3QoR09GX00yLjEsIG1haW4gPSAiR09GIC0gTW9kZWwgMiBcbiBJbmRlZ3JlZSBEaXN0cmlidXRpb24iKQ0KYGBgDQoNCi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQ0KDQojIyBcPFw+IE1vZGVsIDMgLSBEZXBhcnRtZW50DQoNClRoaXMgbW9kZWwgaXMgcGFydGx5IHNpbWlsYXIgdG8gTW9kZWwgMiBidXQgYWRkaXRpb25hbGx5IGhvbGRzIHRoZQ0KbmV0d29yayBzdGF0aXN0aWNzIGVnb1ggYW5kIGFsdFggZm9yIHRoZSBtYWluIGVmZmVjdCBvZiBkZXBhcnRtZW50LCB0bw0KY29udHJvbCBmb3IgZGlmZmVyZW5jZXMgaW4gY29sbGFib3JhdGlvbiBwYXR0ZXJucyBiZXR3ZWVuIHRoZSB0d28NCmRlcGFydG1lbnRzLg0KDQpNb2RlbCAzIGhhcyBhIG1heGltdW0gY29udmVyZ2VuY2UgcmF0aW8gb2YgKiowLjE4MioqIGFuZCBhIEdvb2RuZXNzIG9mDQpGaXQgb24gdGhlIGluZGVncmVlIGRpc3RyaWJ1dGlvbiBvZiAqKjAuMTA4KiouDQoNCioqQ0hBTkdFKiogISEhIQ0KDQpGb3IgdGhlIHN0cnVjdHVyYWwgbmV0d29yayBzdGF0aXN0aWNzIHdlIGZpbmQgc2ltaWxhciByZXN1bHRzLCBpbiB0ZXJtcw0Kb2YgZXN0aW1hdGUgc2l6ZSBhbmQgc2lnbmlmaWNhbmNlLCBhcyBpbiBNb2RlbCAxLiBIb3dldmVyLCB0aGUgb3V0ZGVncmVlDQphY3Rpdml0eSBwYXJhbWV0ZXIgYWxtb3N0IHJlYWNoZXMgc2lnbmlmaWNhbmNlICgqKi0xLjcxMzU0ODQqKikuDQoNCldpdGggcmVnYXJkIHRvIHRoZSBjb3ZhcmlhdGUgbmV0d29yayBzdGF0aXN0aWNzLCB3ZSBmaW5kIHRoYXQgdGhlIGdlbmRlcg0Kb2YgZWdvIChlZ29YKSwgdGhlIGdlbmRlciBvZiBhbHRlciAoYWx0WCkgKiphcmUgbm90IHNpZ25pZmljYW50IGFuZCB0aHVzDQp0aGUgZXN0aW1hdGUgY2Fubm90IGJlIHRydXN0ZWQqKi4iDQoNCkVzdGltYXRlcyBhbmQgc3RhbmRhcmQgZXJyb3JzDQoNClJhdGUgcGFyYW1ldGVyczoNCg0KMFwuIFJhdGUgcGFyYW1ldGVyIDMuMTAxMyAoIDAuNTE4NikNCg0KT3RoZXIgcGFyYW1ldGVyczoNCg0KMVwuIGV2YWw6IG91dGRlZ3JlZSAoZGVuc2l0eSkgLTQuMzIzMyAoIDEuMDg3MSkNCg0KMlwuIGV2YWw6IHJlY2lwcm9jaXR5IDEuMDcyNSAoIDAuNDE3NCkNCg0KM1wuIGV2YWw6IGluZGVncmVlIC0gcG9wdWxhcml0eSAwLjIxMjIgKCAwLjA1MTcpDQoNCjRcLiBldmFsOiBvdXRkZWdyZWUgLSBhY3Rpdml0eSAtMC4zMzY0ICggMC4yMTgyKQ0KDQo1XC4gZXZhbDogbmV0d29yay1pc29sYXRlIDQuMjAwNiAoIDEuMzAwNykNCg0KNlwuIGV2YWw6IGdlbmRlcl9SUyBhbHRlciAwLjMzNTYgKCAwLjI2NTkpDQoNCjdcLiBldmFsOiBnZW5kZXJfUlMgZWdvIC0xLjAwNjYgKCAwLjUxMjEpDQoNCjhcLiBldmFsOiBzYW1lIGdlbmRlcl9SUyAwLjY2MzIgKCAwLjI2MjMpDQoNCjlcLiBldmFsOiB0cmFuc2l0aXZlIHRyaXBsZXRzIGRpZmYuIGdlbmRlcl9SUyAxLjU0NzkgKCAwLjU0MDMpDQoNCjEwXC4gZXZhbDogZGVwYXJ0bV9SUyBhbHRlciAwLjQxNDEgKCAwLjc1NDYpDQoNCjExXC4gZXZhbDogZGVwYXJ0bV9SUyBlZ28gLTEuMTU3MyAoIDAuOTE0OCkNCg0KMTJcLiBldmFsOiBzYW1lIGRlcGFydG1fUlMgMi43MjQwICggMC43Mjc3KQ0KDQotICAgKipOZXR3b3JrIFN0YXRpc3RpY3MqKjoNCg0KICAgIC0gICAqKnNhbWVYIChHZW5kZXIpKio6IENvbXB1dGUgYW5kIGNvbXBhcmUgdGhlIHNpemUgYW5kDQogICAgICAgIHNpZ25pZmljYW5jZSBvZiB0aGUgY29lZmZpY2llbnQgZm9yIGVhY2ggZGVwYXJ0bWVudC4gVGhpcw0KICAgICAgICByZXF1aXJlcyBzZXBhcmF0ZSBtb2RlbHMgZm9yIGVhY2ggZGVwYXJ0bWVudCBvciBpbnRlcmFjdGlvbg0KICAgICAgICB0ZXJtcyB0aGF0IGFsbG93IHRoZSBlZmZlY3QgdG8gdmFyeSBieSBkZXBhcnRtZW50Lg0KDQotICAgKipDb25maXJtYXRpb24qKjoNCg0KICAgIC0gICBBIHNpZ25pZmljYW50bHkgc3Ryb25nZXIgcG9zaXRpdmUgY29lZmZpY2llbnQgZm9yIGBzYW1lWGAgaW4NCiAgICAgICAgUG9saXRpY2FsIFNjaWVuY2UgY29tcGFyZWQgdG8gU29jaW9sb2d5IHdvdWxkIGNvbmZpcm0gdGhlDQogICAgICAgIGh5cG90aGVzaXMuDQoNCiAgICAtICAgU2ltaWxhciBjb2VmZmljaWVudHMgb3IgcmV2ZXJzZWQgcGF0dGVybnMgd291bGQgZGlzY29uZmlybSB0aGUNCiAgICAgICAgaHlwb3RoZXNpcy4NCg0KIyMjIC0tLVN0ZXAgMTogRGVmaW5lIFNpZW5hIERhdGEgJiBWYXJpYWJsZXMNCg0KYGBge3IgUlNpZW5hIGRlZmluZSBtM30NCiMgZGVwZW5kZW50IHZhcmlhYmxlIA0KbmV0cyA8LSBzaWVuYURlcGVuZGVudChuZXRfYXJyYXkpDQoNCiMgcHV0IGdlbmRlciBpbiBvYmplY3QgDQpnZW5kZXIgPC0gZGZfZWdvJGdlbmRlcg0KDQojIGNvdmFyaWF0ZSAxDQpnZW5kZXJfUlMgPC0gY29Db3ZhcihnZW5kZXIpICMgZ2VuZGVyIGFzIGNvdmFyaWF0ZSBpbiBSc2llbmENCg0KI3B1dCBkZXBhcnRtZW50IGluIG9iamVjdCANCmRlcGFydG1lbnQgPC0gZmFjdG9yKGRmX2VnbyRkaXNjaXBsaW5lLjI0LCBsZXZlbHMgPSBjKCJzb2Npb2xvZ3kiLCAicG9saXRpY2FsIHNjaWVuY2UiKSkNCiNtYWtlIG51bWVyaWMNCmRlcGFydG1lbnRfbnVtZXJpYyA8LSBhcy5udW1lcmljKGRlcGFydG1lbnQpIC0gMSAjIHNvY2lvbG9neSA9IDAsIHBvbGl0aWNhbCBzY2llbmNlID0gMQ0KIyBjb3ZhcmlhdGUgMg0KZGVwYXJ0bV9SUyA8LSBjb0NvdmFyKGRlcGFydG1lbnRfbnVtZXJpYykNCg0KIyBkZWZpbmUgZGF0YSBvYmplY3QgDQpteWRhdGFfTTMgPC0gc2llbmFEYXRhQ3JlYXRlKG5ldHMsIGdlbmRlcl9SUywgZGVwYXJ0bV9SUykNCg0KYGBgDQoNClByaW50IHNob3J0IGRlc2NyaXB0aXZlIHJlcG9ydA0KDQpgYGB7cn0NCmlmZWxzZSghZGlyLmV4aXN0cygicmVzdWx0cyIpLCBkaXIuY3JlYXRlKCJyZXN1bHRzIiksIEZBTFNFKQ0KDQpgYGANCg0KYGBge3J9DQpwcmludDAxUmVwb3J0KG15ZGF0YV9NMywgbW9kZWxuYW1lID0gIi4vcmVzdWx0cy9yZXN1bHRzX00zIikgIyBjcmVhdGUgZmlsZSB3aXRoIHJlcG9ydCBpbiByZXN1bHRzIGZvbGRlciANCmBgYA0KDQojIyMgLS0tU3RlcCAyOiBNYWtlIGVmZmVjdHMgb2JqZWN0L3N0cnVjdHVyZQ0KDQpgYGB7ciBSU2llbmEgbXllZmYgbTN9DQojIGRlZmluZSBlZmZlY3RzIHN0cnVjdHVyZSANCm15ZWZmX00zIDwtIGdldEVmZmVjdHMobXlkYXRhX00zKQ0KYGBgDQoNCiMjIyAtLS1TdGVwIDM6IEFkZCBFZmZlY3RzDQoNCmBgYHtyIGVmZmVjdHMgbTN9DQpteWVmZl9NMyA8LSBpbmNsdWRlRWZmZWN0cyhteWVmZl9NMywgaXNvbGF0ZU5ldCwgaW5Qb3AsIG91dEFjdCkgIyBtb2RlbCAxDQoNCm15ZWZmX00zIDwtIGluY2x1ZGVFZmZlY3RzKG15ZWZmX00zLCBlZ29YLCBhbHRYLCBkaWZmWFRyYW5zVHJpcCwgc2FtZVgsIGludGVyYWN0aW9uMSA9ICJnZW5kZXJfUlMiKSAjbW9kZWwgMg0KDQpteWVmZl9NMyA8LSBpbmNsdWRlRWZmZWN0cyhteWVmZl9NMywgZWdvWCwgYWx0WCwgc2FtZVgsIGludGVyYWN0aW9uMSA9ICJkZXBhcnRtX1JTIikgI21vZGVsIDMNCg0KYGBgDQoNCmBgYHs9aHRtbH0NCjwhLS0NCiMgaXNvbGF0ZW5ldDogaWYgaW5kaXZpZHVhbCBpcyBhbG9uZSB0aGV5ICJsaWtlIHRvL3RlbmQgdG8gc3RheSBhbG9uZSINCiMgaW5Qb3A6IHBwbCBsaWtlIHRvIGNvbGxhYm9yYXRlIHdpdGggcGVvcGxlIHdobyBhcmUgcG9wdWxhcg0KDQojIHNhbWVYDQojIHNhbWUgY292YXJpYXRlLCB3aGljaCBjYW4gYWxzbyBiZSBjYWxsZWQgY292YXJpYXRlLXJlbGF0ZWQgaWRlbnRpdHkgKHNhbWVYKSwgZGVmaW5lZCBieSB0aGUgbnVtYmVyIG9mIHRpZXMgb2YgaSB0byBhbGwgb3RoZXIgYWN0b3JzIGogd2hvIGhhdmUgZXhhY3RseSB0aGUgc2FtZSB2YWx1ZSBvbiB0aGUgY292YXJpYXRlLCBzIG5ldCBpOTUoeCkgPSBQIGp4aWogSXt2aSA9IHZqfSwNCiMgd2hlcmUgdGhlIGluZGljYXRvciBmdW5jdGlvbiBJe3ZpID0gdmp9IGlzIDEgaWYgdGhlIGNvbmRpdGlvbiB7dmkgPSB2an0gaXMgc2F0aXNmaWVkLCBhbmQgMCBpZiBpdCBpcyBub3Q7DQoNCg0KI2RpZmZYVHJhbnNUcmlwDQpkaWZmZXJlbnQgY292YXJpYXRlIMOXIHRyYW5zaXRpdmUgdHJpcGxldHMgKGRpZmZYVHJhbnNUcmlwKSwgZGVmaW5lZCBieSB0aGUgbnVtYmVyDQpvZiB0cmFuc2l0aXZlIHRyaXBsZXRzIGkg4oaSIGgg4oaSIGog4oaQIGkgdGhhdCBoYXZlIGRpZmZlcmVudCBjb3ZhcmlhdGUgdmFsdWVzIGZvciBpIGFuZCBqLA0KZGlmZi4gY292LiB2YWx1ZXMgPSBkaWZmIGdlbmRlcg0KDQotLT4NCmBgYA0KIyMjIC0tLVN0ZXAgNDogU3BlY2lmeSBtb2RlbC9hbGdvcml0aG0NCg0KYGBge3IgYWxnbyBtM30NCg0KbXlBbGdvcml0aG1fTTMgPC0gc2llbmFBbGdvcml0aG1DcmVhdGUgKHByb2puYW1lID0gInJlc3VsdHNfTTMiKQ0KDQpgYGANCg0KIyMjIC0tLVN0ZXAgNTogRXN0aW1hdGUgbW9kZWwNCg0KYGBge3IgZXN0aW1hdGUgbTMsIGV2YWwgPUZBTFNFfQ0KIyBlc3RpbWF0ZSB0aGUgbW9kZWwgDQpNb2RlbDMgPC0gc2llbmEwNyhteUFsZ29yaXRobV9NMywgZGF0YSA9IG15ZGF0YV9NMywgZWZmZWN0cyA9IG15ZWZmX00zLCByZXR1cm5EZXBzID0gVFJVRSkNCk1vZGVsMw0KDQojaWYgbWF4aW11bSBjb252ZXJnZW5jZSA+LjI1OiBydW4gYWdhaW4NCk1vZGVsMy4xIDwtIHNpZW5hMDcobXlBbGdvcml0aG1fTTMsIGRhdGEgPSBteWRhdGFfTTMsIGVmZmVjdHMgPSBteWVmZl9NMywgcHJldkFucz0gTW9kZWwzLCByZXR1cm5EZXBzID0gVFJVRSkNCk1vZGVsMy4xIA0KDQojZnNhdmUoTW9kZWwzLCBmaWxlID0iZXN0aW1hdGVkX00zIikNCiNmc2F2ZShNb2RlbDMuMSwgZmlsZSA9ICJlc3RpbWF0ZWRfTTMuMSIpDQoNCmBgYA0KDQpgYGB7ciBsb2FkIE0zIG91dHB1dCwgZWNobz1GQUxTRX0NCg0KTW9kZWwzIDwtIGZsb2FkKCIuL2RhdGEvcHJvY2Vzc2VkL2VzdGltYXRlZF9NM18yMDI0MTEyMy5yZGEiKQ0KTW9kZWwzDQoNCk1vZGVsMy4xIDwtIGZsb2FkICgiLi9kYXRhL3Byb2Nlc3NlZC9lc3RpbWF0ZWRfTTMuMV8yMDI0MTEyMy5yZGEiKQ0KTW9kZWwzLjENCmBgYA0KDQojIyMgLS0tU3RlcCA2OiBHT0YgLSBHb29kbmVzcyBvZiBGaXQNCg0KYGBge3IgR09GIE0zfQ0KR09GX00zLjEgPC0gc2llbmFHT0YoTW9kZWwzLjEgLCBJbmRlZ3JlZURpc3RyaWJ1dGlvbiwgdmVyYm9zZSA9IEZBTFNFLCBqb2luID0gVFJVRSwgdmFyTmFtZSA9ICJuZXRzIikNCg0KcGxvdChHT0ZfTTMuMSwgbWFpbiA9ICJHT0YgLSBNb2RlbCAzIFxuIEluZGVncmVlIERpc3RyaWJ1dGlvbiIpDQpgYGANCg0KLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tDQoNCiMjIFw8XD4gTW9kZWwgNCAtIEgtSW5kZXgNCg0KVGhpcyBtb2RlbCBmdXJ0aGVyIGJ1aWxkcyBvbiB0aGUgcHJpb3IgbW9kZWwgYW5kIGFsc28gaW5jbHVkZXMgdGhlDQpuZXR3b3JrIHN0YXRpc3RpY3Mgb2YgdGhlIGNvdmFyaWF0IEgtaW5kZXgsIG5hbWVseSAqKmVnb1gsIGFsdFggYW5kDQppblBvcFgqKi4NCg0KIlRoZSBsYXN0IG1vZGVsIGhhcyBhIG1heGltdW0gY29udmVyZ2VuY2UgcmF0aW8gb2YgKiowLjIzKiogYW5kIGEgYQ0KR29vZG5lc3Mgb2YgRml0IG9uIHRoZSBpbmRlZ3JlZSBkaXN0cmlidXRpb24gb2YgKiowLjE5NyoqLg0KDQpgYGAgICAgICAgICANCkVzdGltYXRlcywgc3RhbmRhcmQgZXJyb3JzIGFuZCBjb252ZXJnZW5jZSB0LXJhdGlvcw0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBFc3RpbWF0ZSAgIFN0YW5kYXJkICAgQ29udmVyZ2VuY2UNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBFcnJvciAgICAgIHQtcmF0aW8NClJhdGUgcGFyYW1ldGVyczogIA0KICAwICAgICAgUmF0ZSBwYXJhbWV0ZXIgICAgICAgICAgICAgICAgICAgICAgIDIuNjg5MSAgKCAwLjM2NzUgICApICAgICAgICAgICAgICAgDQoNCk90aGVyIHBhcmFtZXRlcnM6ICAgICANCiAgIDEuIGV2YWwgb3V0ZGVncmVlIChkZW5zaXR5KSAgICAgICAgICAgICAgICAgLTIuNzY5MyAgKCAxLjkyMDUgICApICAgIDAuMDY5OCAgICAgICANCiAgIDIuIGV2YWwgcmVjaXByb2NpdHkgICAgICAgICAgICAgICAgICAgICAgICAgIDIuMTc3MCAgKCAwLjU5NjAgICApICAgIDAuMDkxOSAgICAgICANCiAgIDMuIGV2YWwgaW5kZWdyZWUgLSBwb3B1bGFyaXR5ICAgICAgICAgICAgICAgLTAuMDY1MyAgKCAwLjE2NTQgICApICAgLTAuMDEwNCAgICAgICANCiAgIDQuIGV2YWwgb3V0ZGVncmVlIC0gYWN0aXZpdHkgICAgICAgICAgICAgICAgLTAuNjg1MSAgKCAwLjQwMjkgICApICAgIDAuMDUyNyAgICAgICANCiAgIDUuIGV2YWwgbmV0d29yay1pc29sYXRlICAgICAgICAgICAgICAgICAgICAgIDUuNDYzNCAgKCAyLjI3NzAgICApICAgIDAuMDAyOCAgICAgICANCiAgIDYuIGV2YWwgZ2VuZGVyX1JTIGFsdGVyICAgICAgICAgICAgICAgICAgICAgLTAuMDkwMyAgKCAwLjMzNzIgICApICAgIDAuMDEyOSAgICAgICANCiAgIDcuIGV2YWwgZ2VuZGVyX1JTIGVnbyAgICAgICAgICAgICAgICAgICAgICAgIDAuMjk5MyAgKCAwLjQ5MzQgICApICAgLTAuMDUwMyAgICAgICANCiAgIDguIGV2YWwgc2FtZSBnZW5kZXJfUlMgICAgICAgICAgICAgICAgICAgICAgIDAuNjgyMCAgKCAwLjI4MDQgICApICAgIDAuMDIwMSAgICAgICANCiAgIDkuIGV2YWwgdHJhbnNpdGl2ZSB0cmlwbGV0cyBkaWZmLiBnZW5kZXJfUlMgIDIuNDg3MSAgKCAwLjY2NzAgICApICAgIDAuMDUwNSAgICAgIA0KICAxMC4gZXZhbCBkZXBhcnRtX1JTIGFsdGVyICAgICAgICAgICAgICAgICAgICAgMC4zOTI5ICAoIDAuNjEyOCAgICkgICAtMC4wMDYxICAgICAgDQogIDExLiBldmFsIGRlcGFydG1fUlMgZWdvICAgICAgICAgICAgICAgICAgICAgIC0xLjQ2NTIgICggMC42OTYzICAgKSAgIC0wLjAxMTUgICAgICANCiAgMTIuIGV2YWwgc2FtZSBkZXBhcnRtX1JTICAgICAgICAgICAgICAgICAgICAgIDIuNjMyNyAgKCAwLjYwODAgICApICAgIDAuMDE3MyAgICAgIA0KICAxMy4gZXZhbCBoX2luZGV4X1JTIGFsdGVyICAgICAgICAgICAgICAgICAgICAgMC4wODI5ICAoIDAuMDM2NCAgICkgICAtMC4wMDMxICAgICAgDQogIDE0LiBldmFsIGhfaW5kZXhfUlMgZWdvICAgICAgICAgICAgICAgICAgICAgIC0wLjE1OTEgICggMC4wNzQ0ICAgKSAgICAwLjAxNjEgICAgICANCiAgMTUuIGV2YWwgaW5kLiBwb3AuXigxLzEpIHdlaWdodGVkIGhfaW5kZXhfUlMgLTAuMDI4NyAgKCAwLjA1NzAgICApICAgLTAuMDEyOQ0KYGBgDQoNCioqQ0hBTkdFISEhKioNCg0KIkluIHRoaXMgbW9kZWwsIHRoZSBwYXJhbWV0ZXJzIGZvciBkZW5zaXR5IGFuZCByZWNpcHJvY2l0eSBhcmUgc3RpbGwNCnNpZ25pZmljYW50LCB3aXRoIHZhbHVlcyBvZiAqKi0xLjk4KiogKHNlID0gKiowLjcxKiopIGFuZCAqKjIuNTkqKiAoc2UgPQ0KKiowLjM4KiopIHJlc3BlY3RpdmVseSwgbWVhbmluZyB0aGF0IGFjdG9ycyBwcmVmZXIgc3BhcnNlIG5ldHdvcmtzLCBidXQNCmRvIHByZWZlciB0byBzZW5kIHRpZXMgdG8gYWx0ZXJzIHdobyBoYXZlIHNlbnQgdGllcyB0byB0aGVtLg0KDQpJc29sYXRlTmV0IGlzIHN0aWxsIHNpZ25pZmljYW50IHdpdGggYSB2YWx1ZSBvZiAqKjMuMjMqKiAoc2UgPQ0KKioxLjA2KiopLCBpbXBseWluZyB0aGF0IGFjdG9ycyBwcmVmZXIgdG8gYmUgaXNvbGF0ZXMuDQoNCkluIHRoaXMgbW9kZWwsICoqaW5kZWdyZWUgcG9wdWxhcml0eSBzcXVhcmVkKiogKGIgPSAqKjAuMTcqKiwgc2UgPQ0KKiowLjIxKiopIGlzIG5vIGxvbmdlciBzaWduaWZpY2FudCwgaW1wbHlpbmcgdGhhdCB0aGlzIG1pZ2h0IGJlDQpleHBsYWluZWQgYnkgb3RoZXIgbmV0d29yayBzdGF0aXN0aWNzIGluIHRoZSBtb2RlbC4NCg0KVGhlIGNvdmFyaWF0ZSBzdGF0aXN0aWNzIGZvciBnZW5kZXIgc2hvdyBzaW1pbGFyIGZpbmRpbmdzIGFzIE1vZGVsIDIsDQpuYW1lbHkgdGhhdCBhY3RvcnMgcHJlZmVyIHRvIGNsb3NlIHRyaWFkcyB3aXRoIGFsdGVycyB0aGF0IGhhdmUgYQ0KZGlmZmVyZW50IHNjb3JlIGZvciBnZW5kZXIgKGIgPSAqKjEuNTEqKiwgc2UgPSAqKjAuNDQqKikuDQoNClRoZSBlZ28gZWZmZWN0IGFuZCBhbHRlciBlZmZlY3QgZm9yIGdlbmRlciBhcmUgKipub24tc2lnbmlmaWNhbnQqKiwgYXMNCndhcyB0aGUgY2FzZSBpbiBNb2RlbCAyLg0KDQpMYXN0bHksIE1vZGVsIDMgc2hvd3Mgc29tZSBzaWduaWZpY2FudCByZXN1bHRzIHdpdGggcmVnYXJkcyB0byB0aGUNCmNvdmFyaWF0ZSBuZXR3b3JrIHN0YXRpc3RpY3MgZm9yIHByZXN0aWdlLiBUaGUgcHJlc3RpZ2UgZWZmZWN0IGZvcg0KYWx0ZXJzIGlzIHBvc2l0aXZlLCBpbXBseWluZyB0aGF0IHBlb3BsZSBwcmVmZXIgdG8gc2VuZCB0aWVzIHRvIHBlb3BsZQ0Kd2hvIGhhdmUgYSBoaWdoZXIgYW1vdW50IG9mIHByZXN0aWdlIChiID0gKiowLjA0MioqLCBzZSA9ICoqMC4wMDg5KiopLg0KDQpBZGRpdGlvbmFsbHksIHRoZSBwcmVzdGlnZSBlZmZlY3QgZm9yIGVnb3MgaXMgbmVnYXRpdmUsIHdoaWNoIGluZGljYXRlcw0KdGhhdCBwZW9wbGUgd2hvIGhhdmUgaGlnaGVyIHByZXN0aWdlIHNlbmQgbGVzcyB0aWVzIChiID0gKiotMC4wMzAqKiwgc2UNCj0gKiowLjAxNSoqKS4gKipUaGlzIGlzIGluIGxpbmUgd2l0aCB0aGVvcmllcyBvZiBwcmVmZXJlbnRpYWwgYXR0YWNobWVudA0KYW5kIHVwd2FyZCBtb2JpbGl0eSwgYmVjYXVzZSBhcyBlZ29zIHdpdGggaGlnaGVyIHByZXN0aWdlIHdpbGwgYXJlIG1vcmUNCmxpa2VseSB0byByZWNlaXZlIHJlcXVlc3QgZm9yIGNvbGxhYm9yYXRpb24gcmF0aGVyIHRoZW4gc2VuZGluZyByZXF1ZXN0DQpmb3IgY29sbGFib3JhdGlvbi4qKg0KDQpJbnRlcmVzdGluZ2x5IGVub3VnaCwgdGhlIGluZGVncmVlIHBvcHVsYXJpdHkgc3RhdGlzdGljIGZvciBwcmVzdGlnZSBpcw0Kbm90IHNpZ25pZmljYW50IChiID0gKiotMC4wMTIqKiwgc2UgPSAqKjAuMDIzKiopLCBpbXBseWluZyB0aGF0IGFjdG9ycw0Kd2hvIGFyZSBtb3JlIHByZXN0aWdpb3VzIGRvIG5vdCByZWNlaXZlIG1vcmUgaW5kZWdyZWVzLiINCg0KQWJvdXQgSHlwb3RoZXNpcyA0DQoNCm1vZGVsaW5nIGhvdyB0aGUgZGVwYXJ0bWVudCBvZiB0aGUgYWN0b3IgKFNvY2lvbG9neSBvciBQb2xpdGljYWwNClNjaWVuY2UpIGluZmx1ZW5jZXMgdGhlaXIgY29sbGFib3JhdGlvbiBjaG9pY2VzIGluIHRlcm1zIG9mIGdlbmRlci4NCg0KKipJbnRlcmFjdGlvbjEgPSAiZGVwYXJ0bV9SUyIqKjogVGhpcyBhbGxvd3MgeW91IHRvIHRlc3QgaG93IGRlcGFydG1lbnQNCihTb2Npb2xvZ3kgdnMgUG9saXRpY2FsIFNjaWVuY2UpIGluZmx1ZW5jZXMgdGhlIHByb2JhYmlsaXR5IG9mIGZvcm1pbmcNCmNvbGxhYm9yYXRpb25zLCBwb3RlbnRpYWxseSBkaWZmZXJpbmcgYnkgZ2VuZGVyLiBUaGlzIG1lYW5zIHRoYXQgZ2VuZGVyDQpob21vcGhpbHkgKHdoZXRoZXIgYSBwZXJzb24gY29sbGFib3JhdGVzIG1vcmUgb2Z0ZW4gd2l0aCBzYW1lLWdlbmRlcg0KcGVlcnMpIG1pZ2h0IGJlIGRpZmZlcmVudCBpbiB0aGUgdHdvIGRlcGFydG1lbnRzLg0KDQphbGxvd3MgeW91IHRvIGV4cGxvcmUgaG93ICoqZGVwYXJ0bWVudCoqIGluZmx1ZW5jZXMgdGhlIGxpa2VsaWhvb2Qgb2YNCioqc2FtZS1nZW5kZXIqKiBjb2xsYWJvcmF0aW9ucyAoYHNhbWVYYCksIHdoaWNoIGlzIGNlbnRyYWwgdG8geW91cg0KcmVzZWFyY2ggcXVlc3Rpb24uIElmIHRoZSAqKmRlcGFydG1lbnQgdmFyaWFibGUqKiBpcyBhY3RpbmcgYXMgYW4NCmltcG9ydGFudCBjb3ZhcmlhdGUgaW5mbHVlbmNpbmcgY29sbGFib3JhdGlvbiBwYXR0ZXJucywgdGhpcyBsaW5lDQpjYXB0dXJlcyB0aGF0IGVmZmVjdC4NCg0KdGVzdGluZyBob3cgYmVpbmcgaW4gYSBwYXJ0aWN1bGFyIGRlcGFydG1lbnQgaW5mbHVlbmNlcyB0aGUgbGlrZWxpaG9vZA0Kb2YgY29sbGFib3JhdGluZyB3aXRoIHNvbWVvbmUgb2YgdGhlIHNhbWUgZ2VuZGVyLiBJbiBvdGhlciB3b3JkcywgaXQNCmNoZWNrcyBpZiB0aGUgZGVwYXJ0bWVudCBtb2RpZmllcyB0aGUgc3RyZW5ndGggb2YgZ2VuZGVyIGhvbW9waGlseQ0KKGBzYW1lWGApLg0KDQoqKk5ldHdvcmsgU3RhdGlzdGljcyoqOg0KDQotICAgKiplZ29YIChoLWluZGV4KSoqOiBFeGFtaW5lcyBob3cgdGhlIGgtaW5kZXggb2YgdGhlIGZvY2FsIHNjaG9sYXINCiAgICBhZmZlY3RzIHRoZWlyIGNvbGxhYm9yYXRpb24gYmVoYXZpb3IuDQoNCi0gICAqKmFsdFggKGgtaW5kZXgpKio6IEV4YW1pbmVzIGhvdyB0aGUgaC1pbmRleCBvZiBwb3RlbnRpYWwNCiAgICBjb2xsYWJvcmF0b3JzIGFmZmVjdHMgdGhlaXIgYXR0cmFjdGl2ZW5lc3MgYXMgcGFydG5lcnMuDQoNCiAgICBBZGQgYGVnb1hgIGFuZCBgYWx0WGAgZWZmZWN0cyBmb3IgYEhJbmRleF9SU2AgdG8gdGVzdCBpZiBwcmVzdGlnaW91cw0KICAgIHNjaG9sYXJzIGFyZSBtb3JlIGxpa2VseSB0byBpbml0aWF0ZSBvciByZWNlaXZlIHRpZXMuDQoNCi0gICAqKmluUG9wWCAoaC1pbmRleCkqKjogQXNzZXNzZXMgd2hldGhlciBwcmVzdGlnZSBpbmNyZWFzZXMgdGhlDQogICAgbGlrZWxpaG9vZCBvZiBiZWluZyBzb3VnaHQgb3V0IGFzIGEgY29sbGFib3JhdG9yLg0KDQoqKkNvbmZpcm1hdGlvbioqOg0KDQotICAgQSBzaWduaWZpY2FudCBuZWdhdGl2ZSBpbnRlcmFjdGlvbiB0ZXJtIGJldHdlZW4gYHNhbWVYYCBhbmQgaC1pbmRleA0KICAgIHN0YXRpc3RpY3Mgd291bGQgY29uZmlybSB0aGF0IHByZXN0aWdlIHJlZHVjZXMgdGhlIHN0cmVuZ3RoIG9mDQogICAgZ2VuZGVyIGhvbW9waGlseS4NCg0KLSAgIElmIGgtaW5kZXggdmFyaWFibGVzIGRvIG5vdCBzaWduaWZpY2FudGx5IGluZmx1ZW5jZSBgc2FtZVhgLCB0aGlzDQogICAgd291bGQgZGlzY29uZmlybSBIMy4NCg0KIyMjIC0tLVN0ZXAgMTogRGVmaW5lIFNpZW5hIERhdGEgJiBWYXJpYWJsZXMNCg0KYGBge3IgUlNpZW5hIGRlZmluZSBtNH0NCiMgZGVwZW5kZW50IHZhcmlhYmxlIA0KbmV0cyA8LSBzaWVuYURlcGVuZGVudChuZXRfYXJyYXkpDQoNCiMgcHV0IGdlbmRlciBpbiBvYmplY3QgDQpnZW5kZXIgPC0gZGZfZWdvJGdlbmRlcg0KIyBjb3ZhcmlhdGUgMQ0KZ2VuZGVyX1JTIDwtIGNvQ292YXIoZ2VuZGVyKSAjIGdlbmRlciBhcyBjb3ZhcmlhdGUgaW4gUnNpZW5hDQoNCiNwdXQgZGVwYXJ0bWVudCBpbiBvYmplY3QgDQpkZXBhcnRtZW50IDwtIGZhY3RvcihkZl9lZ28kZGlzY2lwbGluZS4yNCwgbGV2ZWxzID0gYygic29jaW9sb2d5IiwgInBvbGl0aWNhbCBzY2llbmNlIikpDQojbWFrZSBudW1lcmljDQpkZXBhcnRtZW50X251bWVyaWMgPC0gYXMubnVtZXJpYyhkZXBhcnRtZW50KSAtIDEgIyBzb2Npb2xvZ3kgPSAwLCBwb2xpdGljYWwgc2NpZW5jZSA9IDENCiMgY292YXJpYXRlIDINCmRlcGFydG1fUlMgPC0gY29Db3ZhcihkZXBhcnRtZW50X251bWVyaWMpDQoNCiMgcHV0IGgtaW5kZXggaW4gb2JqZWN0IA0KaF9pbmRleCA8LSBkZl9lZ28kaF9pbmRleA0KZGZfZWdvJGhfaW5kZXgNCiMgY292YXJpYXRlIDMNCmhfaW5kZXhfUlMgPC0gY29Db3ZhcihoX2luZGV4KSAjIGhfaW5kZXggYXMgY292YXJpYXRlIGluIFJTaWVuYQ0KDQojIGRlZmluZSBkYXRhIG9iamVjdCANCm15ZGF0YV9NNCA8LSBzaWVuYURhdGFDcmVhdGUobmV0cywgZ2VuZGVyX1JTLCBkZXBhcnRtX1JTLCBoX2luZGV4X1JTKQ0KDQpgYGANCg0KUHJpbnQgc2hvcnQgZGVzY3JpcHRpdmUgcmVwb3J0DQoNCmBgYHtyfQ0KaWZlbHNlKCFkaXIuZXhpc3RzKCJyZXN1bHRzIiksIGRpci5jcmVhdGUoInJlc3VsdHMiKSwgRkFMU0UpDQoNCmBgYA0KDQpgYGB7cn0NCnByaW50MDFSZXBvcnQobXlkYXRhX000LCBtb2RlbG5hbWUgPSAiLi9yZXN1bHRzL3Jlc3VsdHNfTTQiKSAjIGNyZWF0ZSBmaWxlIHdpdGggcmVwb3J0IGluIHJlc3VsdHMgZm9sZGVyIA0KYGBgDQoNCiMjIyAtLS1TdGVwIDI6IE1ha2UgZWZmZWN0cyBvYmplY3Qvc3RydWN0dXJlDQoNCmBgYHtyIFJTaWVuYSBteWVmZiBNNH0NCg0KIyBkZWZpbmUgZWZmZWN0cyBzdHJ1Y3R1cmUgDQpteWVmZl9NNCA8LSBnZXRFZmZlY3RzKG15ZGF0YV9NNCkNCg0KYGBgDQoNCiMjIyAtLS1TdGVwIDM6IEFkZCBFZmZlY3RzDQoNCmBgYHtyIGVmZmVjdHMgTTR9DQoNCm15ZWZmX000IDwtIGluY2x1ZGVFZmZlY3RzKG15ZWZmX000LCBpc29sYXRlTmV0LCBpblBvcCwgb3V0QWN0KSAjIG1vZGVsIDENCg0KbXllZmZfTTQgPC0gaW5jbHVkZUVmZmVjdHMobXllZmZfTTQsIGVnb1gsIGFsdFgsIGRpZmZYVHJhbnNUcmlwLCBzYW1lWCwgaW50ZXJhY3Rpb24xID0gImdlbmRlcl9SUyIpICNtb2RlbCAyDQoNCm15ZWZmX000IDwtIGluY2x1ZGVFZmZlY3RzKG15ZWZmX000LCBlZ29YLCBhbHRYLCBzYW1lWCwgaW50ZXJhY3Rpb24xID0gImRlcGFydG1fUlMiKSAjbW9kZWwgMw0KICANCm15ZWZmX000IDwtIGluY2x1ZGVFZmZlY3RzKG15ZWZmX000LCBlZ29YLCBhbHRYLCBpblBvcFgsIGludGVyYWN0aW9uMSA9ICJoX2luZGV4X1JTIikgIyBtb2RlbCA0DQoNCmBgYA0KDQpgYGB7PWh0bWx9DQo8IS0tDQojIGlzb2xhdGVuZXQ6IGlmIGluZGl2aWR1YWwgaXMgYWxvbmUgdGhleSAibGlrZSB0by90ZW5kIHRvIHN0YXkgYWxvbmUiDQojIGluUG9wOiBwcGwgbGlrZSB0byBjb2xsYWIgd2l0aCBwZW9wbGUgd2hvIGFyZSBwb3B1bGFyDQoNCiMgc2FtZVgNCiMgc2FtZSBjb3ZhcmlhdGUsIHdoaWNoIGNhbiBhbHNvIGJlIGNhbGxlZCBjb3ZhcmlhdGUtcmVsYXRlZCBpZGVudGl0eSAoc2FtZVgpLCBkZWZpbmVkIGJ5IHRoZSBudW1iZXIgb2YgdGllcyBvZiBpIHRvIGFsbCBvdGhlciBhY3RvcnMgaiB3aG8gaGF2ZSBleGFjdGx5IHRoZSBzYW1lIHZhbHVlIG9uIHRoZSBjb3ZhcmlhdGUsIHMgbmV0IGk5NSh4KSA9IFAganhpaiBJe3ZpID0gdmp9LA0KIyB3aGVyZSB0aGUgaW5kaWNhdG9yIGZ1bmN0aW9uIEl7dmkgPSB2an0gaXMgMSBpZiB0aGUgY29uZGl0aW9uIHt2aSA9IHZqfSBpcyBzYXRpc2ZpZWQsIGFuZCAwIGlmIGl0IGlzIG5vdDsNCg0KIyBsb29rIHVwIGluUG9wWDogcHJlZmVyZW50aWFsIGF0dGFjaG1lbnQgKGNmLiBLb2VuIGxlbCksIGhpZ2hlciBoLWluZGV4IG1vcmUgcG9wdWxhciANCiAgIyBjZi4gRnJpZGFzIG1vZGVsaW5nIHByb2Nlc3MgKEpvY2hlbSB0b2xkIGhlciB0aGF0ICkNCg0KLS0+DQpgYGANCiMjIyAtLS1TdGVwIDQ6IFNwZWNpZnkgbW9kZWwvYWxnb3JpdGhtDQoNCmBgYHtyIGFsZ28gTTR9DQoNCm15QWxnb3JpdGhtX000IDwtIHNpZW5hQWxnb3JpdGhtQ3JlYXRlIChwcm9qbmFtZSA9ICJyZXN1bHRzX000IikNCg0KYGBgDQoNCiMjIyAtLS1TdGVwIDU6IEVzdGltYXRlIG1vZGVsDQoNCmBgYHtyIGVzdGltYXRlIE00LCBldmFsID1GQUxTRX0NCiMgZXN0aW1hdGUgdGhlIG1vZGVsIA0KTW9kZWw0IDwtIHNpZW5hMDcobXlBbGdvcml0aG1fTTQsIGRhdGEgPSBteWRhdGFfTTQsIGVmZmVjdHMgPSBteWVmZl9NNCwgcmV0dXJuRGVwcyA9IFRSVUUpDQpNb2RlbDQNCg0KI2ZzYXZlKE1vZGVsNCwgZmlsZSA9ImVzdGltYXRlZF9NNCIpDQoNCmBgYA0KDQpgYGB7ciBsb2FkIE00IG91dHB1dCwgZWNobz1GQUxTRX0NCg0KTW9kZWw0IDwtIGZsb2FkKCIuL2RhdGEvcHJvY2Vzc2VkL2VzdGltYXRlZF9NNF8yMDI0MTEyMy5yZGEiKQ0KTW9kZWw0DQoNCmBgYA0KDQojIyMgLS0tU3RlcCA2OiBHT0YgLSBHb29kbmVzcyBvZiBGaXQNCg0KYGBge3IgR09GIE00fQ0KR09GX000IDwtIHNpZW5hR09GKE1vZGVsNCwgSW5kZWdyZWVEaXN0cmlidXRpb24sIHZlcmJvc2UgPSBGQUxTRSwgam9pbiA9IFRSVUUsIHZhck5hbWUgPSAibmV0cyIpDQoNCnBsb3QoR09GX000LCBtYWluID0gIkdPRiAtIE1vZGVsIDQgXG4gSW5kZWdyZWUgRGlzdHJpYnV0aW9uIikNCmBgYA0K</div>


</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->
<script>
$(document).ready(function () {
  window.initializeSourceEmbed("modelestimate.Rmd");
  window.initializeCodeFolding("show" === "show");
});
</script>

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
