<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />


<meta name="author" content="Verooo" />

<meta name="date" content="2024-11-20" />

<title>Model estimation</title>

<script src="site_libs/header-attrs-2.28/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/darkly.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.13.2/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<script src="site_libs/navigation-1.1/codefolding.js"></script>
<script src="site_libs/navigation-1.1/sourceembed.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<script src="site_libs/clipboard-1.7.1/clipboard.min.js"></script>
<link href="site_libs/primer-tooltips-1.4.0/build.css" rel="stylesheet" />
<link href="site_libs/klippy-0.0.0.9500/css/klippy.min.css" rel="stylesheet" />
<script src="site_libs/klippy-0.0.0.9500/js/klippy.min.js"></script>
<link href="site_libs/font-awesome-6.4.2/css/all.min.css" rel="stylesheet" />
<link href="site_libs/font-awesome-6.4.2/css/v4-shims.min.css" rel="stylesheet" />

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>




<style type="text/css">
#rmd-source-code {
  display: none;
}
</style>


<link rel="stylesheet" href="styles.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark the anchor link active (and if it's in a dropdown, also mark that active)
  var dropdown = menuAnchor.closest('li.dropdown');
  if (window.bootstrap) { // Bootstrap 4+
    menuAnchor.addClass('active');
    dropdown.find('> .dropdown-toggle').addClass('active');
  } else { // Bootstrap 3
    menuAnchor.parent().addClass('active');
    dropdown.addClass('active');
  }

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before, .tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "\e259";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "\e258";
  font-family: 'Glyphicons Halflings';
  border: none;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->
<style type="text/css">
.code-folding-btn { margin-bottom: 4px; }
</style>



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html"></a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">
    <span class="fa fa-home"></span>
     
  </a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    My journal
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="testjt.html">Week 1</a>
    </li>
    <li>
      <a href="week2.html">Week 2</a>
    </li>
    <li>
      <a href="Webscraping-Chapter8-tutorial.html">Chapter 8 - Webscraping tutorial</a>
    </li>
    <li>
      <a href="week3RSelenium.html">Week 3 - RSelenium (see Ch.8 tab tho)</a>
    </li>
    <li>
      <a href="networkvis.html">Chapter 9 - Netw. Visualisation tutorial</a>
    </li>
    <li>
      <a href="week5.html">Week 5/Chapter 7 - Analysis pt.1</a>
    </li>
    <li>
      <a href="week5-2.html">!Week 5/Chapter 7 - Analysis pt.2</a>
    </li>
    <li>
      <a href="datapractice1.html">Week 5 - Practice data 1</a>
    </li>
    <li>
      <a href="week6.html">Week 6</a>
    </li>
    <li>
      <a href="weekbacktrack.html">Week Nr. getbackontrack</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    RQs
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="RQdraft1.html">1st draft</a>
    </li>
    <li>
      <a href="RQdraft2.html">2nd draft - w Intro &amp; data types</a>
    </li>
    <li>
      <a href="RQdraft3.html">3rd draft</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Project design
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="clarifyRQsandDesign.html">Clarify RQs</a>
    </li>
    <li>
      <a href="plotting1.html">Plotting</a>
    </li>
    <li>
      <a href="revisitwithJochem.html">Check-in with Jochem</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Step-by-step analysis
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="datapreptrynew.html">Data prep</a>
    </li>
    <li>
      <a href="descriptivestry.html">Step 3: initial description</a>
    </li>
    <li>
      <a href="RSienatry.html">Step 4&amp;5: Specify &amp; Estimate model</a>
    </li>
    <li>
      <a href="estimate_M0.html">Test estimate display</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Draft report
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="draftintro.html">Introduction</a>
    </li>
    <li>
      <a href="drafttheory.html">Theory</a>
    </li>
    <li class="dropdown-submenu">
      <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">Data</a>
      <ul class="dropdown-menu" role="menu">
        <li>
          <a href="draftdata.html">Data &amp; Analysis</a>
        </li>
        <li>
          <a href="datapreptrynew.html">Data preparation</a>
        </li>
        <li>
          <a href="descriptivestry.html">Descriptives</a>
        </li>
      </ul>
    </li>
    <li class="dropdown-submenu">
      <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">Results</a>
      <ul class="dropdown-menu" role="menu">
        <li>
          <a href="draftdesresults.html">Descriptive results</a>
        </li>
        <li>
          <a href="modelestimate.html">Model Estimation</a>
        </li>
        <li>
          <a href="draftGOF.html">Goodness Of Fit</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="draftdiscussion.html">Discussion &amp; Conclusion</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Final report
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="finalintro.html">Introduction</a>
    </li>
    <li>
      <a href="finaltheory.html">Theory</a>
    </li>
    <li class="dropdown-submenu">
      <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">Data</a>
      <ul class="dropdown-menu" role="menu">
        <li>
          <a href="finaldata.html">Data &amp; Analysis</a>
        </li>
        <li>
          <a href="finaldataprep.html">Data Preparation</a>
        </li>
        <li>
          <a href="finaldescriptives.html">Data Descriptives</a>
        </li>
      </ul>
    </li>
    <li class="dropdown-submenu">
      <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">Results</a>
      <ul class="dropdown-menu" role="menu">
        <li>
          <a href="finaldesresults.html">Descriptive Analysis</a>
        </li>
        <li>
          <a href="finalestimate.html">Model Estimation</a>
        </li>
        <li>
          <a href="finalGOF.html">Goodness Of Fit</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="finaldiscussion.html">Discussion &amp; Conclusion</a>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/JochemTolsma/labjournal">
    <span class="fab fa-github"></span>
     
  </a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">

<div class="btn-group pull-right float-right">
<button type="button" class="btn btn-default btn-xs btn-secondary btn-sm dropdown-toggle" data-toggle="dropdown" data-bs-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><span>Code</span> <span class="caret"></span></button>
<ul class="dropdown-menu dropdown-menu-right" style="min-width: 50px;">
<li><a id="rmd-show-all-code" href="#">Show All Code</a></li>
<li><a id="rmd-hide-all-code" href="#">Hide All Code</a></li>
<li role="separator" class="divider"></li>
<li><a id="rmd-download-source" href="#">Download Rmd</a></li>
</ul>
</div>



<h1 class="title toc-ignore">Model estimation</h1>
<h4 class="author">Verooo</h4>
<h4 class="date">2024-11-20</h4>

</div>


<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
My Descriptives
</title>
<p><link rel="stylesheet" href="styles.css">
<!-- Link to the CSS file I created for dark mode code chunks --></p>
</head>
</html>
<script>
  addClassKlippyTo("pre.r, pre.markdown");
  addKlippy('right', 'top', 'auto', '1', 'Copy code', 'Copied!');
</script>
<p>Note to self. Keep in mind:<br />
<strong>meaning of significance in RSiena</strong> “It is important to
mention that significance in RSiena means something different than in
conventional statistics. In normal statistics, such as OLS-regression,
significance of estimates refers to the fact that they are not 0
(<strong>RELEVANT?</strong>). In RSiena, however, it refers to the fact
that the estimates were precisely determined (Ripley et al. 2011). Going
forward with this chapter, significance will refer to this definition of
significance.” - Niels Vullings</p>
<div id="setup" class="section level1" number="1">
<h1><span class="header-section-number">1</span> Setup</h1>
<p>Clean workspace. As always.</p>
<pre class="r test"><code>rm(list = ls())</code></pre>
<div id="packages" class="section level2" number="1.1">
<h2><span class="header-section-number">1.1</span> Packages</h2>
<pre class="r test"><code>require(tidyverse)
require(RSiena)
require(RsienaTwoStep)

# install.packages(&#39;data.table&#39;)
require(data.table)  # mainly for faster data handling
# install.packages(&#39;xml2&#39;)
require(xml2)
# install.packages(&#39;rvest&#39;)
require(rvest)
require(igraph)
require(ggraph)


# install.packages(&#39;visNetwork&#39;)
require(visNetwork)
# install.packages(&#39;threejs&#39;)
require(threejs)
# install.packages(&#39;networkD3&#39;)
require(networkD3)</code></pre>
</div>
<div id="functions" class="section level2" number="1.2">
<h2><span class="header-section-number">1.2</span> Functions</h2>
<p>Functions chunk:</p>
<pre class="r test"><code>fpackage.check &lt;- function(packages) {
    lapply(packages, FUN = function(x) {
        if (!require(x, character.only = TRUE)) {
            install.packages(x, dependencies = TRUE)
            library(x, character.only = TRUE)
        }
    })
}

fsave &lt;- function(x, file = NULL, location = &quot;./data/processed/&quot;) {
    ifelse(!dir.exists(&quot;data&quot;), dir.create(&quot;data&quot;), FALSE)
    ifelse(!dir.exists(&quot;data/processed&quot;), dir.create(&quot;data/processed&quot;), FALSE)
    if (is.null(file))
        file = deparse(substitute(x))
    datename &lt;- substr(gsub(&quot;[:-]&quot;, &quot;&quot;, Sys.time()), 1, 8)
    totalname &lt;- paste(location, file, &quot;_&quot;, datename, &quot;.rda&quot;, sep = &quot;&quot;)
    save(x, file = totalname)  #need to fix if file is reloaded as input name, not as x. 
}

fload &lt;- function(filename) {
    load(filename)
    get(ls()[ls() != &quot;filename&quot;])
}

fshowdf &lt;- function(x, ...) {
    knitr::kable(x, digits = 2, &quot;html&quot;, ...) %&gt;%
        kableExtra::kable_styling(bootstrap_options = c(&quot;striped&quot;, &quot;hover&quot;)) %&gt;%
        kableExtra::scroll_box(width = &quot;100%&quot;, height = &quot;300px&quot;)
}


# this is the most important one. We created it in the previous script

f_pubnets &lt;- function(df_scholars = df, list_publications = publications, discip = &quot;sociology&quot; + &quot;political science&quot;,
    affiliation = &quot;RU&quot;, waves = list(wave1 = c(2018, 2019, 2020), wave2 = c(2021, 2022, 2023))) {

    publications &lt;- list_publications %&gt;%
        bind_rows() %&gt;%
        distinct(title, .keep_all = TRUE)

    df_scholars %&gt;%
        filter(affil1 == affiliation | affil2 == affiliation) %&gt;%
        filter(discipline == discip) -&gt; df_sel

    networklist &lt;- list()
    for (wave in 1:length(waves)) {
        networklist[[wave]] &lt;- matrix(0, nrow = nrow(df_sel), ncol = nrow(df_sel))
    }

    publicationlist &lt;- list()
    for (wave in 1:length(waves)) {
        publicationlist[[wave]] &lt;- publications %&gt;%
            filter(gs_id %in% df_sel$gs_id) %&gt;%
            filter(year %in% waves[[wave]]) %&gt;%
            select(author) %&gt;%
            lapply(str_split, pattern = &quot;,&quot;)
    }

    publicationlist2 &lt;- list()
    for (wave in 1:length(waves)) {
        publicationlist2[[wave]] &lt;- publicationlist[[wave]]$author %&gt;%
            # lowercase
        lapply(tolower) %&gt;%
            # Removing diacritics
        lapply(stri_trans_general, id = &quot;latin-ascii&quot;) %&gt;%
            # only last name
        lapply(word, start = -1, sep = &quot; &quot;) %&gt;%
            # only last last name
        lapply(word, start = -1, sep = &quot;-&quot;)
    }

    for (wave in 1:length(waves)) {
        # let us remove all publications with only one author
        remove &lt;- which(sapply(publicationlist2[[wave]], FUN = function(x) length(x) == 1) == TRUE)
        publicationlist2[[wave]] &lt;- publicationlist2[[wave]][-remove]
    }

    for (wave in 1:length(waves)) {
        pubs &lt;- publicationlist2[[wave]]
        for (ego in 1:nrow(df_sel)) {
            # which ego?
            lastname_ego &lt;- df_sel$lastname[ego]
            # for all publications
            for (pub in 1:length(pubs)) {
                # only continue if ego is author of pub
                if (lastname_ego %in% pubs[[pub]]) {
                  aut_pot &lt;- which.max(pubs[[pub]] %in% lastname_ego)
                  # only continue if ego is first author of pub
                  if (aut_pot == 1) {
                    # check all alters/co-authors
                    for (alter in 1:nrow(df_sel)) {
                      # which alter
                      lastname_alter &lt;- df_sel$lastname[alter]
                      if (lastname_alter %in% pubs[[pub]]) {
                        networklist[[wave]][ego, alter] &lt;- networklist[[wave]][ego, alter] + 1
                      }
                    }
                  }
                }
            }
        }
    }
    return(list(df = df_sel, network = networklist))
}</code></pre>
<p>More functions:</p>
<pre class="r test"><code>fcolnet &lt;- function(data = scholars, university = &quot;RU&quot;, discipline = &quot;sociology&quot; + &quot;political science&quot;,
    waves = list(c(2015, 2018), c(2019, 2023)), type = c(&quot;first&quot;)) {

    # step 1
    demographics &lt;- do.call(rbind.data.frame, data$demographics)
    demographics &lt;- demographics %&gt;%
        mutate(Universiteit1.22 = replace(Universiteit1.22, is.na(Universiteit1.22), &quot;&quot;), Universiteit2.22 = replace(Universiteit2.22,
            is.na(Universiteit2.22), &quot;&quot;), Universiteit1.24 = replace(Universiteit1.24, is.na(Universiteit1.24),
            &quot;&quot;), Universiteit2.24 = replace(Universiteit2.24, is.na(Universiteit2.24), &quot;&quot;), discipline.22 = replace(discipline.22,
            is.na(discipline.22), &quot;&quot;), discipline.24 = replace(discipline.24, is.na(discipline.24), &quot;&quot;))

    sample &lt;- which((demographics$Universiteit1.22 %in% university | demographics$Universiteit2.22 %in%
        university | demographics$Universiteit1.24 %in% university | demographics$Universiteit2.24 %in%
        university) &amp; (demographics$discipline.22 %in% discipline | demographics$discipline.24 %in% discipline))

    demographics_soc &lt;- demographics[sample, ]
    scholars_sel &lt;- lapply(scholars, &quot;[&quot;, sample)

    # step 2
    ids &lt;- demographics_soc$au_id
    nwaves &lt;- length(waves)
    nets &lt;- array(0, dim = c(nwaves, length(ids), length(ids)), dimnames = list(wave = 1:nwaves, ids,
        ids))
    dimnames(nets)

    # step 3
    df_works &lt;- tibble(works_id = unlist(lapply(scholars_sel$work, function(l) l$id)), works_author = unlist(lapply(scholars_sel$work,
        function(l) l$author), recursive = FALSE), works_year = unlist(lapply(scholars_sel$work, function(l) l$publication_year),
        recursive = FALSE))

    df_works &lt;- df_works[!duplicated(df_works), ]

    # step 4
    if (type == &quot;first&quot;) {
        for (j in 1:nwaves) {
            df_works_w &lt;- df_works[df_works$works_year &gt;= waves[[j]][1] &amp; df_works$works_year &lt;= waves[[j]][2],
                ]
            for (i in 1:nrow(df_works_w)) {
                ego &lt;- df_works_w$works_author[i][[1]]$au_id[1]
                alters &lt;- df_works_w$works_author[i][[1]]$au_id[-1]
                if (sum(ids %in% ego) &gt; 0 &amp; sum(ids %in% alters) &gt; 0) {
                  nets[j, which(ids %in% ego), which(ids %in% alters)] &lt;- 1
                }
            }
        }
    }

    if (type == &quot;last&quot;) {
        for (j in 1:nwaves) {
            df_works_w &lt;- df_works[df_works$works_year &gt;= waves[[j]][1] &amp; df_works$works_year &lt;= waves[[j]][2],
                ]
            for (i in 1:nrow(df_works_w)) {
                ego &lt;- rev(df_works_w$works_author[i][[1]]$au_id)[1]
                alters &lt;- rev(df_works_w$works_author[i][[1]]$au_id)[-1]
                if (sum(ids %in% ego) &gt; 0 &amp; sum(ids %in% alters) &gt; 0) {
                  nets[j, which(ids %in% ego), which(ids %in% alters)] &lt;- 1
                }
            }
        }
    }

    if (type == &quot;all&quot;) {
        for (j in 1:nwaves) {
            df_works_w &lt;- df_works[df_works$works_year &gt;= waves[[j]][1] &amp; df_works$works_year &lt;= waves[[j]][2],
                ]
            for (i in 1:nrow(df_works_w)) {
                egos &lt;- df_works_w$works_author[i][[1]]$au_id
                if (sum(ids %in% egos) &gt; 0) {
                  nets[j, which(ids %in% egos), which(ids %in% egos)] &lt;- 1
                }
            }
        }
    }
    output &lt;- list()
    output$data &lt;- scholars_sel
    output$nets &lt;- nets
    return(output)
}</code></pre>
</div>
</div>
<div id="get-data" class="section level1" number="2">
<h1><span class="header-section-number">2</span> Get Data</h1>
<p>Load Scholar Data</p>
<pre class="r test"><code>scholars &lt;- fload(&quot;./data/processed/scholars_20240924.rda&quot;)</code></pre>
<p>Save the output of the function.</p>
<pre class="r test"><code># save the output of your function
test &lt;- fcolnet(data = scholars, university = &quot;RU&quot;, discipline = c(&quot;sociology&quot;, &quot;political science&quot;),
    waves = list(c(2015, 2018), c(2019, 2023)), type = c(&quot;first&quot;))</code></pre>
<p>Load Ego Data</p>
</div>
<div id="make-network-data" class="section level1" number="3">
<h1><span class="header-section-number">3</span> Make Network Data</h1>
<pre class="r test"><code># step1 data
wave1 &lt;- test$nets[1, , ]
wave2 &lt;- test$nets[2, , ]

# put nets in an array
net_array &lt;- array(data = c(wave1, wave2), dim = c(dim(wave1), 2))</code></pre>
<hr />
</div>
<div id="analysis" class="section level1" number="4">
<h1><span class="header-section-number">4</span> Analysis</h1>
<!--
## TEST MODEL

### test 1: Define Siena Data & Variables
-->
<!-- Print short descriptive report-->
<!-- ### test 2: Make effects object/structure -->
<!--

e.g. outdegree (density), called density, three things: evaluation,
endowment, and creation you can only include two of the three (tie
creation, breaking and maintaining)

The assumption is: mechanisms to make and break a a tie are the same so
WE ONLY USE THE EVALUATION part

All these effects are described in the manual of RSiena Chapter 12!

-->
<!--  
### Step X: Initial description
-->
<!--
Has a lot of information in there Also: how tie CHANGED Also: Jaccard
index (measure of stability) Also rate parameter and outdegree

<https://www.stats.ox.ac.uk/~snijders/siena/RSiena_Manual.pdf>

In the package RsienaTwoStep there are functions for the following
network statistics ***s*** :

degree: `ts_degree()`

reciprocity: `ts_recip()`

outdegree activity: `ts_outAct()`

indegree activity: `ts_inAct()`

outdegree popularity: `ts_outPop()`

indegree popularity: `ts_inPop()`

transitivity: `ts_transTrip()`

mediated transitivity: `ts_transMedTrip()`

transitive reciprocated triplets: `ts_transRecTrip()`

number of three-cycles: `ts_cycle3()`
-->
<!-- ### test 3: Add Effects -->
<!-- 


hint FOR MY OWN PROJECT: interaction effect of these statistics and the
effect of gender

THE "X" in altX and eogX refer to the "interaction 1" variable, so it's eg. ego x gender_RS and alter x gender_RS!

altX - egos send more ties who have more on gender (aka. gender =1) 
(iiiish look at egoX explanantion, this is basically the same but in "reverse", aka about receiving rather than sending)

-   covariate-alter or covariate-related popularity (altX), defined by
    the sum of the covariate over all actors to whom ***i*** has a tie,
-   same as egoX but RECEIVING ties

egoX - [definition?]

-   covariate-ego or covariate-related activity (egoX), defined by i’s
    out-degree weighted by his covariate value,
-   since male = 1 egoX only "looks at" men's ties 
-   if egoX significant then men's ties sign. diff. based on whether its to a man or woman (look at direction of effect to know which gender) 



sameX (Gender): Tests whether scholars prefer same-gender collaborators (direct measure of gender homophily).
model the general tendency for scholars to collaborate with same-gender peers.

  Confirmation:

    Significant and positive coefficient for sameX in the RSiena output would confirm that gender homophily exists.

    A non-significant or negative coefficient would disconfirm this hypothesis.


    

"interaction1" HAS NOTHING TO DO WITH AN INTERACTION EFFECT

-   If there are several dependent variables (networks and/or behavioral
    variables), the name of the dependent variable (name) also is
    required to specify the effect, and will be given in the column
    interaction1 (etc.) of the effects object.

-   It should be mentioned that the keywords interaction1, interaction2,
    and interaction3 in functions such as includeEffects do not point to
    interactions between effects. These keywords are used only to
    exactly specify an effect. They point to the covariate or other
    dependent variable used in the effect; this name was chosen for the
    keyword because this other variable may be said to be interacting
    with the dependent variable (network or behavior).

-->
<!-- ### test 4: Specify model/algorithm -->
<!-- ### test 5: Estimate model -->
<!-- 
output:  convergence ration NA probably bc we chose all ties to be included (type = "all") earlier
we can go back and change that or change it here in the myAlgorithm function

convergence ratio should be <.25   !!!
- if above, run model again
- if stays above .25, remove some of the netw. stats
- if close to threshold (e.g. 0.2584) add prevAns = model1  to the siena07 command and rerun then
      model1 <- siena07(myAlgorithm, data = mydata, effects = myeff, prevAns= model1, returnDeps = TRUE)

-->
<!-- ### test 6: GOF - Goodness of Fit -->
<!-- 

Make it a directed network:  ties from "all" to "first"
focus: writing,
model interpretation


### Questions

-   Is the use of RSiena different for people who look at 1 vs 2 waves.
    I need to look at one, made 2 anyways bc RSiena needs waves to do
    it's thing but:\
    Doesn't it look at ministeps over time? How can I interpret the
    output in a way that pertains to only one wave when the process
    seems to consider it within the construct of 'future change'?

    -   How does my model interpretation potentially differ from peeps
        who looked at two waves (or more)?

-   not looking at TWoStep! diff. modelling process. 
RSiena works with ministeps indeed not just Twosteps (that works with two steps lol)


- diff. betweeen wave 1 and wave 2 model -> convergence 
- default recip. and degree: estimates the putput based on a certain reciproc. and degree "assumption"
 
-->
<div id="model-0---null-model" class="section level2" number="4.1">
<h2><span class="header-section-number">4.1</span> &lt;&gt; Model 0 -
Null Model</h2>
<p>First, I estimated a null model with only reciprocity and degree. The
maximum convergence ratio of the model is 0.084. The GOF on the Indegree
Distribution is zero<strong>.</strong> This indicates that the model is
a very bad fit for the data and estimates of this model do not give us
reliable information.<br />
<em>For all GOF plots compiled in one place, see here: <a
href="https://treesdude.github.io/labjournal/finalGOF.html"
class="uri">https://treesdude.github.io/labjournal/finalGOF.html</a>.<br />
</em>For the sake of practise, here they are anyways:<br />
The outdegree (density) effect assesses the tendency of nodes to
establish outgoing connections, serving as a baseline for the likelihood
that any given node will initiate an outgoing tie. In the context of
this study, these outgoing ties represent the initiation of
co-publications. The outdegree estimate is significant and negative (b =
-2.6388, SE = 0.1460), suggesting that a scholar’s tendency to initiate
collaboration is low and dense networks are less sought after. The
reciprocity parameter id significant and positive (b = 1.8035, SE =
0.4343), which implies that directed ties are likely to be reciprocated.
Specific to our case, it describes that scholars tend to initiate
collaborations with those alters who sent a tie to them too.</p>
<div id="step-1-define-siena-data-variables" class="section level3"
number="4.1.1">
<h3><span class="header-section-number">4.1.1</span> —Step 1: Define
Siena Data &amp; Variables</h3>
<pre class="r test"><code># dependent variable
nets &lt;- sienaDependent(net_array)

# define data object
mydata_M0 &lt;- sienaDataCreate(nets)</code></pre>
<p>Print short descriptive report</p>
<pre class="r test"><code>ifelse(!dir.exists(&quot;results&quot;), dir.create(&quot;results&quot;), FALSE)</code></pre>
<pre class="test2"><code>#&gt; [1] FALSE</code></pre>
<pre class="r test"><code>print01Report(mydata_M0, modelname = &quot;./results/results_M0&quot;)  # create file with report in results folder </code></pre>
</div>
<div id="step-2-make-effects-objectstructure" class="section level3"
number="4.1.2">
<h3><span class="header-section-number">4.1.2</span> —Step 2: Make
effects object/structure</h3>
<pre class="r test"><code># define effects structure
myeff_M0 &lt;- getEffects(mydata_M0)</code></pre>
</div>
<div id="step-3-add-effects" class="section level3" number="4.1.3">
<h3><span class="header-section-number">4.1.3</span> —Step 3: Add
Effects</h3>
<p>Null model: none.</p>
</div>
<div id="step-4-specify-modelalgorithm" class="section level3"
number="4.1.4">
<h3><span class="header-section-number">4.1.4</span> —Step 4: Specify
model/algorithm</h3>
<pre class="r test"><code>myAlgorithm_M0 &lt;- sienaAlgorithmCreate(projname = &quot;results_M0&quot;)</code></pre>
<pre class="test2"><code>#&gt; If you use this algorithm object, siena07 will create/use an output file results_M0.txt .</code></pre>
</div>
<div id="step-5-estimate-model" class="section level3" number="4.1.5">
<h3><span class="header-section-number">4.1.5</span> —Step 5: Estimate
model</h3>
<pre class="r test"><code># estimate the model
Model0 &lt;- siena07(myAlgorithm_M0, data = mydata_M0, effects = myeff_M0, returnDeps = TRUE)
Model0

fsave(Model0, file = &quot;estimated_M0&quot;)</code></pre>
<pre class="test2"><code>#&gt; Estimates, standard errors and convergence t-ratios
#&gt; 
#&gt;                               Estimate   Standard   Convergence 
#&gt;                                            Error      t-ratio   
#&gt; 
#&gt; Rate parameters: 
#&gt;   0       Rate parameter       2.1170  ( 0.3561   )             
#&gt; 
#&gt; Other parameters: 
#&gt;   1. eval outdegree (density) -2.6388  ( 0.1460   )    0.0182   
#&gt;   2. eval reciprocity          1.8035  ( 0.4343   )   -0.0668   
#&gt; 
#&gt; Overall maximum convergence ratio:    0.0843 
#&gt; 
#&gt; 
#&gt; Total of 2012 iteration steps.</code></pre>
<pre class="r test"><code>GOF_M0 &lt;- sienaGOF(Model0, IndegreeDistribution, verbose = FALSE, join = TRUE, varName = &quot;nets&quot;)

plot(GOF_M0, main = &quot;GOF - \&quot;Null\&quot; Model 0 \n Indegree Distribution&quot;)</code></pre>
<p><img src="modelestimate_files/figure-html/GOF%20M0-1.png" width="672" /></p>
<hr />
</div>
</div>
<div id="model-1---structural-effects" class="section level2"
number="4.2">
<h2><span class="header-section-number">4.2</span> &lt;&gt; Model 1 -
Structural Effects</h2>
<p>This model additionally entails InPop, outAct, isolateNet to control
for effects of network statistics. The maximum convergence ratio of this
model is <strong>0.17</strong> and a Goodness of Fit on the indegree
distribution is <strong>0.002.</strong> Estimates of this model do not
fit the data well and thus do not give us reliable information.</p>
<p>For the sake of practise, here they are anyways:<br />
As in our null model, the parameters for outdegree (b = -2.0862, SE =
0.7050) and reciprocity (b = 1.0894, SE = 0.4144) remain significant and
unchanged on their ‘direction’.</p>
<p>The added parameter for indegree popularity tells us something about
the popularity of people who have a lot of outgoing ties. In our model
the estimate for this parameter is significantly positive (b =0.2549, SE
=0.0439), suggesting that scholars specifically like to initiate
collaborations with those who have a lot of indegrees.</p>
<p>Further, the parameter for outdegree activity conveys information
about scholars’ preferences to collaborate with others who have a lot of
outdegrees. In our case, the estimate is insignificant and cannot be
reliably interpreted.</p>
<p>Lastly, the network isolate parameter can be used to infer about
scholars’ tendency to neither send nor receive ties. The estimate for
this parameter is significantly positive (b = 4.9645, SE = 1.1146) in
our model, indicating that the scholars of our sample tend to remain
isolates.</p>
<div id="step-1-define-siena-data-variables-1" class="section level3"
number="4.2.1">
<h3><span class="header-section-number">4.2.1</span> —Step 1: Define
Siena Data &amp; Variables</h3>
<pre class="r test"><code># dependent variable
nets &lt;- sienaDependent(net_array)

# define data object
mydata_M1 &lt;- sienaDataCreate(nets)</code></pre>
<p>Print short descriptive report</p>
<pre class="r test"><code>ifelse(!dir.exists(&quot;results&quot;), dir.create(&quot;results&quot;), FALSE)</code></pre>
<pre class="test2"><code>#&gt; [1] FALSE</code></pre>
<pre class="r test"><code>print01Report(mydata_M1, modelname = &quot;./results/results_M1&quot;)  # create file with report in results folder </code></pre>
</div>
<div id="step-2-make-effects-objectstructure-1" class="section level3"
number="4.2.2">
<h3><span class="header-section-number">4.2.2</span> —Step 2: Make
effects object/structure</h3>
<pre class="r test"><code># define effects structure
myeff_M1 &lt;- getEffects(mydata_M1)</code></pre>
</div>
<div id="step-3-add-effects-1" class="section level3" number="4.2.3">
<h3><span class="header-section-number">4.2.3</span> —Step 3: Add
Effects</h3>
<pre class="r test"><code>myeff_M1 &lt;- includeEffects(myeff_M1, isolateNet, inPop, outAct)</code></pre>
<pre class="test2"><code>#&gt;   effectName            include fix   test  initialValue parm
#&gt; 1 indegree - popularity TRUE    FALSE FALSE          0   0   
#&gt; 2 outdegree - activity  TRUE    FALSE FALSE          0   0   
#&gt; 3 network-isolate       TRUE    FALSE FALSE          0   0</code></pre>
</div>
<div id="step-4-specify-modelalgorithm-1" class="section level3"
number="4.2.4">
<h3><span class="header-section-number">4.2.4</span> —Step 4: Specify
model/algorithm</h3>
<pre class="r test"><code>myAlgorithm_M1 &lt;- sienaAlgorithmCreate(projname = &quot;results_M1&quot;)</code></pre>
<pre class="test2"><code>#&gt; If you use this algorithm object, siena07 will create/use an output file results_M1.txt .</code></pre>
</div>
<div id="step-5-estimate-model-1" class="section level3" number="4.2.5">
<h3><span class="header-section-number">4.2.5</span> —Step 5: Estimate
model</h3>
<pre class="r test"><code># estimate the model
Model1 &lt;- siena07(myAlgorithm_M1, data = mydata_M1, effects = myeff_M1, returnDeps = TRUE)
Model1
# maximum convergence &gt;.25 run again:
Model1.1 &lt;- siena07(myAlgorithm_M1, data = mydata_M1, effects = myeff_M1, prevAns = Model1, returnDeps = TRUE)
Model1.1

# fsave(Model1, file =&#39;estimated_M1&#39;) fsave(Model1.1, file = &#39;estimated_M1.1&#39;)</code></pre>
<pre class="test2"><code>#&gt; Estimates, standard errors and convergence t-ratios
#&gt; 
#&gt;                                 Estimate   Standard   Convergence 
#&gt;                                              Error      t-ratio   
#&gt; 
#&gt; Rate parameters: 
#&gt;   0       Rate parameter         3.1828  ( 0.5998   )             
#&gt; 
#&gt; Other parameters: 
#&gt;   1. eval outdegree (density)   -2.1969  ( 0.6803   )    0.2455   
#&gt;   2. eval reciprocity            1.0939  ( 0.4500   )    0.0324   
#&gt;   3. eval indegree - popularity  0.2778  ( 0.0441   )    0.3761   
#&gt;   4. eval outdegree - activity  -0.0820  ( 0.1208   )    0.1302   
#&gt;   5. eval network-isolate        4.7886  ( 1.1409   )   -0.1993   
#&gt; 
#&gt; Overall maximum convergence ratio:    0.3834 
#&gt; 
#&gt; 
#&gt; Total of 2569 iteration steps.</code></pre>
<pre class="test2"><code>#&gt; Estimates, standard errors and convergence t-ratios
#&gt; 
#&gt;                                 Estimate   Standard   Convergence 
#&gt;                                              Error      t-ratio   
#&gt; 
#&gt; Rate parameters: 
#&gt;   0       Rate parameter         3.3690  ( 0.5713   )             
#&gt; 
#&gt; Other parameters: 
#&gt;   1. eval outdegree (density)   -2.1194  ( 0.7764   )    0.0455   
#&gt;   2. eval reciprocity            1.0930  ( 0.4241   )    0.0532   
#&gt;   3. eval indegree - popularity  0.2564  ( 0.0459   )   -0.0039   
#&gt;   4. eval outdegree - activity  -0.0863  ( 0.1370   )    0.0526   
#&gt;   5. eval network-isolate        4.9560  ( 1.4674   )    0.0066   
#&gt; 
#&gt; Overall maximum convergence ratio:    0.0710 
#&gt; 
#&gt; 
#&gt; Total of 2372 iteration steps.</code></pre>
</div>
<div id="step-6-gof---goodness-of-fit" class="section level3"
number="4.2.6">
<h3><span class="header-section-number">4.2.6</span> —Step 6: GOF -
Goodness of Fit</h3>
<pre class="r test"><code>GOF_M1.1 &lt;- sienaGOF(Model1.1, IndegreeDistribution, verbose = FALSE, join = TRUE, varName = &quot;nets&quot;)

plot(GOF_M1.1, main = &quot;GOF - Model 1 \n Indegree Distribution&quot;)</code></pre>
<p><img src="modelestimate_files/figure-html/GOF%20M1-1.png" width="672" /></p>
<hr />
</div>
</div>
<div id="model-2---gender" class="section level2" number="4.3">
<h2><span class="header-section-number">4.3</span> &lt;&gt; Model 2 -
Gender</h2>
<p>This model is partly similar to Model 1 but additionally holds the
network statistics sameX, diffXTransTrip, egoX &amp; altX of the
covariate gender. EgoX and AltX ought to indicate whether male or female
scholars are more likely to initiate or receive ties, while sameX models
the general tendency for scholars to collaborate with same-gender
peers.</p>
<p>The statistic for transitive triplets based on a different covariate
value (here: different gender) was originally included to control for
relationships of triadic nature (diffXTransTrip), but will be
disregarded in the interpretation of the results since a more
appropriate control statistic would have been that of transitive
triplets (TransTrip), but I simply lack the time to adjust the
models.</p>
<pre><code>Estimates, standard errors and convergence t-ratios                                                
                                            Estimate   Standard   Convergence
                                                        Error      t-ratio     
Rate parameters:    
0       Rate parameter                       2.9204  ( 0.4617   )               

Other parameters:    
1. eval outdegree (density)                 -1.8628  ( 1.1060   )    0.0703 --&gt; insign. (-1.684268)    
2. eval reciprocity                          1.3341  ( 0.4543   )   -0.0152 --&gt; sign.    (2.936606)***     
3. eval indegree - popularity                0.2209  ( 0.0470   )   -0.0083 --&gt; sign.    (4.7)     ***
4. eval outdegree - activity                -0.3017  ( 0.2287   )    0.0806 --&gt; insign. (-1.319195)    
5. eval network-isolate                      4.7507  ( 1.5194   )   -0.0379 --&gt; sign.    (3.126695)***     

6. eval gender_RS alter                      0.3254  ( 0.2701   )    0.0411 --&gt; insign.  (1.204739)      
7. eval gender_RS ego                       -1.0642  ( 0.6055   )   -0.0400 --&gt; insign. (-1.757556)     
8. eval same gender_RS                       0.6637  ( 0.2685   )    0.0308 --&gt; sign.    (2.471881)***     
9. eval transitive triplets diff. gender_RS  2.1787  ( 0.6027   )    0.0416 --&gt; sign.    (3.6149)  ***</code></pre>
<p>The maximum convergence ratio for model 2 is <strong>0.132</strong>
and the Goodness of Fit on the indegree distribution is
<strong>0.096</strong>.</p>
<p>Looking at our ‘base-line’ network statistics, it bears noting that
the estimate for Outdegree is not significant anymore. This statistic’s
prior significance can seemingly be explained by a parameter relating to
the covariate gender that I added to this model. However, the estimate
of the outdegree parameter is still nearing the significance ‘threshold’
(b = -1.8628, SE = 1.1060, b/SE = -1.684268).</p>
<p>Comparing this model to the prior ones, we see that the reciprocity
estimate is still significantly positive (b = 1.3341, SE = 0.4543).</p>
<p>The parameters of the structural network statistics also show similar
patterns in estimates and significance as they did in model 1.</p>
<p>Concerning the added covariate “gender”, we find that the parameter
estimates for both covariate-related activity (egoX) , pertaining to the
gender of the ego, and covariate-related popularity (altX), relating to
the gender of the alter, do <strong>not</strong> show any significance
and hence do not allow for reliable inferences.</p>
<p>The ‘same-covariate’ measure (sameX) for gender is significantly
positive (b = 0.6637, SE =0.2685). It reveals that scholars, indeed,
prefer same-gender collaborators. This supports H1, which posits gender
homophily in collaboration patterns.</p>
<p>Model 2 provides strong evidence for gender homophily (H1), with
scholars more likely to collaborate with same-gender peers, but no
significant differences in collaboration tendencies based on the gender
of ego or alter.</p>
<p>Hypothesis about structural effects</p>
<ul>
<li><p><strong>Network Statistics</strong>:</p>
<ul>
<li><p><strong>sameX (Gender)</strong>: Tests for gender homophily
directly.</p></li>
<li><p>Structural statistics like <strong>reciprocity</strong>,
<strong>inPop</strong>, <strong>outAct</strong>, and
<strong>isolateNet</strong> are control variables to account for
network-level dynamics.</p></li>
</ul></li>
<li><p><strong>Confirmation</strong>:</p>
<ul>
<li><p>A significant <code>sameX</code> coefficient, even after
including structural controls, would confirm that gender homophily
exists at the dyadic level.</p></li>
<li><p>If <code>sameX</code> becomes non-significant after controls, it
suggests structural factors, not individual preferences, explain gender
clustering.</p></li>
</ul></li>
</ul>
<p>–&gt; unsure if this hpold true for me, since I added gender only
after running a model that controls for structural effects so I cannot
really infer that but it’S too late to change that now.</p>
<div id="step-1-define-siena-data-variables-2" class="section level3"
number="4.3.1">
<h3><span class="header-section-number">4.3.1</span> —Step 1: Define
Siena Data &amp; Variables</h3>
<pre class="r test"><code># dependent variable
nets &lt;- sienaDependent(net_array)

# put gender in object
gender &lt;- df_ego$gender

# covariate 1
gender_RS &lt;- coCovar(gender)  # gender as covariate in Rsiena

# define data object
mydata_M2 &lt;- sienaDataCreate(nets, gender_RS)</code></pre>
<p>Print short descriptive report</p>
<pre class="r test"><code>ifelse(!dir.exists(&quot;results&quot;), dir.create(&quot;results&quot;), FALSE)</code></pre>
<pre class="test2"><code>#&gt; [1] FALSE</code></pre>
<pre class="r test"><code>print01Report(mydata_M2, modelname = &quot;./results/results_M2&quot;)  # create file with report in results folder </code></pre>
</div>
<div id="step-2-make-effects-objectstructure-2" class="section level3"
number="4.3.2">
<h3><span class="header-section-number">4.3.2</span> —Step 2: Make
effects object/structure</h3>
<pre class="r test"><code># define effects structure
myeff_M2 &lt;- getEffects(mydata_M2)</code></pre>
</div>
<div id="step-3-add-effects-2" class="section level3" number="4.3.3">
<h3><span class="header-section-number">4.3.3</span> —Step 3: Add
Effects</h3>
<pre class="r test"><code>myeff_M2 &lt;- includeEffects(myeff_M2, isolateNet, inPop, outAct)</code></pre>
<pre class="test2"><code>#&gt;   effectName            include fix   test  initialValue parm
#&gt; 1 indegree - popularity TRUE    FALSE FALSE          0   0   
#&gt; 2 outdegree - activity  TRUE    FALSE FALSE          0   0   
#&gt; 3 network-isolate       TRUE    FALSE FALSE          0   0</code></pre>
<pre class="r test"><code>myeff_M2 &lt;- includeEffects(myeff_M2, egoX, altX, diffXTransTrip, sameX, interaction1 = &quot;gender_RS&quot;)</code></pre>
<pre class="test2"><code>#&gt;   effectName                          include fix   test  initialValue parm
#&gt; 1 gender_RS alter                     TRUE    FALSE FALSE          0   0   
#&gt; 2 gender_RS ego                       TRUE    FALSE FALSE          0   0   
#&gt; 3 same gender_RS                      TRUE    FALSE FALSE          0   0   
#&gt; 4 transitive triplets diff. gender_RS TRUE    FALSE FALSE          0   0</code></pre>
<!--
# isolatenet: if individual is alone they "like to/tend to stay alone"
# inPop: ppl like to collaborate with people who are popular

# sameX
# same covariate, which can also be called covariate-related identity (sameX), defined by the number of ties of i to all other actors j who have exactly the same value on the covariate, s net i95(x) = P jxij I{vi = vj},
# where the indicator function I{vi = vj} is 1 if the condition {vi = vj} is satisfied, and 0 if it is not;


#diffXTransTrip
different covariate × transitive triplets (diffXTransTrip), defined by the number
of transitive triplets i → h → j ← i that have different covariate values for i and j,
diff. cov. values = diff gender

-->
</div>
<div id="step-4-specify-modelalgorithm-2" class="section level3"
number="4.3.4">
<h3><span class="header-section-number">4.3.4</span> —Step 4: Specify
model/algorithm</h3>
<pre class="r test"><code>myAlgorithm_M2 &lt;- sienaAlgorithmCreate(projname = &quot;results_M2&quot;)</code></pre>
<pre class="test2"><code>#&gt; If you use this algorithm object, siena07 will create/use an output file results_M2.txt .</code></pre>
</div>
<div id="step-5-estimate-model-2" class="section level3" number="4.3.5">
<h3><span class="header-section-number">4.3.5</span> —Step 5: Estimate
model</h3>
<pre class="r test"><code># estimate the model
Model2 &lt;- siena07(myAlgorithm_M2, data = mydata_M2, effects = myeff_M2, returnDeps = TRUE)
Model2
# maximum convergence &gt;.25 run again:
Model2.1 &lt;- siena07(myAlgorithm_M2, data = mydata_M2, effects = myeff_M2, prevAns = Model2, returnDeps = TRUE)
Model2.1

# fsave(Model2, file =&#39;estimated_M2&#39;) fsave(Model2.1, file = &#39;estimated_M2.1&#39;)</code></pre>
<pre class="test2"><code>#&gt; Estimates, standard errors and convergence t-ratios
#&gt; 
#&gt;                                 Estimate   Standard   Convergence 
#&gt;                                              Error      t-ratio   
#&gt; 
#&gt; Rate parameters: 
#&gt;   0       Rate parameter         3.1029  ( 0.5490   )             
#&gt; 
#&gt; Other parameters: 
#&gt;   1. eval outdegree (density)   -1.7742  ( 1.1441   )    0.0988   
#&gt;   2. eval reciprocity            1.4275  ( 0.4218   )   -0.0194   
#&gt;   3. eval indegree - popularity  0.2565  ( 0.0484   )    0.2281   
#&gt;   4. eval outdegree - activity  -0.2088  ( 0.2242   )    0.0696   
#&gt;   5. eval network-isolate        5.6769  ( 1.5077   )   -0.0236   
#&gt;   6. eval gender_RS alter        0.4139  ( 0.2485   )    0.1751   
#&gt;   7. eval gender_RS ego         -1.6507  ( 0.8049   )    0.1058   
#&gt;   8. eval same gender_RS         0.4483  ( 0.2370   )    0.0775   
#&gt; 
#&gt; Overall maximum convergence ratio:    0.2534 
#&gt; 
#&gt; 
#&gt; Total of 2704 iteration steps.</code></pre>
<pre class="test2"><code>#&gt; Estimates, standard errors and convergence t-ratios
#&gt; 
#&gt;                                 Estimate   Standard   Convergence 
#&gt;                                              Error      t-ratio   
#&gt; 
#&gt; Rate parameters: 
#&gt;   0       Rate parameter         3.1864  ( 0.5236   )             
#&gt; 
#&gt; Other parameters: 
#&gt;   1. eval outdegree (density)   -1.6312  ( 1.7196   )   0.0438    
#&gt;   2. eval reciprocity            1.4395  ( 0.4535   )   0.0647    
#&gt;   3. eval indegree - popularity  0.2441  ( 0.0525   )   0.0333    
#&gt;   4. eval outdegree - activity  -0.2295  ( 0.3252   )   0.0789    
#&gt;   5. eval network-isolate        5.8919  ( 2.6335   )   0.1210    
#&gt;   6. eval gender_RS alter        0.4354  ( 0.2526   )   0.0831    
#&gt;   7. eval gender_RS ego         -1.7360  ( 1.0777   )   0.0151    
#&gt;   8. eval same gender_RS         0.4464  ( 0.2389   )   0.0267    
#&gt; 
#&gt; Overall maximum convergence ratio:    0.1816 
#&gt; 
#&gt; 
#&gt; Total of 2753 iteration steps.</code></pre>
</div>
<div id="step-6-gof---goodness-of-fit-1" class="section level3"
number="4.3.6">
<h3><span class="header-section-number">4.3.6</span> —Step 6: GOF -
Goodness of Fit</h3>
<pre class="r test"><code>GOF_M2.1 &lt;- sienaGOF(Model2.1, IndegreeDistribution, verbose = FALSE, join = TRUE, varName = &quot;nets&quot;)

plot(GOF_M2.1, main = &quot;GOF - Model 2 \n Indegree Distribution&quot;)</code></pre>
<p><img src="modelestimate_files/figure-html/GOF%20M2-1.png" width="672" /></p>
<hr />
</div>
</div>
<div id="model-3---department" class="section level2" number="4.4">
<h2><span class="header-section-number">4.4</span> &lt;&gt; Model 3 -
Department</h2>
<p>This model is partly similar to Model 2 but additionally holds the
network statistics egoX and altX for the main effect of department, to
investigate differences in same-gender collaboration patterns based on
the two departments.</p>
<p>Originally, I planned to also include an interaction term of
departm_RS and gender_RS to obtain clearer insights into variations in
patterns of gender homophily in relation to scholars’ departments.
However, I have refrained from adding another model to this project. I
decided against this partly due to time constraints but I also reason
that I can use the comparison of model 2 and 3 to examine changes in the
estimate of ‘sameX’ (gender), to <em>tentatively</em> infer whether the
department of scholars modifies the collaboration patterns at hand.</p>
<p>Model 3 has a maximum convergence ratio of <strong>0.182</strong> and
a Goodness of Fit on the indegree distribution of
<strong>0.108</strong>.</p>
<p>Interestingly, the estimate for outdegree (density) that had lost its
significance in model 2, is now back to being significant and negative
(b = -4.3233, SE = 1.0871).</p>
<p>In terms of estimate size and significance of the structural network
statistics we, once again, find similar patterns as in models 1 and 2.
However, the outdegree parameter has now reached significance (b =
-4.3233, SE = 1.0871).</p>
<p>With regard to the network statistics of the covariate ‘gender’, we
find that the estimates relating to the gender of an ego (egoX) and the
gender of an alter (altX) remain non-significant. The parameter
estimates for sameX remains significantly positive (b = 0.6632, SE =
0.2623) and are almost identical to those of model 2 (b = 0.6632, SE =
0.2623). This suggests that adding the covariate ‘department’ did not
bring about any noteworthy changes in patterns of scholars seeking out
same-gendered scholars to collaborate.</p>
<p>When it comes to the parameters pertaining to the added covariate
‘department’, we find that any differences in collaboration based on the
department of an ego (egoX) or of an alter (altX) are not warranted, as
the estimates of these parameters are insignificant. However, we find a
significantly positive estimate for the parameter of ‘covariate-related
identity’ (sameX), which indicates that scholars are more likely to
collaborate with people from their own department, indicating
<strong>department-based homophily</strong>. (b = 2.7240, SE =
0.7277).</p>
<p>Model 3 highlights persistent gender homophily (H1) across
departments but does not provide evidence for differences in gender
homophily between Sociology and Political Science, contrary to H2.</p>
<hr />
<p>Estimates and SEs model 3:</p>
<p>1. eval: outdegree (density) -4.3233 ( 1.0871) ***</p>
<p>2. eval: reciprocity 1.0725 ( 0.4174) ***</p>
<p>3. eval: indegree - popularity 0.2122 ( 0.0517) ***</p>
<p>4. eval: outdegree - activity -0.3364 ( 0.2182) insign.
(-1.541705)</p>
<p>5. eval: network-isolate 4.2006 ( 1.3007) ***</p>
<p>6. eval: gender_RS alter 0.3356 ( 0.2659) insign (1.262129)</p>
<p>7. eval: gender_RS ego -1.0066 ( 0.5121) insign (-1.965632) almost
significant</p>
<p>8. eval: same gender_RS 0.6632 ( 0.2623) sign. (2.52840) ***<br />
(sameX: comparison model 2 and 3:<br />
estimate got hardly any smaller (0.6637–&gt;0.6632), SE got hardly any
smaller (0.2685–&gt;0.2623), significance value got bigger
(2.47881–&gt;2.52840))</p>
<p>9. eval: tr. tripl. diff. gend. 1.5479 ( 0.5403) sign. (2.86489)
***<br />
(diffxTrTrip comparison model 2 and 3:<br />
estimate got smaller and NEGATIVE (2.1787 –&gt;-1.5479), SE got smaller
(0.6027 –&gt; 0.5403), significance value got smaller
(3.6149–&gt;2.86489))</p>
<p>10. eval: departm_RS alter 0.4141 ( 0.7546) insign. (0.549)</p>
<p>11. eval: departm_RS ego -1.1573 ( 0.9148) insign (-1.27)</p>
<p>12. eval: same departm_RS 2.7240 ( 0.7277) ***</p>
<ul>
<li><p><strong>Network Statistics</strong>:</p>
<ul>
<li><strong>sameX (Gender)</strong>: Compute and compare the size and
significance of the coefficient for each department. This requires
separate models for each department or interaction terms that allow the
effect to vary by department.</li>
</ul></li>
<li><p><strong>Confirmation</strong>:</p>
<ul>
<li><p>A significantly stronger positive coefficient for
<code>sameX</code> in Political Science compared to Sociology would
confirm the hypothesis.</p></li>
<li><p>Similar coefficients or reversed patterns would disconfirm the
hypothesis.</p></li>
</ul></li>
</ul>
<p>altX - egos send more ties who have more on gender (aka. gender =1)
(iiiish look at egoX explanantion, this is basically the same but in
“reverse”, aka about receiving rather than sending)</p>
<ul>
<li>covariate-alter or covariate-related popularity (altX), defined by
the sum of the covariate over all actors to whom
<strong><em>i</em></strong> has a tie,</li>
<li>same as egoX but RECEIVING ties</li>
</ul>
<p>egoX - [definition?]</p>
<ul>
<li>covariate-ego or covariate-related activity (egoX), defined by i’s
out-degree weighted by his covariate value,</li>
<li>since male = 1 egoX only “looks at” men’s ties</li>
<li>if egoX significant then men’s ties sign. diff. based on whether its
to a man or woman (look at direction of effect to know which
gender)</li>
</ul>
<div id="step-1-define-siena-data-variables-3" class="section level3"
number="4.4.1">
<h3><span class="header-section-number">4.4.1</span> —Step 1: Define
Siena Data &amp; Variables</h3>
<pre class="r test"><code># dependent variable
nets &lt;- sienaDependent(net_array)

# put gender in object
gender &lt;- df_ego$gender

# covariate 1
gender_RS &lt;- coCovar(gender)  # gender as covariate in Rsiena

# put department in object
department &lt;- factor(df_ego$discipline.24, levels = c(&quot;sociology&quot;, &quot;political science&quot;))
# make numeric
department_numeric &lt;- as.numeric(department) - 1  # sociology = 0, political science = 1
# covariate 2
departm_RS &lt;- coCovar(department_numeric)

# define data object
mydata_M3 &lt;- sienaDataCreate(nets, gender_RS, departm_RS)</code></pre>
<p>Print short descriptive report</p>
<pre class="r test"><code>ifelse(!dir.exists(&quot;results&quot;), dir.create(&quot;results&quot;), FALSE)</code></pre>
<pre class="test2"><code>#&gt; [1] FALSE</code></pre>
<pre class="r test"><code>print01Report(mydata_M3, modelname = &quot;./results/results_M3&quot;)  # create file with report in results folder </code></pre>
</div>
<div id="step-2-make-effects-objectstructure-3" class="section level3"
number="4.4.2">
<h3><span class="header-section-number">4.4.2</span> —Step 2: Make
effects object/structure</h3>
<pre class="r test"><code># define effects structure
myeff_M3 &lt;- getEffects(mydata_M3)</code></pre>
</div>
<div id="step-3-add-effects-3" class="section level3" number="4.4.3">
<h3><span class="header-section-number">4.4.3</span> —Step 3: Add
Effects</h3>
<pre class="r test"><code>myeff_M3 &lt;- includeEffects(myeff_M3, isolateNet, inPop, outAct)  # model 1</code></pre>
<pre class="test2"><code>#&gt;   effectName            include fix   test  initialValue parm
#&gt; 1 indegree - popularity TRUE    FALSE FALSE          0   0   
#&gt; 2 outdegree - activity  TRUE    FALSE FALSE          0   0   
#&gt; 3 network-isolate       TRUE    FALSE FALSE          0   0</code></pre>
<pre class="r test"><code>myeff_M3 &lt;- includeEffects(myeff_M3, egoX, altX, diffXTransTrip, sameX, interaction1 = &quot;gender_RS&quot;)  #model 2</code></pre>
<pre class="test2"><code>#&gt;   effectName                          include fix   test  initialValue parm
#&gt; 1 gender_RS alter                     TRUE    FALSE FALSE          0   0   
#&gt; 2 gender_RS ego                       TRUE    FALSE FALSE          0   0   
#&gt; 3 same gender_RS                      TRUE    FALSE FALSE          0   0   
#&gt; 4 transitive triplets diff. gender_RS TRUE    FALSE FALSE          0   0</code></pre>
<pre class="r test"><code>myeff_M3 &lt;- includeEffects(myeff_M3, egoX, altX, sameX, interaction1 = &quot;departm_RS&quot;)  #model 3</code></pre>
<pre class="test2"><code>#&gt;   effectName       include fix   test  initialValue parm
#&gt; 1 departm_RS alter TRUE    FALSE FALSE          0   0   
#&gt; 2 departm_RS ego   TRUE    FALSE FALSE          0   0   
#&gt; 3 same departm_RS  TRUE    FALSE FALSE          0   0</code></pre>
<!--
# isolatenet: if individual is alone they "like to/tend to stay alone"
# inPop: ppl like to collaborate with people who are popular

# sameX
# same covariate, which can also be called covariate-related identity (sameX), defined by the number of ties of i to all other actors j who have exactly the same value on the covariate, s net i95(x) = P jxij I{vi = vj},
# where the indicator function I{vi = vj} is 1 if the condition {vi = vj} is satisfied, and 0 if it is not;


#diffXTransTrip
different covariate × transitive triplets (diffXTransTrip), defined by the number
of transitive triplets i → h → j ← i that have different covariate values for i and j,
diff. cov. values = diff gender

-->
</div>
<div id="step-4-specify-modelalgorithm-3" class="section level3"
number="4.4.4">
<h3><span class="header-section-number">4.4.4</span> —Step 4: Specify
model/algorithm</h3>
<pre class="r test"><code>myAlgorithm_M3 &lt;- sienaAlgorithmCreate(projname = &quot;results_M3&quot;)</code></pre>
<pre class="test2"><code>#&gt; If you use this algorithm object, siena07 will create/use an output file results_M3.txt .</code></pre>
</div>
<div id="step-5-estimate-model-3" class="section level3" number="4.4.5">
<h3><span class="header-section-number">4.4.5</span> —Step 5: Estimate
model</h3>
<pre class="r test"><code># estimate the model
Model3 &lt;- siena07(myAlgorithm_M3, data = mydata_M3, effects = myeff_M3, returnDeps = TRUE)
Model3

# if maximum convergence &gt;.25: run again
Model3.1 &lt;- siena07(myAlgorithm_M3, data = mydata_M3, effects = myeff_M3, prevAns = Model3, returnDeps = TRUE)
Model3.1

# fsave(Model3, file =&#39;estimated_M3&#39;) fsave(Model3.1, file = &#39;estimated_M3.1&#39;)</code></pre>
<pre class="test2"><code>#&gt; Estimates, standard errors and convergence t-ratios
#&gt; 
#&gt;                                                Estimate   Standard   Convergence 
#&gt;                                                             Error      t-ratio   
#&gt; 
#&gt; Rate parameters: 
#&gt;   0        Rate parameter                       3.0283  ( 0.4540   )             
#&gt; 
#&gt; Other parameters: 
#&gt;    1. eval outdegree (density)                 -4.5069  ( 1.0796   )    0.1107   
#&gt;    2. eval reciprocity                          1.0472  ( 0.4463   )   -0.0419   
#&gt;    3. eval indegree - popularity                0.2142  ( 0.0496   )    0.1107   
#&gt;    4. eval outdegree - activity                -0.3423  ( 0.1745   )    0.1165   
#&gt;    5. eval network-isolate                      4.1968  ( 1.0825   )    0.0149   
#&gt;    6. eval gender_RS alter                      0.3511  ( 0.2602   )    0.1186   
#&gt;    7. eval gender_RS ego                       -1.0285  ( 0.4820   )   -0.1188   
#&gt;    8. eval same gender_RS                       0.6650  ( 0.2666   )   -0.0002   
#&gt;    9. eval transitive triplets diff. gender_RS  1.5836  ( 0.5367   )    0.1694   
#&gt;   10. eval departm_RS alter                     0.5620  ( 0.6890   )   -0.0668   
#&gt;   11. eval departm_RS ego                      -1.3124  ( 0.8647   )   -0.0906   
#&gt;   12. eval same departm_RS                      2.9231  ( 0.7430   )    0.1732   
#&gt; 
#&gt; Overall maximum convergence ratio:    0.4454 
#&gt; 
#&gt; 
#&gt; Total of 2660 iteration steps.</code></pre>
<pre class="test2"><code>#&gt; Estimates, standard errors and convergence t-ratios
#&gt; 
#&gt;                                                Estimate   Standard   Convergence 
#&gt;                                                             Error      t-ratio   
#&gt; 
#&gt; Rate parameters: 
#&gt;   0        Rate parameter                       3.1013  ( 0.5186   )             
#&gt; 
#&gt; Other parameters: 
#&gt;    1. eval outdegree (density)                 -4.3233  ( 1.0871   )   -0.0034   
#&gt;    2. eval reciprocity                          1.0725  ( 0.4174   )    0.0126   
#&gt;    3. eval indegree - popularity                0.2122  ( 0.0517   )   -0.0042   
#&gt;    4. eval outdegree - activity                -0.3364  ( 0.2182   )    0.0027   
#&gt;    5. eval network-isolate                      4.2006  ( 1.3007   )    0.0526   
#&gt;    6. eval gender_RS alter                      0.3356  ( 0.2659   )   -0.0145   
#&gt;    7. eval gender_RS ego                       -1.0066  ( 0.5121   )    0.0453   
#&gt;    8. eval same gender_RS                       0.6632  ( 0.2623   )    0.0938   
#&gt;    9. eval transitive triplets diff. gender_RS  1.5479  ( 0.5403   )    0.0086   
#&gt;   10. eval departm_RS alter                     0.4141  ( 0.7546   )    0.0077   
#&gt;   11. eval departm_RS ego                      -1.1573  ( 0.9148   )    0.0144   
#&gt;   12. eval same departm_RS                      2.7240  ( 0.7277   )    0.0072   
#&gt; 
#&gt; Overall maximum convergence ratio:    0.1817 
#&gt; 
#&gt; 
#&gt; Total of 2859 iteration steps.</code></pre>
</div>
<div id="step-6-gof---goodness-of-fit-2" class="section level3"
number="4.4.6">
<h3><span class="header-section-number">4.4.6</span> —Step 6: GOF -
Goodness of Fit</h3>
<pre class="r test"><code>GOF_M3.1 &lt;- sienaGOF(Model3.1, IndegreeDistribution, verbose = FALSE, join = TRUE, varName = &quot;nets&quot;)

plot(GOF_M3.1, main = &quot;GOF - Model 3 \n Indegree Distribution&quot;)</code></pre>
<p><img src="modelestimate_files/figure-html/GOF%20M3-1.png" width="672" /></p>
<hr />
</div>
</div>
<div id="model-4---h-index" class="section level2" number="4.5">
<h2><span class="header-section-number">4.5</span> &lt;&gt; Model 4 -
H-Index</h2>
<p>This model further builds on the prior model and also includes
network statistics of the covariate H-Index, namely egoX, altX and
inPopX. By adding these effects we can model how the h-index of a
scholar influences their preferences regarding same-gendered
collaborations. Similarly, to model 3, this model could have profited
from a ‘follow-up’ model that includes and interaction term between
h-index and gender to better infer about their influences. The same
reasoning for my decision to stick with one model prior also applies to
this case. EgoX for this covariate examines how the h-index of a scholar
affects their collaboration behavior, while AltX examines how the
h-index of potential collaborators affects their attractiveness as
partners. With the help of these effects we can test prestigious
scholars are more likely to initiate or receive ties. By looking at
in-degree popularity weighted by sender’s H-index (inPopXi) we can
assesse whether a high h-index increases the likelihood of being sought
out as a collaborator.<br />
</p>
<pre><code>Estimates, standard errors and convergence t-ratios
                                               Estimate   Standard   Convergence
                                                          Error      t-ratio
Rate parameters:  
  0      Rate parameter                       2.6891  ( 0.3675   )               

Other parameters:     
   1. eval outdegree (density)                 -2.7693  ( 1.9205   )    0.0698 --&gt; insign. (-1.441968)       
   2. eval reciprocity                          2.1770  ( 0.5960   )    0.0919 --&gt; sign.    (3.652685)***      
   3. eval indegree - popularity               -0.0653  ( 0.1654   )   -0.0104 --&gt; insign. (-0.3948005)      
   4. eval outdegree - activity                -0.6851  ( 0.4029   )    0.0527 --&gt; insign. (-1.700422)      
   5. eval network-isolate                      5.4634  ( 2.2770   )    0.0028 --&gt; sign.    (2.399385)***      
   6. eval gender_RS alter                     -0.0903  ( 0.3372   )    0.0129 --&gt; insign. (-0.2677936)       
   7. eval gender_RS ego                        0.2993  ( 0.4934   )   -0.0503 --&gt; insign. (0.6066072)      
   8. eval same gender_RS                       0.6820  ( 0.2804   )    0.0201 --&gt; sign.   (2.43224)  ***       
   9. eval transitive triplets diff. gender_RS  2.4871  ( 0.6670   )    0.0505 --&gt; sign.   (3.728786) ***    
  10. eval departm_RS alter                     0.3929  ( 0.6128   )   -0.0061 --&gt; insign. (0.6411554)    
  11. eval departm_RS ego                      -1.4652  ( 0.6963   )   -0.0115 --&gt; SIGN.   (-2.104265)***
  12. eval same departm_RS                      2.6327  ( 0.6080   )    0.0173 --&gt; sign    (4.330099) ***    
  13. eval h_index_RS alter                     0.0829  ( 0.0364   )   -0.0031 --&gt; SIGN    (2.277473) ***
  14. eval h_index_RS ego                      -0.1591  ( 0.0744   )    0.0161 --&gt; SIGN.  (-2.138441) ***   
  15. eval ind. pop.^(1/1) weighted h_index_RS -0.0287  ( 0.0570   )   -0.0129 --&gt; insign.(-0.5035088)</code></pre>
<p>Model 4 has a maximum convergence ratio of <strong>0.23,</strong> and
a a Goodness of Fit on the indegree distribution of
<strong>0.197</strong>.</p>
<p>Structural network statistics:</p>
<p>The estimate for outdegree is negative but not significant. This
suggests that, after accounting for other variables, the baseline
likelihood of forming ties remains low and is not a major driver of
collaboration patterns. Reciprocity has a significant positive estimate
(b = 2.1770, SE = 0.5960). This reflects a strong tendency for mutual
collaborations, meaning if one scholar collaborates with another, the
latter is likely to collaborate back (dyadic reciprocity). The paramters
Indegree Popularity and Outdegree Activity are both insignificant,
suggesting that neither the tendency to receive many collaborations
(indegree popularity) nor the tendency to initiate them (outdegree
activity) is significantly relevant to the network structure. The
network isolate estimate is, once again, significantly positive ( b =
5.4634, SE = 2.2770), indicating that as isolates tend to remain
isolated.</p>
<p>Gender:</p>
<p>Similar to AltX and EgoX in prior models, both an alter’s gender (b =
-0.0903, SE = 0.3372) and an ego’s gender (b = 0.2993, SE = 0.4934)
still have insignificant effects. The parameter SameX shows a
significant positive estimate (b = 0.6820, SE = 0.2804) which barely
differs from the two prior models. This suggests that adding the
covariate ‘H-Index’ did not prompt any major changes in scholars’
preferences for same-gendered collaborators.</p>
<p>Department:</p>
<p>While an alter’s departmen<strong>t</strong> (AltX) remained
insignificant to the collaboration patterns, the estimates for an ego’s
department changed incomparison to the prior model. In this model, egoX
seems to be of significant relevance (b = -1.4652, SE = 0.6963), with
its negative estimate indicating that, once effects of h-index are
controlled for, scholars from the political science (coded as 1)
department have a lower tendency to initiate collaborations than
scholars from the sociology department (coded as 0).<br />
Similar to the prior model, the sameX parameter for department shows a
significant positive estimate (b = 2.6327, SE = 0.6080) scholars are
still more likely to collaborate with others from the same
department.</p>
<p>H-Index:</p>
<p>Both an alter’s and an ego’s H-Index seem to be relevant in
collaboration preferences. The significant and positive estimateof AltX
(b = 0.0829, SE = 0.0364) suggest that scholars with higher h-index are
more preferred as collaborators. The egoX estimate is significant and
negative (b = -0.1591, SE = 0.0744) suggesting that scholars with higher
h-index are less likely to initiate collaborations.</p>
<p><em>Discussion part about egoX h.index: <strong>“This is in line with
theories of preferential attachment and upward mobility, because as egos
with higher prestige will are more likely to receive request for
collaboration rather then sending request for collaboration.” -
Niels</strong></em></p>
<p>The estimate for the Indegree Popularity weighted by h-index is
insignificant, suggesting that high-prestige individuals (as measured by
their h-index) do not significantly receive more indegrees</p>
<p>The results partially support <strong>H4</strong>, as the h-index is
shown to influence collaboration patterns, with prestigious scholars
being more likely to attract collaborations as alters but less likely to
initiate them as egos. However, gender homophily remains significant
even after controlling for the h-index, suggesting that prestige does
not substantially weaken the influence of gender homophily in
co-authorship networks.</p>
<p>Transitive Triplets (Diff Gender): A positive significant effect
(b=2.4871, SE = 0.6670). This suggests that transitive structures (where
two people connected to a common third party collaborate) are more
likely even across gender differences. Could be a potential
counterbalance to homophily.</p>
<p>R-Manual: in-degree popularity weighted by sender’s V (inPopX)
defined by the sum of values of V for actors h for which there are ties
i → j ← h</p>
<p>note that to use this effect for p = 2 the variable V must be
nonnegative, which implies that it must be non-centered; further note
that if V is a behavioral variable, it will be used in the centered
version, so that p must be 1; if weighting by a non-centered behavioral
variable is desired, a new effect is necessary;</p>
<div id="step-1-define-siena-data-variables-4" class="section level3"
number="4.5.1">
<h3><span class="header-section-number">4.5.1</span> —Step 1: Define
Siena Data &amp; Variables</h3>
<pre class="r test"><code># dependent variable
nets &lt;- sienaDependent(net_array)

# put gender in object
gender &lt;- df_ego$gender
# covariate 1
gender_RS &lt;- coCovar(gender)  # gender as covariate in Rsiena

# put department in object
department &lt;- factor(df_ego$discipline.24, levels = c(&quot;sociology&quot;, &quot;political science&quot;))
# make numeric
department_numeric &lt;- as.numeric(department) - 1  # sociology = 0, political science = 1
# covariate 2
departm_RS &lt;- coCovar(department_numeric)

# put h-index in object
h_index &lt;- df_ego$h_index
df_ego$h_index</code></pre>
<pre class="test2"><code>#&gt;   [1]  5 26 12  9  4 10 27 23  5  9 10 12 11  8 42 11 11 51 25 22 23 11 26  4 11  6  3  3  3  2  3
#&gt;  [32]  2  2  2  1  4  3  2  3  1  1  2 17 15  2 37  2  2  4  9  1  0  1 17 16 13  0  2  0  1 12 18
#&gt;  [63]  6  1  1  6  8 10 12  8  1  1 15 12 10  1  3 13 11  6  6  0  2  7 16 12 29 12 15  6 13 18 21
#&gt;  [94]  1 10  3  2  7  0  5  8</code></pre>
<pre class="r test"><code># covariate 3
h_index_RS &lt;- coCovar(h_index)  # h_index as covariate in RSiena

# define data object
mydata_M4 &lt;- sienaDataCreate(nets, gender_RS, departm_RS, h_index_RS)</code></pre>
<p>Print short descriptive report</p>
<pre class="r test"><code>ifelse(!dir.exists(&quot;results&quot;), dir.create(&quot;results&quot;), FALSE)</code></pre>
<pre class="test2"><code>#&gt; [1] FALSE</code></pre>
<pre class="r test"><code>print01Report(mydata_M4, modelname = &quot;./results/results_M4&quot;)  # create file with report in results folder </code></pre>
</div>
<div id="step-2-make-effects-objectstructure-4" class="section level3"
number="4.5.2">
<h3><span class="header-section-number">4.5.2</span> —Step 2: Make
effects object/structure</h3>
<pre class="r test"><code># define effects structure
myeff_M4 &lt;- getEffects(mydata_M4)</code></pre>
</div>
<div id="step-3-add-effects-4" class="section level3" number="4.5.3">
<h3><span class="header-section-number">4.5.3</span> —Step 3: Add
Effects</h3>
<pre class="r test"><code>myeff_M4 &lt;- includeEffects(myeff_M4, isolateNet, inPop, outAct)  # model 1</code></pre>
<pre class="test2"><code>#&gt;   effectName            include fix   test  initialValue parm
#&gt; 1 indegree - popularity TRUE    FALSE FALSE          0   0   
#&gt; 2 outdegree - activity  TRUE    FALSE FALSE          0   0   
#&gt; 3 network-isolate       TRUE    FALSE FALSE          0   0</code></pre>
<pre class="r test"><code>myeff_M4 &lt;- includeEffects(myeff_M4, egoX, altX, diffXTransTrip, sameX, interaction1 = &quot;gender_RS&quot;)  #model 2</code></pre>
<pre class="test2"><code>#&gt;   effectName                          include fix   test  initialValue parm
#&gt; 1 gender_RS alter                     TRUE    FALSE FALSE          0   0   
#&gt; 2 gender_RS ego                       TRUE    FALSE FALSE          0   0   
#&gt; 3 same gender_RS                      TRUE    FALSE FALSE          0   0   
#&gt; 4 transitive triplets diff. gender_RS TRUE    FALSE FALSE          0   0</code></pre>
<pre class="r test"><code>myeff_M4 &lt;- includeEffects(myeff_M4, egoX, altX, sameX, interaction1 = &quot;departm_RS&quot;)  #model 3</code></pre>
<pre class="test2"><code>#&gt;   effectName       include fix   test  initialValue parm
#&gt; 1 departm_RS alter TRUE    FALSE FALSE          0   0   
#&gt; 2 departm_RS ego   TRUE    FALSE FALSE          0   0   
#&gt; 3 same departm_RS  TRUE    FALSE FALSE          0   0</code></pre>
<pre class="r test"><code>myeff_M4 &lt;- includeEffects(myeff_M4, egoX, altX, inPopX, interaction1 = &quot;h_index_RS&quot;)  # model 4</code></pre>
<pre class="test2"><code>#&gt;   effectName                          include fix   test  initialValue parm
#&gt; 1 h_index_RS alter                    TRUE    FALSE FALSE          0   0   
#&gt; 2 h_index_RS ego                      TRUE    FALSE FALSE          0   0   
#&gt; 3 ind. pop.^(1/#) weighted h_index_RS TRUE    FALSE FALSE          0   1</code></pre>
<!--
# isolatenet: if individual is alone they "like to/tend to stay alone"
# inPop: ppl like to collab with people who are popular

# sameX
# same covariate, which can also be called covariate-related identity (sameX), defined by the number of ties of i to all other actors j who have exactly the same value on the covariate, s net i95(x) = P jxij I{vi = vj},
# where the indicator function I{vi = vj} is 1 if the condition {vi = vj} is satisfied, and 0 if it is not;

# look up inPopX: preferential attachment (cf. Koen lel), higher h-index more popular 
  # cf. Fridas modeling process (Jochem told her that )

-->
</div>
<div id="step-4-specify-modelalgorithm-4" class="section level3"
number="4.5.4">
<h3><span class="header-section-number">4.5.4</span> —Step 4: Specify
model/algorithm</h3>
<pre class="r test"><code>myAlgorithm_M4 &lt;- sienaAlgorithmCreate(projname = &quot;results_M4&quot;)</code></pre>
<pre class="test2"><code>#&gt; If you use this algorithm object, siena07 will create/use an output file results_M4.txt .</code></pre>
</div>
<div id="step-5-estimate-model-4" class="section level3" number="4.5.5">
<h3><span class="header-section-number">4.5.5</span> —Step 5: Estimate
model</h3>
<pre class="r test"><code># estimate the model
Model4 &lt;- siena07(myAlgorithm_M4, data = mydata_M4, effects = myeff_M4, returnDeps = TRUE)
Model4

# fsave(Model4, file =&#39;estimated_M4&#39;)</code></pre>
<pre class="test2"><code>#&gt; Estimates, standard errors and convergence t-ratios
#&gt; 
#&gt;                                               Estimate   Standard   Convergence 
#&gt;                                                            Error      t-ratio   
#&gt; 
#&gt; Rate parameters: 
#&gt;   0       Rate parameter                       2.1021  ( 0.3399   )             
#&gt; 
#&gt; Other parameters: 
#&gt;   1. eval outdegree (density)                 -3.3787  ( 0.2606   )   -0.0783   
#&gt;   2. eval reciprocity                          3.0814  ( 0.5381   )   -0.1007   
#&gt;   3. eval h_index_RS alter                     0.0644  ( 0.0092   )   -0.0444   
#&gt;   4. eval h_index_RS ego                      -0.0903  ( 0.0506   )   -0.0432   
#&gt;   5. eval ind. pop.^(1/1) weighted h_index_RS  0.0139  ( 0.0637   )   -0.1012   
#&gt; 
#&gt; Overall maximum convergence ratio:    0.1610 
#&gt; 
#&gt; 
#&gt; Total of 2277 iteration steps.</code></pre>
</div>
<div id="step-6-gof---goodness-of-fit-3" class="section level3"
number="4.5.6">
<h3><span class="header-section-number">4.5.6</span> —Step 6: GOF -
Goodness of Fit</h3>
<pre class="r test"><code>GOF_M4 &lt;- sienaGOF(Model4, IndegreeDistribution, verbose = FALSE, join = TRUE, varName = &quot;nets&quot;)

plot(GOF_M4, main = &quot;GOF - Model 4 \n Indegree Distribution&quot;)</code></pre>
<p><img src="modelestimate_files/figure-html/GOF%20M4-1.png" width="672" /></p>
</div>
</div>
</div>

<div id="rmd-source-code">LS0tDQp0aXRsZTogIk1vZGVsIGVzdGltYXRpb24iDQphdXRob3I6ICJWZXJvb28iDQpkYXRlOiAiMjAyNC0xMS0yMCINCm91dHB1dDogaHRtbF9kb2N1bWVudA0KYmlibGlvZ3JhcGh5OiByZWZlcmVuY2VzLmJpYg0KY3NsOiBhcGEuY3NsDQplZGl0b3Jfb3B0aW9uczogDQogIG1hcmtkb3duOiANCiAgICB3cmFwOiA3Mg0KLS0tDQoNCjxodG1sIGxhbmc9ImVuIj4NCg0KPGhlYWQ+DQoNCjxtZXRhIGNoYXJzZXQ9IlVURi04Ij4NCg0KPG1ldGEgbmFtZT0idmlld3BvcnQiIGNvbnRlbnQ9IndpZHRoPWRldmljZS13aWR0aCwgaW5pdGlhbC1zY2FsZT0xLjAiPg0KDQo8dGl0bGU+TXkgRGVzY3JpcHRpdmVzPC90aXRsZT4NCg0KPGxpbmsgcmVsPSJzdHlsZXNoZWV0IiBocmVmPSJzdHlsZXMuY3NzIj4NCjwhLS0gTGluayB0byB0aGUgQ1NTIGZpbGUgSSBjcmVhdGVkIGZvciBkYXJrIG1vZGUgY29kZSBjaHVua3MgLS0+DQoNCjwvaGVhZD4NCg0KPC9odG1sPg0KDQpgYGB7ciBzZXR1cCwgaW5jbHVkZT1GQUxTRX0NCmtuaXRyOjpvcHRzX2NodW5rJHNldChlY2hvID0gVFJVRSkNCmBgYA0KDQpgYGB7ciwgZ2xvYmFsc2V0dGluZ3MsIGVjaG89RkFMU0UsIHdhcm5pbmc9RkFMU0UsIHJlc3VsdHM9J2hpZGUnfQ0KbGlicmFyeShrbml0cikNCg0Ka25pdHI6Om9wdHNfY2h1bmskc2V0KGVjaG8gPSBUUlVFKQ0Kb3B0c19jaHVuayRzZXQodGlkeS5vcHRzPWxpc3Qod2lkdGguY3V0b2ZmPTEwMCksdGlkeT1UUlVFLCB3YXJuaW5nID0gRkFMU0UsIG1lc3NhZ2UgPSBGQUxTRSxjb21tZW50ID0gIiM+IiwgY2FjaGU9VFJVRSwgY2xhc3Muc291cmNlPWMoInRlc3QiKSwgY2xhc3Mub3V0cHV0PWMoInRlc3QyIikpDQpvcHRpb25zKHdpZHRoID0gMTAwKQ0KcmdsOjpzZXR1cEtuaXRyKCkNCg0KY29sb3JpemUgPC0gZnVuY3Rpb24oeCwgY29sb3IpIHtzcHJpbnRmKCI8c3BhbiBzdHlsZT0nY29sb3I6ICVzOyc+JXM8L3NwYW4+IiwgY29sb3IsIHgpIH0NCg0KYGBgDQoNCmBgYHtyIGtsaXBweSwgZWNobz1GQUxTRSwgaW5jbHVkZT1UUlVFfQ0Ka2xpcHB5OjprbGlwcHkocG9zaXRpb24gPSBjKCd0b3AnLCAncmlnaHQnKSkNCiNrbGlwcHk6OmtsaXBweShjb2xvciA9ICdkYXJrcmVkJykNCiNrbGlwcHk6OmtsaXBweSh0b29sdGlwX21lc3NhZ2UgPSAnQ2xpY2sgdG8gY29weScsIHRvb2x0aXBfc3VjY2VzcyA9ICdEb25lJykNCmBgYA0KDQpOb3RlIHRvIHNlbGYuIEtlZXAgaW4gbWluZDogXA0KKiptZWFuaW5nIG9mIHNpZ25pZmljYW5jZSBpbiBSU2llbmEqKiAiSXQgaXMgaW1wb3J0YW50IHRvIG1lbnRpb24gdGhhdA0Kc2lnbmlmaWNhbmNlIGluIFJTaWVuYSBtZWFucyBzb21ldGhpbmcgZGlmZmVyZW50IHRoYW4gaW4gY29udmVudGlvbmFsDQpzdGF0aXN0aWNzLiBJbiBub3JtYWwgc3RhdGlzdGljcywgc3VjaCBhcyBPTFMtcmVncmVzc2lvbiwgc2lnbmlmaWNhbmNlDQpvZiBlc3RpbWF0ZXMgcmVmZXJzIHRvIHRoZSBmYWN0IHRoYXQgdGhleSBhcmUgbm90IDAgKCoqUkVMRVZBTlQ/KiopLiBJbg0KUlNpZW5hLCBob3dldmVyLCBpdCByZWZlcnMgdG8gdGhlIGZhY3QgdGhhdCB0aGUgZXN0aW1hdGVzIHdlcmUgcHJlY2lzZWx5DQpkZXRlcm1pbmVkIChSaXBsZXkgZXQgYWwuIDIwMTEpLiBHb2luZyBmb3J3YXJkIHdpdGggdGhpcyBjaGFwdGVyLA0Kc2lnbmlmaWNhbmNlIHdpbGwgcmVmZXIgdG8gdGhpcyBkZWZpbml0aW9uIG9mIHNpZ25pZmljYW5jZS4iIC0gTmllbHMNClZ1bGxpbmdzDQoNCiMgU2V0dXANCg0KQ2xlYW4gd29ya3NwYWNlLiBBcyBhbHdheXMuDQoNCmBgYHtyIGNsZWFufQ0Kcm0obGlzdCA9IGxzKCkpDQpgYGANCg0KIyMgUGFja2FnZXMNCg0KYGBge3IgcGFja2FnZSwgaW5jbHVkZT1UUlVFLCBoaWRlPVRSVUUsIGV2YWw9VFJVRX0NCnJlcXVpcmUodGlkeXZlcnNlKQ0KcmVxdWlyZShSU2llbmEpDQpyZXF1aXJlKFJzaWVuYVR3b1N0ZXApDQoNCiNpbnN0YWxsLnBhY2thZ2VzKCJkYXRhLnRhYmxlIikNCnJlcXVpcmUoZGF0YS50YWJsZSkgICMgbWFpbmx5IGZvciBmYXN0ZXIgZGF0YSBoYW5kbGluZw0KIyBpbnN0YWxsLnBhY2thZ2VzKCd4bWwyJykNCnJlcXVpcmUoeG1sMikNCiMgaW5zdGFsbC5wYWNrYWdlcygncnZlc3QnKQ0KcmVxdWlyZShydmVzdCkNCnJlcXVpcmUoaWdyYXBoKQ0KcmVxdWlyZShnZ3JhcGgpDQoNCg0KI2luc3RhbGwucGFja2FnZXMoJ3Zpc05ldHdvcmsnKQ0KcmVxdWlyZSh2aXNOZXR3b3JrKQ0KI2luc3RhbGwucGFja2FnZXMoJ3RocmVlanMnKQ0KcmVxdWlyZSh0aHJlZWpzKQ0KI2luc3RhbGwucGFja2FnZXMoJ25ldHdvcmtEMycpDQpyZXF1aXJlKG5ldHdvcmtEMykNCg0KDQpgYGANCg0KIyMgRnVuY3Rpb25zDQoNCkZ1bmN0aW9ucyBjaHVuazoNCg0KYGBge3IgZnVuY3Rpb25zIDEsIGhpZGU9VFJVRX0NCmZwYWNrYWdlLmNoZWNrIDwtIGZ1bmN0aW9uKHBhY2thZ2VzKSB7DQogICAgbGFwcGx5KHBhY2thZ2VzLCBGVU4gPSBmdW5jdGlvbih4KSB7DQogICAgICAgIGlmICghcmVxdWlyZSh4LCBjaGFyYWN0ZXIub25seSA9IFRSVUUpKSB7DQogICAgICAgICAgICBpbnN0YWxsLnBhY2thZ2VzKHgsIGRlcGVuZGVuY2llcyA9IFRSVUUpDQogICAgICAgICAgICBsaWJyYXJ5KHgsIGNoYXJhY3Rlci5vbmx5ID0gVFJVRSkNCiAgICAgICAgfQ0KICAgIH0pDQp9DQoNCmZzYXZlIDwtIGZ1bmN0aW9uKHgsIGZpbGUgPSBOVUxMLCBsb2NhdGlvbiA9ICIuL2RhdGEvcHJvY2Vzc2VkLyIpIHsNCiAgICBpZmVsc2UoIWRpci5leGlzdHMoImRhdGEiKSwgZGlyLmNyZWF0ZSgiZGF0YSIpLCBGQUxTRSkNCiAgICBpZmVsc2UoIWRpci5leGlzdHMoImRhdGEvcHJvY2Vzc2VkIiksIGRpci5jcmVhdGUoImRhdGEvcHJvY2Vzc2VkIiksIEZBTFNFKQ0KICAgIGlmIChpcy5udWxsKGZpbGUpKQ0KICAgICAgICBmaWxlID0gZGVwYXJzZShzdWJzdGl0dXRlKHgpKQ0KICAgIGRhdGVuYW1lIDwtIHN1YnN0cihnc3ViKCJbOi1dIiwgIiIsIFN5cy50aW1lKCkpLCAxLCA4KQ0KICAgIHRvdGFsbmFtZSA8LSBwYXN0ZShsb2NhdGlvbiwgZmlsZSwgIl8iLCBkYXRlbmFtZSwgIi5yZGEiLCBzZXAgPSAiIikNCiAgICBzYXZlKHgsIGZpbGUgPSB0b3RhbG5hbWUpICAjbmVlZCB0byBmaXggaWYgZmlsZSBpcyByZWxvYWRlZCBhcyBpbnB1dCBuYW1lLCBub3QgYXMgeC4gDQp9DQoNCmZsb2FkIDwtIGZ1bmN0aW9uKGZpbGVuYW1lKSB7DQogICAgbG9hZChmaWxlbmFtZSkNCiAgICBnZXQobHMoKVtscygpICE9ICJmaWxlbmFtZSJdKQ0KfQ0KDQpmc2hvd2RmIDwtIGZ1bmN0aW9uKHgsIC4uLikgew0KICAgIGtuaXRyOjprYWJsZSh4LCBkaWdpdHMgPSAyLCAiaHRtbCIsIC4uLikgJT4lDQogICAgICAgIGthYmxlRXh0cmE6OmthYmxlX3N0eWxpbmcoYm9vdHN0cmFwX29wdGlvbnMgPSBjKCJzdHJpcGVkIiwgImhvdmVyIikpICU+JQ0KICAgICAgICBrYWJsZUV4dHJhOjpzY3JvbGxfYm94KHdpZHRoID0gIjEwMCUiLCBoZWlnaHQgPSAiMzAwcHgiKQ0KfQ0KDQoNCiMgdGhpcyBpcyB0aGUgbW9zdCBpbXBvcnRhbnQgb25lLiBXZSBjcmVhdGVkIGl0IGluIHRoZSBwcmV2aW91cyBzY3JpcHQNCg0KZl9wdWJuZXRzIDwtIGZ1bmN0aW9uKGRmX3NjaG9sYXJzID0gZGYsIGxpc3RfcHVibGljYXRpb25zID0gcHVibGljYXRpb25zLCBkaXNjaXAgPSAic29jaW9sb2d5IisicG9saXRpY2FsIHNjaWVuY2UiLCBhZmZpbGlhdGlvbiA9ICJSVSIsDQogICAgd2F2ZXMgPSBsaXN0KHdhdmUxID0gYygyMDE4LCAyMDE5LCAyMDIwKSwgd2F2ZTIgPSBjKDIwMjEsIDIwMjIsIDIwMjMpKSkgew0KDQogICAgcHVibGljYXRpb25zIDwtIGxpc3RfcHVibGljYXRpb25zICU+JQ0KICAgICAgICBiaW5kX3Jvd3MoKSAlPiUNCiAgICAgICAgZGlzdGluY3QodGl0bGUsIC5rZWVwX2FsbCA9IFRSVUUpDQoNCiAgICBkZl9zY2hvbGFycyAlPiUNCiAgICAgICAgZmlsdGVyKGFmZmlsMSA9PSBhZmZpbGlhdGlvbiB8IGFmZmlsMiA9PSBhZmZpbGlhdGlvbikgJT4lDQogICAgICAgIGZpbHRlcihkaXNjaXBsaW5lID09IGRpc2NpcCkgLT4gZGZfc2VsDQoNCiAgICBuZXR3b3JrbGlzdCA8LSBsaXN0KCkNCiAgICBmb3IgKHdhdmUgaW4gMTpsZW5ndGgod2F2ZXMpKSB7DQogICAgICAgIG5ldHdvcmtsaXN0W1t3YXZlXV0gPC0gbWF0cml4KDAsIG5yb3cgPSBucm93KGRmX3NlbCksIG5jb2wgPSBucm93KGRmX3NlbCkpDQogICAgfQ0KDQogICAgcHVibGljYXRpb25saXN0IDwtIGxpc3QoKQ0KICAgIGZvciAod2F2ZSBpbiAxOmxlbmd0aCh3YXZlcykpIHsNCiAgICAgICAgcHVibGljYXRpb25saXN0W1t3YXZlXV0gPC0gcHVibGljYXRpb25zICU+JQ0KICAgICAgICAgICAgZmlsdGVyKGdzX2lkICVpbiUgZGZfc2VsJGdzX2lkKSAlPiUNCiAgICAgICAgICAgIGZpbHRlcih5ZWFyICVpbiUgd2F2ZXNbW3dhdmVdXSkgJT4lDQogICAgICAgICAgICBzZWxlY3QoYXV0aG9yKSAlPiUNCiAgICAgICAgICAgIGxhcHBseShzdHJfc3BsaXQsIHBhdHRlcm4gPSAiLCIpDQogICAgfQ0KDQogICAgcHVibGljYXRpb25saXN0MiA8LSBsaXN0KCkNCiAgICBmb3IgKHdhdmUgaW4gMTpsZW5ndGgod2F2ZXMpKSB7DQogICAgICAgIHB1YmxpY2F0aW9ubGlzdDJbW3dhdmVdXSA8LSBwdWJsaWNhdGlvbmxpc3RbW3dhdmVdXSRhdXRob3IgJT4lDQogICAgICAgICAgICAjIGxvd2VyY2FzZQ0KICAgICAgICBsYXBwbHkodG9sb3dlcikgJT4lDQogICAgICAgICAgICAjIFJlbW92aW5nIGRpYWNyaXRpY3MNCiAgICAgICAgbGFwcGx5KHN0cmlfdHJhbnNfZ2VuZXJhbCwgaWQgPSAibGF0aW4tYXNjaWkiKSAlPiUNCiAgICAgICAgICAgICMgb25seSBsYXN0IG5hbWUNCiAgICAgICAgbGFwcGx5KHdvcmQsIHN0YXJ0ID0gLTEsIHNlcCA9ICIgIikgJT4lDQogICAgICAgICAgICAjIG9ubHkgbGFzdCBsYXN0IG5hbWUNCiAgICAgICAgbGFwcGx5KHdvcmQsIHN0YXJ0ID0gLTEsIHNlcCA9ICItIikNCiAgICB9DQoNCiAgICBmb3IgKHdhdmUgaW4gMTpsZW5ndGgod2F2ZXMpKSB7DQogICAgICAgICMgbGV0IHVzIHJlbW92ZSBhbGwgcHVibGljYXRpb25zIHdpdGggb25seSBvbmUgYXV0aG9yDQogICAgICAgIHJlbW92ZSA8LSB3aGljaChzYXBwbHkocHVibGljYXRpb25saXN0Mltbd2F2ZV1dLCBGVU4gPSBmdW5jdGlvbih4KSBsZW5ndGgoeCkgPT0gMSkgPT0gVFJVRSkNCiAgICAgICAgcHVibGljYXRpb25saXN0Mltbd2F2ZV1dIDwtIHB1YmxpY2F0aW9ubGlzdDJbW3dhdmVdXVstcmVtb3ZlXQ0KICAgIH0NCg0KICAgIGZvciAod2F2ZSBpbiAxOmxlbmd0aCh3YXZlcykpIHsNCiAgICAgICAgcHVicyA8LSBwdWJsaWNhdGlvbmxpc3QyW1t3YXZlXV0NCiAgICAgICAgZm9yIChlZ28gaW4gMTpucm93KGRmX3NlbCkpIHsNCiAgICAgICAgICAgICMgd2hpY2ggZWdvPw0KICAgICAgICAgICAgbGFzdG5hbWVfZWdvIDwtIGRmX3NlbCRsYXN0bmFtZVtlZ29dDQogICAgICAgICAgICAjIGZvciBhbGwgcHVibGljYXRpb25zDQogICAgICAgICAgICBmb3IgKHB1YiBpbiAxOmxlbmd0aChwdWJzKSkgew0KICAgICAgICAgICAgICAgICMgb25seSBjb250aW51ZSBpZiBlZ28gaXMgYXV0aG9yIG9mIHB1Yg0KICAgICAgICAgICAgICAgIGlmIChsYXN0bmFtZV9lZ28gJWluJSBwdWJzW1twdWJdXSkgew0KICAgICAgICAgICAgICAgICAgYXV0X3BvdCA8LSB3aGljaC5tYXgocHVic1tbcHViXV0gJWluJSBsYXN0bmFtZV9lZ28pDQogICAgICAgICAgICAgICAgICAjIG9ubHkgY29udGludWUgaWYgZWdvIGlzIGZpcnN0IGF1dGhvciBvZiBwdWINCiAgICAgICAgICAgICAgICAgIGlmIChhdXRfcG90ID09IDEpIHsNCiAgICAgICAgICAgICAgICAgICAgIyBjaGVjayBhbGwgYWx0ZXJzL2NvLWF1dGhvcnMNCiAgICAgICAgICAgICAgICAgICAgZm9yIChhbHRlciBpbiAxOm5yb3coZGZfc2VsKSkgew0KICAgICAgICAgICAgICAgICAgICAgICMgd2hpY2ggYWx0ZXINCiAgICAgICAgICAgICAgICAgICAgICBsYXN0bmFtZV9hbHRlciA8LSBkZl9zZWwkbGFzdG5hbWVbYWx0ZXJdDQogICAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RuYW1lX2FsdGVyICVpbiUgcHVic1tbcHViXV0pIHsNCiAgICAgICAgICAgICAgICAgICAgICAgIG5ldHdvcmtsaXN0W1t3YXZlXV1bZWdvLCBhbHRlcl0gPC0gbmV0d29ya2xpc3RbW3dhdmVdXVtlZ28sIGFsdGVyXSArIDENCiAgICAgICAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICB9DQogICAgICAgIH0NCiAgICB9DQogICAgcmV0dXJuKGxpc3QoZGYgPSBkZl9zZWwsIG5ldHdvcmsgPSBuZXR3b3JrbGlzdCkpDQp9DQoNCmBgYA0KDQpNb3JlIGZ1bmN0aW9uczoNCg0KYGBge3IgZnVuY3Rpb25zIDIsIGhpZGU9IFRSVUV9DQpmY29sbmV0IDwtIGZ1bmN0aW9uKGRhdGEgPSBzY2hvbGFycywgdW5pdmVyc2l0eSA9ICJSVSIsIGRpc2NpcGxpbmUgPSAic29jaW9sb2d5IisicG9saXRpY2FsIHNjaWVuY2UiLCB3YXZlcyA9IGxpc3QoYygyMDE1LA0KICAgIDIwMTgpLCBjKDIwMTksIDIwMjMpKSwgdHlwZSA9IGMoImZpcnN0IikpIHsNCg0KICAgICMgc3RlcCAxDQogICAgZGVtb2dyYXBoaWNzIDwtIGRvLmNhbGwocmJpbmQuZGF0YS5mcmFtZSwgZGF0YSRkZW1vZ3JhcGhpY3MpDQogICAgZGVtb2dyYXBoaWNzIDwtIGRlbW9ncmFwaGljcyAlPiUNCiAgICAgICAgbXV0YXRlKFVuaXZlcnNpdGVpdDEuMjIgPSByZXBsYWNlKFVuaXZlcnNpdGVpdDEuMjIsIGlzLm5hKFVuaXZlcnNpdGVpdDEuMjIpLCAiIiksIFVuaXZlcnNpdGVpdDIuMjIgPSByZXBsYWNlKFVuaXZlcnNpdGVpdDIuMjIsDQogICAgICAgICAgICBpcy5uYShVbml2ZXJzaXRlaXQyLjIyKSwgIiIpLCBVbml2ZXJzaXRlaXQxLjI0ID0gcmVwbGFjZShVbml2ZXJzaXRlaXQxLjI0LCBpcy5uYShVbml2ZXJzaXRlaXQxLjI0KSwNCiAgICAgICAgICAgICIiKSwgVW5pdmVyc2l0ZWl0Mi4yNCA9IHJlcGxhY2UoVW5pdmVyc2l0ZWl0Mi4yNCwgaXMubmEoVW5pdmVyc2l0ZWl0Mi4yNCksICIiKSwgZGlzY2lwbGluZS4yMiA9IHJlcGxhY2UoZGlzY2lwbGluZS4yMiwNCiAgICAgICAgICAgIGlzLm5hKGRpc2NpcGxpbmUuMjIpLCAiIiksIGRpc2NpcGxpbmUuMjQgPSByZXBsYWNlKGRpc2NpcGxpbmUuMjQsIGlzLm5hKGRpc2NpcGxpbmUuMjQpLCAiIikpDQoNCiAgICBzYW1wbGUgPC0gd2hpY2goKGRlbW9ncmFwaGljcyRVbml2ZXJzaXRlaXQxLjIyICVpbiUgdW5pdmVyc2l0eSB8IGRlbW9ncmFwaGljcyRVbml2ZXJzaXRlaXQyLjIyICVpbiUNCiAgICAgICAgdW5pdmVyc2l0eSB8IGRlbW9ncmFwaGljcyRVbml2ZXJzaXRlaXQxLjI0ICVpbiUgdW5pdmVyc2l0eSB8IGRlbW9ncmFwaGljcyRVbml2ZXJzaXRlaXQyLjI0ICVpbiUNCiAgICAgICAgdW5pdmVyc2l0eSkgJiAoZGVtb2dyYXBoaWNzJGRpc2NpcGxpbmUuMjIgJWluJSBkaXNjaXBsaW5lIHwgZGVtb2dyYXBoaWNzJGRpc2NpcGxpbmUuMjQgJWluJSBkaXNjaXBsaW5lKSkNCg0KICAgIGRlbW9ncmFwaGljc19zb2MgPC0gZGVtb2dyYXBoaWNzW3NhbXBsZSwgXQ0KICAgIHNjaG9sYXJzX3NlbCA8LSBsYXBwbHkoc2Nob2xhcnMsICJbIiwgc2FtcGxlKQ0KDQogICAgIyBzdGVwIDINCiAgICBpZHMgPC0gZGVtb2dyYXBoaWNzX3NvYyRhdV9pZA0KICAgIG53YXZlcyA8LSBsZW5ndGgod2F2ZXMpDQogICAgbmV0cyA8LSBhcnJheSgwLCBkaW0gPSBjKG53YXZlcywgbGVuZ3RoKGlkcyksIGxlbmd0aChpZHMpKSwgZGltbmFtZXMgPSBsaXN0KHdhdmUgPSAxOm53YXZlcywgaWRzLA0KICAgICAgICBpZHMpKQ0KICAgIGRpbW5hbWVzKG5ldHMpDQoNCiAgICAjIHN0ZXAgMw0KICAgIGRmX3dvcmtzIDwtIHRpYmJsZSh3b3Jrc19pZCA9IHVubGlzdChsYXBwbHkoc2Nob2xhcnNfc2VsJHdvcmssIGZ1bmN0aW9uKGwpIGwkaWQpKSwgd29ya3NfYXV0aG9yID0gdW5saXN0KGxhcHBseShzY2hvbGFyc19zZWwkd29yaywNCiAgICAgICAgZnVuY3Rpb24obCkgbCRhdXRob3IpLCByZWN1cnNpdmUgPSBGQUxTRSksIHdvcmtzX3llYXIgPSB1bmxpc3QobGFwcGx5KHNjaG9sYXJzX3NlbCR3b3JrLCBmdW5jdGlvbihsKSBsJHB1YmxpY2F0aW9uX3llYXIpLA0KICAgICAgICByZWN1cnNpdmUgPSBGQUxTRSkpDQoNCiAgICBkZl93b3JrcyA8LSBkZl93b3Jrc1shZHVwbGljYXRlZChkZl93b3JrcyksIF0NCg0KICAgICMgc3RlcCA0DQogICAgaWYgKHR5cGUgPT0gImZpcnN0Iikgew0KICAgICAgICBmb3IgKGogaW4gMTpud2F2ZXMpIHsNCiAgICAgICAgICAgIGRmX3dvcmtzX3cgPC0gZGZfd29ya3NbZGZfd29ya3Mkd29ya3NfeWVhciA+PSB3YXZlc1tbal1dWzFdICYgZGZfd29ya3Mkd29ya3NfeWVhciA8PSB3YXZlc1tbal1dWzJdLA0KICAgICAgICAgICAgICAgIF0NCiAgICAgICAgICAgIGZvciAoaSBpbiAxOm5yb3coZGZfd29ya3NfdykpIHsNCiAgICAgICAgICAgICAgICBlZ28gPC0gZGZfd29ya3NfdyR3b3Jrc19hdXRob3JbaV1bWzFdXSRhdV9pZFsxXQ0KICAgICAgICAgICAgICAgIGFsdGVycyA8LSBkZl93b3Jrc193JHdvcmtzX2F1dGhvcltpXVtbMV1dJGF1X2lkWy0xXQ0KICAgICAgICAgICAgICAgIGlmIChzdW0oaWRzICVpbiUgZWdvKSA+IDAgJiBzdW0oaWRzICVpbiUgYWx0ZXJzKSA+IDApIHsNCiAgICAgICAgICAgICAgICAgIG5ldHNbaiwgd2hpY2goaWRzICVpbiUgZWdvKSwgd2hpY2goaWRzICVpbiUgYWx0ZXJzKV0gPC0gMQ0KICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgIH0NCiAgICAgICAgfQ0KICAgIH0NCg0KICAgIGlmICh0eXBlID09ICJsYXN0Iikgew0KICAgICAgICBmb3IgKGogaW4gMTpud2F2ZXMpIHsNCiAgICAgICAgICAgIGRmX3dvcmtzX3cgPC0gZGZfd29ya3NbZGZfd29ya3Mkd29ya3NfeWVhciA+PSB3YXZlc1tbal1dWzFdICYgZGZfd29ya3Mkd29ya3NfeWVhciA8PSB3YXZlc1tbal1dWzJdLA0KICAgICAgICAgICAgICAgIF0NCiAgICAgICAgICAgIGZvciAoaSBpbiAxOm5yb3coZGZfd29ya3NfdykpIHsNCiAgICAgICAgICAgICAgICBlZ28gPC0gcmV2KGRmX3dvcmtzX3ckd29ya3NfYXV0aG9yW2ldW1sxXV0kYXVfaWQpWzFdDQogICAgICAgICAgICAgICAgYWx0ZXJzIDwtIHJldihkZl93b3Jrc193JHdvcmtzX2F1dGhvcltpXVtbMV1dJGF1X2lkKVstMV0NCiAgICAgICAgICAgICAgICBpZiAoc3VtKGlkcyAlaW4lIGVnbykgPiAwICYgc3VtKGlkcyAlaW4lIGFsdGVycykgPiAwKSB7DQogICAgICAgICAgICAgICAgICBuZXRzW2osIHdoaWNoKGlkcyAlaW4lIGVnbyksIHdoaWNoKGlkcyAlaW4lIGFsdGVycyldIDwtIDENCiAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICB9DQogICAgICAgIH0NCiAgICB9DQoNCiAgICBpZiAodHlwZSA9PSAiYWxsIikgew0KICAgICAgICBmb3IgKGogaW4gMTpud2F2ZXMpIHsNCiAgICAgICAgICAgIGRmX3dvcmtzX3cgPC0gZGZfd29ya3NbZGZfd29ya3Mkd29ya3NfeWVhciA+PSB3YXZlc1tbal1dWzFdICYgZGZfd29ya3Mkd29ya3NfeWVhciA8PSB3YXZlc1tbal1dWzJdLA0KICAgICAgICAgICAgICAgIF0NCiAgICAgICAgICAgIGZvciAoaSBpbiAxOm5yb3coZGZfd29ya3NfdykpIHsNCiAgICAgICAgICAgICAgICBlZ29zIDwtIGRmX3dvcmtzX3ckd29ya3NfYXV0aG9yW2ldW1sxXV0kYXVfaWQNCiAgICAgICAgICAgICAgICBpZiAoc3VtKGlkcyAlaW4lIGVnb3MpID4gMCkgew0KICAgICAgICAgICAgICAgICAgbmV0c1tqLCB3aGljaChpZHMgJWluJSBlZ29zKSwgd2hpY2goaWRzICVpbiUgZWdvcyldIDwtIDENCiAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICB9DQogICAgICAgIH0NCiAgICB9DQogICAgb3V0cHV0IDwtIGxpc3QoKQ0KICAgIG91dHB1dCRkYXRhIDwtIHNjaG9sYXJzX3NlbA0KICAgIG91dHB1dCRuZXRzIDwtIG5ldHMNCiAgICByZXR1cm4ob3V0cHV0KQ0KfQ0KYGBgDQoNCiMgR2V0IERhdGENCg0KTG9hZCBTY2hvbGFyIERhdGENCg0KYGBge3Igc2Nob2xhciBkYXRhfQ0Kc2Nob2xhcnMgPC0gZmxvYWQoIi4vZGF0YS9wcm9jZXNzZWQvc2Nob2xhcnNfMjAyNDA5MjQucmRhIikgDQpgYGANCg0KU2F2ZSB0aGUgb3V0cHV0IG9mIHRoZSBmdW5jdGlvbi4NCg0KYGBge3Igc2F2aW5nIG91dHB1dH0NCiMgc2F2ZSB0aGUgb3V0cHV0IG9mIHlvdXIgZnVuY3Rpb24NCnRlc3QgIDwtIGZjb2xuZXQoZGF0YSA9IHNjaG9sYXJzLCANCiAgICAgICAgICAgICAgICB1bml2ZXJzaXR5ID0gIlJVIiwgDQogICAgICAgICAgICAgICAgZGlzY2lwbGluZSA9IGMoInNvY2lvbG9neSIsICJwb2xpdGljYWwgc2NpZW5jZSIpLA0KICAgICAgICAgICAgICAgIHdhdmVzID0gbGlzdChjKDIwMTUsIDIwMTgpLCBjKDIwMTksIDIwMjMpKSwgDQogICAgICAgICAgICAgICAgdHlwZSA9IGMoImZpcnN0IikpDQpgYGANCg0KTG9hZCBFZ28gRGF0YQ0KDQpgYGB7ciBkZl9lZ28gZGF0YSwgaW5jbHVkZT0gRkFMU0V9DQpkZl9lZ28gPC0gZmxvYWQoIi4vZGF0YS9wcm9jZXNzZWQvZGZfZWdvXzIwMjQxMTA4LnJkYSIpDQoNCmBgYA0KDQojIE1ha2UgTmV0d29yayBEYXRhDQoNCmBgYHtyIFJTaWVuYSBuZXR3b3JrIGRhdGF9DQojc3RlcDEgZGF0YQ0Kd2F2ZTEgPC0gdGVzdCRuZXRzWzEsLF0NCndhdmUyIDwtIHRlc3QkbmV0c1syLCxdDQoNCiMgcHV0IG5ldHMgaW4gYW4gYXJyYXkNCm5ldF9hcnJheSA8LSBhcnJheShkYXRhID0gYyh3YXZlMSwgd2F2ZTIpLCBkaW0gPSBjKGRpbSh3YXZlMSksIDIpKQ0KDQpgYGANCg0KLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tDQoNCiMgQW5hbHlzaXMNCg0KYGBgez1odG1sfQ0KPCEtLQ0KIyMgVEVTVCBNT0RFTA0KDQojIyMgdGVzdCAxOiBEZWZpbmUgU2llbmEgRGF0YSAmIFZhcmlhYmxlcw0KLS0+DQpgYGANCmBgYHtyIFJTaWVuYSBkZWZpbmUsIGhpZGUgPVRSVUUsIGVjaG89RkFMU0UsIGV2YWw9RkFMU0V9DQojIGRlcGVuZGVudCB2YXJpYWJsZSANCm5ldHMgPC0gc2llbmFEZXBlbmRlbnQobmV0X2FycmF5KQ0KDQojIHB1dCBnZW5kZXIgaW4gb2JqZWN0IA0KZ2VuZGVyIDwtIGRmX2VnbyRnZW5kZXINCg0KIyBjb3ZhcmlhdGUgMQ0KZ2VuZGVyX1JTIDwtIGNvQ292YXIoZ2VuZGVyKSAjIGdlbmRlciBhcyBjb3ZhcmlhdGUgaW4gUnNpZW5hDQoNCg0KIyBwdXQgaC1pbmRleCBpbiBvYmplY3QgDQpoX2luZGV4IDwtIGRmX2VnbyRoX2luZGV4DQpkZl9lZ28kaF9pbmRleA0KDQojIGNvdmFyaWF0ZSAyDQpoX2luZGV4X1JTIDwtIGNvQ292YXIoaF9pbmRleCkgIyBoX2luZGV4IGFzIGNvdmFyaWF0ZSBpbiBSU2llbmENCg0KIyBkZWZpbmUgZGF0YSBvYmplY3QgDQpteWRhdGEgPC0gc2llbmFEYXRhQ3JlYXRlKG5ldHMsIGdlbmRlcl9SUywgaF9pbmRleF9SUykNCg0KYGBgDQoNCjwhLS0gUHJpbnQgc2hvcnQgZGVzY3JpcHRpdmUgcmVwb3J0LS0+DQoNCmBgYHtyLCBoaWRlID1UUlVFLCBlY2hvPUZBTFNFLCBldmFsPUZBTFNFfQ0KaWZlbHNlKCFkaXIuZXhpc3RzKCJyZXN1bHRzIiksIGRpci5jcmVhdGUoInJlc3VsdHMiKSwgRkFMU0UpDQoNCiNpZiB0aGVyZSBpcyBub3QgYSBmb2xkZXIgY2FsbGVkICJyZXN1bHRzIiBpbiB5b3VyIHJlcG9zaXRvcnk6IG1ha2Ugb25lDQoNCmBgYA0KDQpgYGB7ciwgaGlkZSA9VFJVRSwgZWNobz1GQUxTRSwgZXZhbD1GQUxTRX0NCnByaW50MDFSZXBvcnQobXlkYXRhLCBtb2RlbG5hbWUgPSAiLi9yZXN1bHRzL3RyeSIpICMgY3JlYXRlIGZpbGUgd2l0aCByZXBvcnQgaW4gcmVzdWx0cyBmb2xkZXIgDQpgYGANCg0KPCEtLSAjIyMgdGVzdCAyOiBNYWtlIGVmZmVjdHMgb2JqZWN0L3N0cnVjdHVyZSAtLT4NCg0KYGBge3IgUlNpZW5hIG15ZWZmLCBoaWRlID1UUlVFLCBlY2hvPUZBTFNFLCBldmFsPUZBTFNFfQ0KDQojIGRlZmluZSBlZmZlY3RzIHN0cnVjdHVyZSANCm15ZWZmIDwtIGdldEVmZmVjdHMobXlkYXRhKQ0KDQpgYGANCg0KYGBgez1odG1sfQ0KPCEtLQ0KDQplLmcuIG91dGRlZ3JlZSAoZGVuc2l0eSksIGNhbGxlZCBkZW5zaXR5LCB0aHJlZSB0aGluZ3M6IGV2YWx1YXRpb24sDQplbmRvd21lbnQsIGFuZCBjcmVhdGlvbiB5b3UgY2FuIG9ubHkgaW5jbHVkZSB0d28gb2YgdGhlIHRocmVlICh0aWUNCmNyZWF0aW9uLCBicmVha2luZyBhbmQgbWFpbnRhaW5pbmcpDQoNClRoZSBhc3N1bXB0aW9uIGlzOiBtZWNoYW5pc21zIHRvIG1ha2UgYW5kIGJyZWFrIGEgYSB0aWUgYXJlIHRoZSBzYW1lIHNvDQpXRSBPTkxZIFVTRSBUSEUgRVZBTFVBVElPTiBwYXJ0DQoNCkFsbCB0aGVzZSBlZmZlY3RzIGFyZSBkZXNjcmliZWQgaW4gdGhlIG1hbnVhbCBvZiBSU2llbmEgQ2hhcHRlciAxMiENCg0KLS0+DQpgYGANCmBgYHs9aHRtbH0NCjwhLS0gIA0KIyMjIFN0ZXAgWDogSW5pdGlhbCBkZXNjcmlwdGlvbg0KLS0+DQpgYGANCmBgYHs9aHRtbH0NCjwhLS0NCkhhcyBhIGxvdCBvZiBpbmZvcm1hdGlvbiBpbiB0aGVyZSBBbHNvOiBob3cgdGllIENIQU5HRUQgQWxzbzogSmFjY2FyZA0KaW5kZXggKG1lYXN1cmUgb2Ygc3RhYmlsaXR5KSBBbHNvIHJhdGUgcGFyYW1ldGVyIGFuZCBvdXRkZWdyZWUNCg0KPGh0dHBzOi8vd3d3LnN0YXRzLm94LmFjLnVrL35zbmlqZGVycy9zaWVuYS9SU2llbmFfTWFudWFsLnBkZj4NCg0KSW4gdGhlIHBhY2thZ2UgUnNpZW5hVHdvU3RlcCB0aGVyZSBhcmUgZnVuY3Rpb25zIGZvciB0aGUgZm9sbG93aW5nDQpuZXR3b3JrIHN0YXRpc3RpY3MgKioqcyoqKiA6DQoNCmRlZ3JlZTogYHRzX2RlZ3JlZSgpYA0KDQpyZWNpcHJvY2l0eTogYHRzX3JlY2lwKClgDQoNCm91dGRlZ3JlZSBhY3Rpdml0eTogYHRzX291dEFjdCgpYA0KDQppbmRlZ3JlZSBhY3Rpdml0eTogYHRzX2luQWN0KClgDQoNCm91dGRlZ3JlZSBwb3B1bGFyaXR5OiBgdHNfb3V0UG9wKClgDQoNCmluZGVncmVlIHBvcHVsYXJpdHk6IGB0c19pblBvcCgpYA0KDQp0cmFuc2l0aXZpdHk6IGB0c190cmFuc1RyaXAoKWANCg0KbWVkaWF0ZWQgdHJhbnNpdGl2aXR5OiBgdHNfdHJhbnNNZWRUcmlwKClgDQoNCnRyYW5zaXRpdmUgcmVjaXByb2NhdGVkIHRyaXBsZXRzOiBgdHNfdHJhbnNSZWNUcmlwKClgDQoNCm51bWJlciBvZiB0aHJlZS1jeWNsZXM6IGB0c19jeWNsZTMoKWANCi0tPg0KYGBgDQo8IS0tICMjIyB0ZXN0IDM6IEFkZCBFZmZlY3RzIC0tPg0KDQpgYGB7ciBlZmZlY3RzLCBoaWRlID1UUlVFLCBlY2hvPUZBTFNFLCBldmFsPUZBTFNFfQ0KDQojIE51bGwgbW9kZWw6IGp1c3QgbXllZmYgKGp1c3QgZGVncmVlIGFuZCByZWNpcHJvY2l0eSBieSBkZWZhdWx0KSAjIG1vZGVsMCAgI2ZvciB0aGlzIHdoZW4geW91IGNyZWF0ZSBTaWVuYSBEYXRhLCBkbyBub3QgYWRkIHRoZSBnZW5kZXIgdmFyaWFibGUgDQoNCm15ZWZmIDwtIGluY2x1ZGVFZmZlY3RzKG15ZWZmLCBpc29sYXRlTmV0LCBpblBvcCwgb3V0QWN0KSANCiMgaXNvbGF0ZW5ldDogaWYgaW5kaXZpZHVhbCBpcyBhbG9uZSB0aGV5ICJsaWtlIHRvL3RlbmQgdG8gc3RheSBhbG9uZSINCiMgaW5Qb3A6IHBwbCBsaWtlIHRvIGNvbGxhYiB3aXRoIHBlb3BsZSB3aG8gYXJlIHBvcHVsYXINCiAgIyBvdmVyIHRpbWU6IGlucG9wOiBwcGwgd2l0aCBsb3RzIG9mIGluZGVncmVlcyB3aWxsIGhhdmVsb3Qgb2YgaW5kZWdyZWVzDQoNCiNpbi1kZWdyZWUgcmVsYXRlZCBwb3B1bGFyaXR5IGVmZmVjdCAoaW5Qb3ApIChlYXJsaWVyIGNhbGxlZCBwb3B1bGFyaXR5IG9yIHBvcHVsYXJpdHkgb2YgYWx0ZXIgZWZmZWN0KSwgZGVmaW5lZCBieSB0aGUgc3VtIG9mIHRoZSBpbi1kZWdyZWVzIG9mIHRoZSBvdGhlcnMgdG8gd2hvbSBpIGlzIHRpZWQsDQoNCiMgbGF0ZXIgKGluIHBvcHVsYXRpb24pIG91dEFjdDogcHBsIHdpdGggbG90cyBvZiBvdXRkZWdyZWVzIHdpbGwgaGF2ZSBsb3QNCiMgb2YgaW5kZWdyZWVzIGxhdGVyDQoNCg0KbXllZmYgPC0gaW5jbHVkZUVmZmVjdHMobXllZmYsIGVnb1gsIGFsdFgsIHNhbWVYLCBpbnRlcmFjdGlvbjEgPSAiZ2VuZGVyX1JTIikgIyBtb2RlbDENCiMgaW5jbHVkZSBlZmZlY3Qgb2YgaCBpbmRleCBsYXRlciB0b28gZXRjDQojIGxvb2sgdXAgd2hpY2ggZWZmZWN0cyB0byBpbmNsdWRlDQoNCg0KDQoNCm15ZWZmIDwtIGluY2x1ZGVFZmZlY3RzKG15ZWZmLCBlZ29YLCBhbHRYLCBpblBvcFgsIGludGVyYWN0aW9uMSA9ICJoX2luZGV4X1JTIikgIyBtb2RlbCAyIChhcyBsb25nIGFzIG15ZWZmIGlzIGVpdGhpbiB0aGUgYnJhY2tldHMgdG9vLCB0aGUgb3RoZXIgdGhpbmdzIGdldCBhZGRlZCB0byB0aGUgbXllZmYgb2JqZWN0KQ0KDQoNCiMgY2hhbmdlIHN0YXRpc3RpY3MgdG8gZml0IHdoYXRldmVyIEkgd2FudCB0byBrbm93IGFib3V0IGgtaW5kZXggDQojIG5vdCBzYW1lWCANCiMgbG9vayB1cCBpblBvcFg6IHByZWZlcmVudGlhbCBhdHRhY2htZW50IChjZi4gS29lbiBsZWwpLCBoaWdoZXIgaC1pbmRleCBtb3JlIHBvcHVsYXIgDQogICMgY2YuIEZyaWRhcyBtb2RlbGluZyBwcm9jZXNzIChKb2NoZW0gdG9sZCBoZXIgdGhhdCApDQoNCiNkaWZmWFRyYW5zVHJpcA0KI2RpZmZlcmVudCBjb3ZhcmlhdGUgw5cgdHJhbnNpdGl2ZSB0cmlwbGV0cyAoZGlmZlhUcmFuc1RyaXApLCBkZWZpbmVkIGJ5IHRoZSBudW1iZXIgb2YgdHJhbnNpdGl2ZSB0cmlwbGV0cyBpIOKGkiBoIOKGkiBqIOKGkCBpIHRoYXQgaGF2ZSBkaWZmZXJlbnQgY292YXJpYXRlIHZhbHVlcyBmb3IgaSBhbmQgaiwgZGlmZi4gY292LiB2YWx1ZXMgPSBkaWZmIGdlbmRlciAtUlNpZW5hIG1hbnVhbCANCg0KIyAiVGhlIHRyYW5zdHJpcCBmb3IgZGlmZmVyZW50IGdlbmRlciAoZGlmZlhUcmFuc1RyaXApIGlzIHBvc2l0aXZlIGFuZCBzaWduaWZpY2FudCwgd2hpY2ggaW1wbGllcyB0aGF0IGFuIGVnbyBwcmVmZXJzIHRvIGNsb3NlIHRyaWFkcyB3aXRoIGFsdGVycyB3aG8gaGF2ZSBhIGRpZmZlcmVudCBnZW5kZXIgc2NvcmUgdGhhbiB0aGVpcnMuIFRoaXMgaXMgYW4gaW50ZXJlc3RpbmcgZmluZGluZywgYmVjYXVzZSBpdCBpbXBsaWVzIHRoYXQgdGhlaXIgaXMgYSB0ZW5kZW5jeSB0b3dhcmRzIGRpdmVyc2UgY29sbGFib3JhdGlvbi4gSG93ZXZlciwgd2hlbiBjb21wYXJlZCB0byB0aGUgbGV2ZWwgb2YgZ2VuZGVyIGNsdXN0ZXJpbmcgYW5kIHRoZSBmYWN0IHRoYXQgdGhpcyBjbHVzdGVyaW5nIGRlY3JlYXNlZCwgdGhpcyBmaW5kaW5nIGRvZXMgbWFrZSBzZW5zZS4iIC0gTmllbHMNCg0KDQpgYGANCg0KYGBgez1odG1sfQ0KPCEtLSANCg0KDQpoaW50IEZPUiBNWSBPV04gUFJPSkVDVDogaW50ZXJhY3Rpb24gZWZmZWN0IG9mIHRoZXNlIHN0YXRpc3RpY3MgYW5kIHRoZQ0KZWZmZWN0IG9mIGdlbmRlcg0KDQpUSEUgIlgiIGluIGFsdFggYW5kIGVvZ1ggcmVmZXIgdG8gdGhlICJpbnRlcmFjdGlvbiAxIiB2YXJpYWJsZSwgc28gaXQncyBlZy4gZWdvIHggZ2VuZGVyX1JTIGFuZCBhbHRlciB4IGdlbmRlcl9SUyENCg0KYWx0WCAtIGVnb3Mgc2VuZCBtb3JlIHRpZXMgd2hvIGhhdmUgbW9yZSBvbiBnZW5kZXIgKGFrYS4gZ2VuZGVyID0xKSANCihpaWlpc2ggbG9vayBhdCBlZ29YIGV4cGxhbmFudGlvbiwgdGhpcyBpcyBiYXNpY2FsbHkgdGhlIHNhbWUgYnV0IGluICJyZXZlcnNlIiwgYWthIGFib3V0IHJlY2VpdmluZyByYXRoZXIgdGhhbiBzZW5kaW5nKQ0KDQotICAgY292YXJpYXRlLWFsdGVyIG9yIGNvdmFyaWF0ZS1yZWxhdGVkIHBvcHVsYXJpdHkgKGFsdFgpLCBkZWZpbmVkIGJ5DQogICAgdGhlIHN1bSBvZiB0aGUgY292YXJpYXRlIG92ZXIgYWxsIGFjdG9ycyB0byB3aG9tICoqKmkqKiogaGFzIGEgdGllLA0KLSAgIHNhbWUgYXMgZWdvWCBidXQgUkVDRUlWSU5HIHRpZXMNCg0KZWdvWCAtIFtkZWZpbml0aW9uP10NCg0KLSAgIGNvdmFyaWF0ZS1lZ28gb3IgY292YXJpYXRlLXJlbGF0ZWQgYWN0aXZpdHkgKGVnb1gpLCBkZWZpbmVkIGJ5IGnigJlzDQogICAgb3V0LWRlZ3JlZSB3ZWlnaHRlZCBieSBoaXMgY292YXJpYXRlIHZhbHVlLA0KLSAgIHNpbmNlIG1hbGUgPSAxIGVnb1ggb25seSAibG9va3MgYXQiIG1lbidzIHRpZXMgDQotICAgaWYgZWdvWCBzaWduaWZpY2FudCB0aGVuIG1lbidzIHRpZXMgc2lnbi4gZGlmZi4gYmFzZWQgb24gd2hldGhlciBpdHMgdG8gYSBtYW4gb3Igd29tYW4gKGxvb2sgYXQgZGlyZWN0aW9uIG9mIGVmZmVjdCB0byBrbm93IHdoaWNoIGdlbmRlcikgDQoNCg0KDQpzYW1lWCAoR2VuZGVyKTogVGVzdHMgd2hldGhlciBzY2hvbGFycyBwcmVmZXIgc2FtZS1nZW5kZXIgY29sbGFib3JhdG9ycyAoZGlyZWN0IG1lYXN1cmUgb2YgZ2VuZGVyIGhvbW9waGlseSkuDQptb2RlbCB0aGUgZ2VuZXJhbCB0ZW5kZW5jeSBmb3Igc2Nob2xhcnMgdG8gY29sbGFib3JhdGUgd2l0aCBzYW1lLWdlbmRlciBwZWVycy4NCg0KICBDb25maXJtYXRpb246DQoNCiAgICBTaWduaWZpY2FudCBhbmQgcG9zaXRpdmUgY29lZmZpY2llbnQgZm9yIHNhbWVYIGluIHRoZSBSU2llbmEgb3V0cHV0IHdvdWxkIGNvbmZpcm0gdGhhdCBnZW5kZXIgaG9tb3BoaWx5IGV4aXN0cy4NCg0KICAgIEEgbm9uLXNpZ25pZmljYW50IG9yIG5lZ2F0aXZlIGNvZWZmaWNpZW50IHdvdWxkIGRpc2NvbmZpcm0gdGhpcyBoeXBvdGhlc2lzLg0KDQoNCiAgICANCg0KImludGVyYWN0aW9uMSIgSEFTIE5PVEhJTkcgVE8gRE8gV0lUSCBBTiBJTlRFUkFDVElPTiBFRkZFQ1QNCg0KLSAgIElmIHRoZXJlIGFyZSBzZXZlcmFsIGRlcGVuZGVudCB2YXJpYWJsZXMgKG5ldHdvcmtzIGFuZC9vciBiZWhhdmlvcmFsDQogICAgdmFyaWFibGVzKSwgdGhlIG5hbWUgb2YgdGhlIGRlcGVuZGVudCB2YXJpYWJsZSAobmFtZSkgYWxzbyBpcw0KICAgIHJlcXVpcmVkIHRvIHNwZWNpZnkgdGhlIGVmZmVjdCwgYW5kIHdpbGwgYmUgZ2l2ZW4gaW4gdGhlIGNvbHVtbg0KICAgIGludGVyYWN0aW9uMSAoZXRjLikgb2YgdGhlIGVmZmVjdHMgb2JqZWN0Lg0KDQotICAgSXQgc2hvdWxkIGJlIG1lbnRpb25lZCB0aGF0IHRoZSBrZXl3b3JkcyBpbnRlcmFjdGlvbjEsIGludGVyYWN0aW9uMiwNCiAgICBhbmQgaW50ZXJhY3Rpb24zIGluIGZ1bmN0aW9ucyBzdWNoIGFzIGluY2x1ZGVFZmZlY3RzIGRvIG5vdCBwb2ludCB0bw0KICAgIGludGVyYWN0aW9ucyBiZXR3ZWVuIGVmZmVjdHMuIFRoZXNlIGtleXdvcmRzIGFyZSB1c2VkIG9ubHkgdG8NCiAgICBleGFjdGx5IHNwZWNpZnkgYW4gZWZmZWN0LiBUaGV5IHBvaW50IHRvIHRoZSBjb3ZhcmlhdGUgb3Igb3RoZXINCiAgICBkZXBlbmRlbnQgdmFyaWFibGUgdXNlZCBpbiB0aGUgZWZmZWN0OyB0aGlzIG5hbWUgd2FzIGNob3NlbiBmb3IgdGhlDQogICAga2V5d29yZCBiZWNhdXNlIHRoaXMgb3RoZXIgdmFyaWFibGUgbWF5IGJlIHNhaWQgdG8gYmUgaW50ZXJhY3RpbmcNCiAgICB3aXRoIHRoZSBkZXBlbmRlbnQgdmFyaWFibGUgKG5ldHdvcmsgb3IgYmVoYXZpb3IpLg0KDQotLT4NCmBgYA0KPCEtLSAjIyMgdGVzdCA0OiBTcGVjaWZ5IG1vZGVsL2FsZ29yaXRobSAtLT4NCg0KYGBge3IgYWxnbywgaGlkZSA9VFJVRSwgZWNobz1GQUxTRSwgZXZhbD1GQUxTRX0NCiMgQWxnb3JpdGhtIGZyb20gd2hlbiBKb2NoZW0gYW5kIEkgc2F0IHRvZ2V0aGVyIGJ1dCBpdCdzIG5vdCBmaXR0aW5nIGFueW1vcmUgYmMgbW9kZWwgdHlwZSBpcyBmb3IgdW5kaXJlY3RlZCB0aWVzIA0KIyBteUFsZ29yaXRobSA8LSBzaWVuYUFsZ29yaXRobUNyZWF0ZShtb2RlbFR5cGUgPSBjKG5ldHM9NiksIHByb2puYW1lID0gInByb1Byb2plY3QiKQ0KIyB1bmRpcmVjdGVkOiBtb2RlbCA2ICJhZGRpdGl2ZSBtb2RlbCIsICNjaGVjayBtYW51YWwgZm9yIHRoaXMgTk9XIElUJ1MgVU5ESVJFQ1RFRCEhISANCg0KIyBOaWVscyBhZHZpY2U6IHRha2UgaGlzIGFsZ29yaXRobSBpbnN0ZWFkLiBoYWhhIG9rLCBubyBxdWVzdGlvbnMgYXNrZWQgbXkgZ3V5LCB5b3UgZ290IGl0LiANCm15QWxnb3JpdGhtX3Rlc3QgPC0gc2llbmFBbGdvcml0aG1DcmVhdGUgKHByb2puYW1lID0gInJlc3VsdHNfdGVzdCIpDQoNCmBgYA0KDQo8IS0tICMjIyB0ZXN0IDU6IEVzdGltYXRlIG1vZGVsIC0tPg0KDQpgYGB7ciBlc3RpbWF0ZSwgaGlkZSA9VFJVRSwgZWNobz1GQUxTRSwgZXZhbD1GQUxTRX0NCiMgZXN0aW1hdGUgdGhlIG1vZGVsIA0KbW9kZWxfdGVzdCA8LSBzaWVuYTA3KG15QWxnb3JpdGhtX3Rlc3QsIGRhdGEgPSBteWRhdGEsIGVmZmVjdHMgPSBteWVmZiwgcmV0dXJuRGVwcyA9IFRSVUUpDQojbGF0dGVyIG5lZWRlZCBmb3IgR09GIGxhdGVyb24NCg0KbW9kZWxfdGVzdA0KDQpgYGANCg0KYGBgez1odG1sfQ0KPCEtLSANCm91dHB1dDogIGNvbnZlcmdlbmNlIHJhdGlvbiBOQSBwcm9iYWJseSBiYyB3ZSBjaG9zZSBhbGwgdGllcyB0byBiZSBpbmNsdWRlZCAodHlwZSA9ICJhbGwiKSBlYXJsaWVyDQp3ZSBjYW4gZ28gYmFjayBhbmQgY2hhbmdlIHRoYXQgb3IgY2hhbmdlIGl0IGhlcmUgaW4gdGhlIG15QWxnb3JpdGhtIGZ1bmN0aW9uDQoNCmNvbnZlcmdlbmNlIHJhdGlvIHNob3VsZCBiZSA8LjI1ICAgISEhDQotIGlmIGFib3ZlLCBydW4gbW9kZWwgYWdhaW4NCi0gaWYgc3RheXMgYWJvdmUgLjI1LCByZW1vdmUgc29tZSBvZiB0aGUgbmV0dy4gc3RhdHMNCi0gaWYgY2xvc2UgdG8gdGhyZXNob2xkIChlLmcuIDAuMjU4NCkgYWRkIHByZXZBbnMgPSBtb2RlbDEgIHRvIHRoZSBzaWVuYTA3IGNvbW1hbmQgYW5kIHJlcnVuIHRoZW4NCiAgICAgIG1vZGVsMSA8LSBzaWVuYTA3KG15QWxnb3JpdGhtLCBkYXRhID0gbXlkYXRhLCBlZmZlY3RzID0gbXllZmYsIHByZXZBbnM9IG1vZGVsMSwgcmV0dXJuRGVwcyA9IFRSVUUpDQoNCi0tPg0KYGBgDQo8IS0tICMjIyB0ZXN0IDY6IEdPRiAtIEdvb2RuZXNzIG9mIEZpdCAtLT4NCg0KYGBge3IgR09GIHRlc3QsIGhpZGUgPVRSVUUsIGVjaG89RkFMU0UsIGV2YWw9RkFMU0V9DQpHT0YgPC0gc2llbmFHT0YobW9kZWxfdGVzdCwgSW5kZWdyZWVEaXN0cmlidXRpb24sIHZlcmJvc2UgPSBGQUxTRSwgam9pbiA9IFRSVUUsIHZhck5hbWUgPSAibmV0cyIpDQoNCnBsb3QoR09GLCBtYWluID0gIlRlc3QgSW5kZWdyZWUgRGlzdHIiKQ0KDQoNCiMgIkVycm9yIHVzaW5nIHBhY2tldCAxICJidyIgaXMgbm90IHBvc2l0aXZlIg0KDQojLS0tLS0tLS0tIFRyeSB0byBmaXggZXJyb3I6ICAtLS0tLS0tICANCiMjLS0tLS0tLS0tIEluc3BlY3QgR09GIG9iamVjdCAgLS0tLS0tLSANCiMgc3RyKEdPRikNCiAgIyBzdW1tYXJ5KEdPRiRKb2ludCRTaW11bGF0ZWRUZXN0U3RhdCkNCg0KIyMtLS0tLS0tLS0gQ2hlY2sgZm9yIGludmFsaWQgL2luZmludGUgdmFsdWVzIC0tLS0tLS0gDQogICAgIyBhbnlOQShHT0YkSm9pbnQkU2ltdWxhdGVkVGVzdFN0YXQpICAjIFNob3VsZCByZXR1cm4gRkFMU0UNCiAgICAjIGFueSghaXMuZmluaXRlKEdPRiRKb2ludCRTaW11bGF0ZWRUZXN0U3RhdCkpICAjIFNob3VsZCByZXR1cm4gRkFMU0UNCiAgICAjIHN1bW1hcnkoR09GJEpvaW50JFNpbXVsYXRlZFRlc3RTdGF0KSAgIyBJbnNwZWN0IHRoZSByYW5nZSBvZiB2YWx1ZXMNCg0KDQogICAgIyBHZXQgcmlkIG9mIGludmFsaWQgb3IgaW5maW5pdGUgdmFsdWVzDQogICAgICAgICMgR09GJEpvaW50JFNpbXVsYXRlZFRlc3RTdGF0IDwtIG5hLm9taXQoR09GJEpvaW50JFNpbXVsYXRlZFRlc3RTdGF0KQ0KICAgICAgICAjIEdPRiRKb2ludCRTaW11bGF0ZWRUZXN0U3RhdCA8LSAgIEdPRiRKb2ludCRTaW11bGF0ZWRUZXN0U3RhdFtpcy5maW5pdGUoR09GJEpvaW50JFNpbXVsYXRlZFRlc3RTdGF0KV0NCg0KICAjIHZhcihHT0YkSm9pbnQkU2ltdWxhdGVkVGVzdFN0YXQpICAjIFNob3VsZCByZXR1cm4gYSBwb3NpdGl2ZSB2YWx1ZQ0KDQoNCiMjLS0tLS0tLS0tIERlbnNpdHkgc2ltdWxhdGlvbiAgLS0tLS0tLSANCiAgICAjIHNpbXVsYXRlZCA8LSBHT0YkSm9pbnQkU2ltdWxhdGVkVGVzdFN0YXQNCiAgICAjICMgVHJ5IGRlbnNpdHkgZXN0aW1hdGlvbiB3aXRoIGRlZmF1bHQgYmFuZHdpZHRoDQogICAgIyAgIGRlbnNpdHlfZXN0IDwtIHRyeUNhdGNoKGRlbnNpdHkoc2ltdWxhdGVkKSwgZXJyb3IgPSBmdW5jdGlvbihlKSBlKQ0KICAgICMgICBpZiAoaW5oZXJpdHMoZGVuc2l0eV9lc3QsICJlcnJvciIpKSB7DQogICAgIyAgIHByaW50KCJEZW5zaXR5IGVzdGltYXRpb24gZmFpbGVkLiIpDQogICAgIyAgICAgfSBlbHNlIHsNCiAgICAjICAgICAgICAgICAgIHByaW50KCJEZW5zaXR5IGVzdGltYXRpb24gc3VjY2VlZGVkLiIpDQogICAgIyAgICAgICAgICAgICBwbG90KGRlbnNpdHlfZXN0LCBtYWluID0gIlNpbXVsYXRlZCBUZXN0IFN0YXRpc3RpY3MiKQ0KICAgICMgICAgIH0NCiAgICAjICAgDQojIy0tLS0tLS0tLSBGb3JjZSBiYW5kd2lkdGggLS0tLS0tLSAgICAgDQogICAgICAjIEZvcmNlIHRoZSBCYW5kd2lkdGggaW4gcGxvdC5zaWVuYUdPRg0KICAgICAgIyBwbG90KEdPRiwgbWFpbiA9ICJJbmRlZ3JlZSBEaXN0cmlidXRpb24gR29vZG5lc3Mgb2YgRml0IiwgYncgPSAwLjUpDQogICAgICAjICNub3BlIGRvZXMgbm90IHdvcmsgDQoNCiMjLS0tLS0tLS0tIEN1c3RvbSBmdW5jdGlvbiAtLS0tLS0tICANCiAgICAgICMgY3VzdG9tX3Bsb3Rfc2llbmFHT0YgPC0gZnVuY3Rpb24oZ29mLCBidyA9IDAuNSwgLi4uKSB7DQogICAgICAjIHNpbXVsYXRlZCA8LSBnb2YkSm9pbnQkU2ltdWxhdGVkVGVzdFN0YXQNCiAgICAgICMgb2JzZXJ2ZWQgPC0gZ29mJEpvaW50JE9ic2VydmVkVGVzdFN0YXQNCiAgICAgICMgDQogICAgICAjICMgUGVyZm9ybSBkZW5zaXR5IGVzdGltYXRpb24gd2l0aCBmb3JjZWQgYmFuZHdpZHRoDQogICAgICAjIGRlbnNpdHlfZXN0IDwtIGRlbnNpdHkoc2ltdWxhdGVkLCBidyA9IGJ3KQ0KICAgICAgIyANCiAgICAgICMgIyBQbG90IHRoZSBkZW5zaXR5DQogICAgICAjIHBsb3QoZGVuc2l0eV9lc3QsIG1haW4gPSAiQ3VzdG9tIEluZGVncmVlIERpc3RyLi0gR09GIiwgLi4uKQ0KICAgICAgIyBhYmxpbmUodiA9IG9ic2VydmVkLCBjb2wgPSAicmVkIiwgbHR5ID0gMiwgbHdkID0gMikgDQogICAgICAjIH0NCiAgICAgICMgDQogICAgICAjICAjcnVuIGN1c3RvbSBmdW5jdGlvbiAgICAgIA0KICAgICAgIyBjdXN0b21fcGxvdF9zaWVuYUdPRihHT0YsIGJ3ID0gMC41KQ0KICAgICAgIyAjIHdvcmtzIGJ1dCBub3QgdGhlIHNhbWUgYXQgYWxsIA0KICAgICAgIyANCiMjLS0tLS0tLS0tIEdncGxvdDIgLS0tLS0tLSANCiMgRnVjayB0aGlzIHNoaXQuIEkgdXNpbmcgZ2dwbG90IA0KICAgICMgbGlicmFyeShnZ3Bsb3QyKQ0KICAgICMgDQogICAgIyAjIFByZXBhcmUgZGF0YQ0KICAgICMgZGF0YSA8LSBkYXRhLmZyYW1lKA0KICAgICMgICB2YWx1ZSA9IEdPRiRKb2ludCRTaW11bGF0ZWRUZXN0U3RhdCwNCiAgICAjICAgdHlwZSA9ICJTaW11bGF0ZWQiDQogICAgIyApDQogICAgIyBkYXRhIDwtIHJiaW5kKGRhdGEsIGRhdGEuZnJhbWUodmFsdWUgPSBHT0YkSm9pbnQkT2JzZXJ2ZWRUZXN0U3RhdCwgdHlwZSA9ICJPYnNlcnZlZCIpKQ0KICAgICMgDQogICAgIyAjIFBsb3QgZGVuc2l0eQ0KICAgICMgZ2dwbG90KGRhdGEsIGFlcyh4ID0gdmFsdWUsIGZpbGwgPSB0eXBlKSkgKw0KICAgICMgICBnZW9tX2RlbnNpdHkoYWxwaGEgPSAwLjUsIGFkanVzdCA9IDEsIGJ3ID0gMC41KSArDQogICAgIyAgIGdlb21fdmxpbmUoeGludGVyY2VwdCA9IEdPRiRKb2ludCRPYnNlcnZlZFRlc3RTdGF0LCBjb2xvciA9ICJyZWQiLCBsaW5ldHlwZSA9ICJkYXNoZWQiKSArDQogICAgIyAgIGdndGl0bGUoIkluZGVncmVlIERpc3RyaWJ1dGlvbiBHb29kbmVzcyBvZiBGaXQiKSArDQogICAgIyAgIHRoZW1lX21pbmltYWwoKQ0KDQojIHdvcmtzIGJ1dCBpdCdzIHRoZSBzYW1lIHRoaW5nIGFzIHdpdGggdGhlIGN1c3RvbSBmdW5jdGlvbi4uLiBJdCBub3QgYSB2aW9saW4tcGxvdCBhbmQganVzdCBkb2VzIG5vdCBoaXQgdGhlIHNwb3QuIA0KIyBUaGUgb25seSB2aW9saW5zIEkgaGF2ZSBhcmUgdGhlIG9uZXMgcGxheWluZyB0aGUgc2FkIHNlbGYtcGl0eSBtdXNpYyBpbiBteSBicmFpbiByaWdodCBub3cuIA0KDQojIy0tLS0tLS0tLSByZWluc3RhbGwgUlNpZW5hIC0tLS0tLS0gDQoNCiMgSS4uLi4gDQogICAgIyAuLi4uDQogICAgICAjIC4uLi4gDQogICAgICAgICMgLi4uLiBzdXJlLiAgDQoNCg0KIyAtLS0tLS0tLS0gSSBoYXRlIG15c2VsZiBhbmQgYmFjayB3ZSBnbyB0byBHT0YgLS0tLS0NCiMgb3RoZXIgc2llbmEgR09GIGZ1bmN0aW9ucyAob3V0ZGVncmVlIGRvZXMgbm90IHdvcmsgZWl0aGVyLCBHZW9kZXNpY0Rpc3RyaWJ1dGlvbiB3ZWlyZGx5IGVub3VnaCB3b3Jrcy4pDQoNCiNnb2ZvMCA8LSBzaWVuYUdPRihtb2RlbF90ZXN0LCBPdXRkZWdyZWVEaXN0cmlidXRpb24sIHZlcmJvc2UgPSBGQUxTRSwgam9pbiA9IFRSVUUsIGxldmxzID0gYygwOjEwLCAxNSwgMjApLCB2YXJOYW1lID0gIm5ldHMiKQ0KI3Bsb3QoZ29mbzAsIG1haW4gPSJUZXN0IE91dGRlZ3JlZSBEaXN0ciIpDQoNCiNnb2YwLmdkIDwtIHNpZW5hR09GKG1vZGVsX3Rlc3QsIEdlb2Rlc2ljRGlzdHJpYnV0aW9uLCBjdW11bGF0aXZlID0gRkFMU0UsIHZlcmJvc2UgPSBGQUxTRSwgam9pbiA9IFRSVUUsIHZhck5hbWUgPSAibmV0cyIpDQojcGxvdChnb2YwLmdkLCBtYWluID0iVGVzdCBHZW9kZXNpYyIpDQoNCg0KYGBgDQoNCmBgYHs9aHRtbH0NCjwhLS0gDQoNCk1ha2UgaXQgYSBkaXJlY3RlZCBuZXR3b3JrOiAgdGllcyBmcm9tICJhbGwiIHRvICJmaXJzdCINCmZvY3VzOiB3cml0aW5nLA0KbW9kZWwgaW50ZXJwcmV0YXRpb24NCg0KDQojIyMgUXVlc3Rpb25zDQoNCi0gICBJcyB0aGUgdXNlIG9mIFJTaWVuYSBkaWZmZXJlbnQgZm9yIHBlb3BsZSB3aG8gbG9vayBhdCAxIHZzIDIgd2F2ZXMuDQogICAgSSBuZWVkIHRvIGxvb2sgYXQgb25lLCBtYWRlIDIgYW55d2F5cyBiYyBSU2llbmEgbmVlZHMgd2F2ZXMgdG8gZG8NCiAgICBpdCdzIHRoaW5nIGJ1dDpcDQogICAgRG9lc24ndCBpdCBsb29rIGF0IG1pbmlzdGVwcyBvdmVyIHRpbWU/IEhvdyBjYW4gSSBpbnRlcnByZXQgdGhlDQogICAgb3V0cHV0IGluIGEgd2F5IHRoYXQgcGVydGFpbnMgdG8gb25seSBvbmUgd2F2ZSB3aGVuIHRoZSBwcm9jZXNzDQogICAgc2VlbXMgdG8gY29uc2lkZXIgaXQgd2l0aGluIHRoZSBjb25zdHJ1Y3Qgb2YgJ2Z1dHVyZSBjaGFuZ2UnPw0KDQogICAgLSAgIEhvdyBkb2VzIG15IG1vZGVsIGludGVycHJldGF0aW9uIHBvdGVudGlhbGx5IGRpZmZlciBmcm9tIHBlZXBzDQogICAgICAgIHdobyBsb29rZWQgYXQgdHdvIHdhdmVzIChvciBtb3JlKT8NCg0KLSAgIG5vdCBsb29raW5nIGF0IFRXb1N0ZXAhIGRpZmYuIG1vZGVsbGluZyBwcm9jZXNzLiANClJTaWVuYSB3b3JrcyB3aXRoIG1pbmlzdGVwcyBpbmRlZWQgbm90IGp1c3QgVHdvc3RlcHMgKHRoYXQgd29ya3Mgd2l0aCB0d28gc3RlcHMgbG9sKQ0KDQoNCi0gZGlmZi4gYmV0d2VlZW4gd2F2ZSAxIGFuZCB3YXZlIDIgbW9kZWwgLT4gY29udmVyZ2VuY2UgDQotIGRlZmF1bHQgcmVjaXAuIGFuZCBkZWdyZWU6IGVzdGltYXRlcyB0aGUgcHV0cHV0IGJhc2VkIG9uIGEgY2VydGFpbiByZWNpcHJvYy4gYW5kIGRlZ3JlZSAiYXNzdW1wdGlvbiINCiANCi0tPg0KYGBgDQojIyBcPFw+IE1vZGVsIDAgLSBOdWxsIE1vZGVsDQoNCkZpcnN0LCBJIGVzdGltYXRlZCBhIG51bGwgbW9kZWwgd2l0aCBvbmx5IHJlY2lwcm9jaXR5IGFuZCBkZWdyZWUuIFRoZQ0KbWF4aW11bSBjb252ZXJnZW5jZSByYXRpbyBvZiB0aGUgbW9kZWwgaXMgMC4wODQuIFRoZSBHT0Ygb24gdGhlIEluZGVncmVlDQpEaXN0cmlidXRpb24gaXMgemVybyoqLioqIFRoaXMgaW5kaWNhdGVzIHRoYXQgdGhlIG1vZGVsIGlzIGEgdmVyeSBiYWQNCmZpdCBmb3IgdGhlIGRhdGEgYW5kIGVzdGltYXRlcyBvZiB0aGlzIG1vZGVsIGRvIG5vdCBnaXZlIHVzIHJlbGlhYmxlDQppbmZvcm1hdGlvbi4gXA0KKkZvciBhbGwgR09GIHBsb3RzIGNvbXBpbGVkIGluIG9uZSBwbGFjZSwgc2VlIGhlcmU6DQo8aHR0cHM6Ly90cmVlc2R1ZGUuZ2l0aHViLmlvL2xhYmpvdXJuYWwvZmluYWxHT0YuaHRtbD4uXA0KKkZvciB0aGUgc2FrZSBvZiBwcmFjdGlzZSwgaGVyZSB0aGV5IGFyZSBhbnl3YXlzOlwNClRoZSBvdXRkZWdyZWUgKGRlbnNpdHkpIGVmZmVjdCBhc3Nlc3NlcyB0aGUgdGVuZGVuY3kgb2Ygbm9kZXMgdG8NCmVzdGFibGlzaCBvdXRnb2luZyBjb25uZWN0aW9ucywgc2VydmluZyBhcyBhIGJhc2VsaW5lIGZvciB0aGUgbGlrZWxpaG9vZA0KdGhhdCBhbnkgZ2l2ZW4gbm9kZSB3aWxsIGluaXRpYXRlIGFuIG91dGdvaW5nIHRpZS4gSW4gdGhlIGNvbnRleHQgb2YNCnRoaXMgc3R1ZHksIHRoZXNlIG91dGdvaW5nIHRpZXMgcmVwcmVzZW50IHRoZSBpbml0aWF0aW9uIG9mDQpjby1wdWJsaWNhdGlvbnMuIFRoZSBvdXRkZWdyZWUgZXN0aW1hdGUgaXMgc2lnbmlmaWNhbnQgYW5kIG5lZ2F0aXZlIChiID0NCi0yLjYzODgsIFNFID0gMC4xNDYwKSwgc3VnZ2VzdGluZyB0aGF0IGEgc2Nob2xhcidzIHRlbmRlbmN5IHRvIGluaXRpYXRlDQpjb2xsYWJvcmF0aW9uIGlzIGxvdyBhbmQgZGVuc2UgbmV0d29ya3MgYXJlIGxlc3Mgc291Z2h0IGFmdGVyLiBUaGUNCnJlY2lwcm9jaXR5IHBhcmFtZXRlciBpZCBzaWduaWZpY2FudCBhbmQgcG9zaXRpdmUgKGIgPSAxLjgwMzUsIFNFID0NCjAuNDM0MyksIHdoaWNoIGltcGxpZXMgdGhhdCBkaXJlY3RlZCB0aWVzIGFyZSBsaWtlbHkgdG8gYmUgcmVjaXByb2NhdGVkLg0KU3BlY2lmaWMgdG8gb3VyIGNhc2UsIGl0IGRlc2NyaWJlcyB0aGF0IHNjaG9sYXJzIHRlbmQgdG8gaW5pdGlhdGUNCmNvbGxhYm9yYXRpb25zIHdpdGggdGhvc2UgYWx0ZXJzIHdobyBzZW50IGEgdGllIHRvIHRoZW0gdG9vLg0KDQojIyMgLS0tU3RlcCAxOiBEZWZpbmUgU2llbmEgRGF0YSAmIFZhcmlhYmxlcw0KDQpgYGB7ciBSU2llbmEgZGVmaW5lIG0wfQ0KIyBkZXBlbmRlbnQgdmFyaWFibGUgDQpuZXRzIDwtIHNpZW5hRGVwZW5kZW50KG5ldF9hcnJheSkNCg0KIyBkZWZpbmUgZGF0YSBvYmplY3QgDQpteWRhdGFfTTAgPC0gc2llbmFEYXRhQ3JlYXRlKG5ldHMpDQoNCmBgYA0KDQpQcmludCBzaG9ydCBkZXNjcmlwdGl2ZSByZXBvcnQNCg0KYGBge3J9DQppZmVsc2UoIWRpci5leGlzdHMoInJlc3VsdHMiKSwgZGlyLmNyZWF0ZSgicmVzdWx0cyIpLCBGQUxTRSkNCg0KYGBgDQoNCmBgYHtyfQ0KcHJpbnQwMVJlcG9ydChteWRhdGFfTTAsIG1vZGVsbmFtZSA9ICIuL3Jlc3VsdHMvcmVzdWx0c19NMCIpICMgY3JlYXRlIGZpbGUgd2l0aCByZXBvcnQgaW4gcmVzdWx0cyBmb2xkZXIgDQpgYGANCg0KIyMjIC0tLVN0ZXAgMjogTWFrZSBlZmZlY3RzIG9iamVjdC9zdHJ1Y3R1cmUNCg0KYGBge3IgUlNpZW5hIG15ZWZmIE0wfQ0KIyBkZWZpbmUgZWZmZWN0cyBzdHJ1Y3R1cmUgDQpteWVmZl9NMCA8LSBnZXRFZmZlY3RzKG15ZGF0YV9NMCkNCg0KYGBgDQoNCiMjIyAtLS1TdGVwIDM6IEFkZCBFZmZlY3RzDQoNCk51bGwgbW9kZWw6IG5vbmUuDQoNCiMjIyAtLS1TdGVwIDQ6IFNwZWNpZnkgbW9kZWwvYWxnb3JpdGhtDQoNCmBgYHtyIGFsZ28gTTB9DQoNCm15QWxnb3JpdGhtX00wIDwtIHNpZW5hQWxnb3JpdGhtQ3JlYXRlIChwcm9qbmFtZSA9ICJyZXN1bHRzX00wIikNCg0KYGBgDQoNCiMjIyAtLS1TdGVwIDU6IEVzdGltYXRlIG1vZGVsDQoNCmBgYHtyIGVzdGltYXRlIE0wLCBldmFsPUZBTFNFfQ0KIyBlc3RpbWF0ZSB0aGUgbW9kZWwgDQpNb2RlbDAgPC0gc2llbmEwNyhteUFsZ29yaXRobV9NMCwgZGF0YSA9IG15ZGF0YV9NMCwgZWZmZWN0cyA9IG15ZWZmX00wLCByZXR1cm5EZXBzID0gVFJVRSkNCk1vZGVsMA0KDQpmc2F2ZShNb2RlbDAsIGZpbGUgPSJlc3RpbWF0ZWRfTTAiKQ0KYGBgDQoNCmBgYHtyIGxvYWQgTTAgb3V0cHV0LCBlY2hvPUZBTFNFfQ0KTW9kZWwwIDwtIGZsb2FkKCIuL2RhdGEvcHJvY2Vzc2VkL2VzdGltYXRlZF9NMF8yMDI0MTEyMy5yZGEiKQ0KTW9kZWwwDQpgYGANCg0KYGBge3IgR09GIE0wfQ0KR09GX00wIDwtIHNpZW5hR09GKE1vZGVsMCwgSW5kZWdyZWVEaXN0cmlidXRpb24sIHZlcmJvc2UgPSBGQUxTRSwgam9pbiA9IFRSVUUsIHZhck5hbWUgPSAibmV0cyIpDQoNCnBsb3QoR09GX00wLCBtYWluID0gJ0dPRiAtICJOdWxsIiBNb2RlbCAwIFxuIEluZGVncmVlIERpc3RyaWJ1dGlvbicpDQpgYGANCg0KLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tDQoNCiMjIFw8XD4gTW9kZWwgMSAtIFN0cnVjdHVyYWwgRWZmZWN0cw0KDQpUaGlzIG1vZGVsIGFkZGl0aW9uYWxseSBlbnRhaWxzIEluUG9wLCBvdXRBY3QsIGlzb2xhdGVOZXQgdG8gY29udHJvbCBmb3INCmVmZmVjdHMgb2YgbmV0d29yayBzdGF0aXN0aWNzLiBUaGUgbWF4aW11bSBjb252ZXJnZW5jZSByYXRpbyBvZiB0aGlzDQptb2RlbCBpcyAqKjAuMTcqKiBhbmQgYSBHb29kbmVzcyBvZiBGaXQgb24gdGhlIGluZGVncmVlIGRpc3RyaWJ1dGlvbiBpcw0KKiowLjAwMi4qKiBFc3RpbWF0ZXMgb2YgdGhpcyBtb2RlbCBkbyBub3QgZml0IHRoZSBkYXRhIHdlbGwgYW5kIHRodXMgZG8NCm5vdCBnaXZlIHVzIHJlbGlhYmxlIGluZm9ybWF0aW9uLg0KDQpGb3IgdGhlIHNha2Ugb2YgcHJhY3Rpc2UsIGhlcmUgdGhleSBhcmUgYW55d2F5czpcDQpBcyBpbiBvdXIgbnVsbCBtb2RlbCwgdGhlIHBhcmFtZXRlcnMgZm9yIG91dGRlZ3JlZSAoYiA9IC0yLjA4NjIsIFNFID0NCjAuNzA1MCkgYW5kIHJlY2lwcm9jaXR5IChiID0gMS4wODk0LCBTRSA9IDAuNDE0NCkgcmVtYWluIHNpZ25pZmljYW50IGFuZA0KdW5jaGFuZ2VkIG9uIHRoZWlyICdkaXJlY3Rpb24nLg0KDQpUaGUgYWRkZWQgcGFyYW1ldGVyIGZvciBpbmRlZ3JlZSBwb3B1bGFyaXR5IHRlbGxzIHVzIHNvbWV0aGluZyBhYm91dCB0aGUNCnBvcHVsYXJpdHkgb2YgcGVvcGxlIHdobyBoYXZlIGEgbG90IG9mIG91dGdvaW5nIHRpZXMuIEluIG91ciBtb2RlbCB0aGUNCmVzdGltYXRlIGZvciB0aGlzIHBhcmFtZXRlciBpcyBzaWduaWZpY2FudGx5IHBvc2l0aXZlIChiID0wLjI1NDksIFNFDQo9MC4wNDM5KSwgc3VnZ2VzdGluZyB0aGF0IHNjaG9sYXJzIHNwZWNpZmljYWxseSBsaWtlIHRvIGluaXRpYXRlDQpjb2xsYWJvcmF0aW9ucyB3aXRoIHRob3NlIHdobyBoYXZlIGEgbG90IG9mIGluZGVncmVlcy4NCg0KRnVydGhlciwgdGhlIHBhcmFtZXRlciBmb3Igb3V0ZGVncmVlIGFjdGl2aXR5IGNvbnZleXMgaW5mb3JtYXRpb24gYWJvdXQNCnNjaG9sYXJzJyBwcmVmZXJlbmNlcyB0byBjb2xsYWJvcmF0ZSB3aXRoIG90aGVycyB3aG8gaGF2ZSBhIGxvdCBvZg0Kb3V0ZGVncmVlcy4gSW4gb3VyIGNhc2UsIHRoZSBlc3RpbWF0ZSBpcyBpbnNpZ25pZmljYW50IGFuZCBjYW5ub3QgYmUNCnJlbGlhYmx5IGludGVycHJldGVkLg0KDQpMYXN0bHksIHRoZSBuZXR3b3JrIGlzb2xhdGUgcGFyYW1ldGVyIGNhbiBiZSB1c2VkIHRvIGluZmVyIGFib3V0DQpzY2hvbGFycycgdGVuZGVuY3kgdG8gbmVpdGhlciBzZW5kIG5vciByZWNlaXZlIHRpZXMuIFRoZSBlc3RpbWF0ZSBmb3INCnRoaXMgcGFyYW1ldGVyIGlzIHNpZ25pZmljYW50bHkgcG9zaXRpdmUgKGIgPSA0Ljk2NDUsIFNFID0gMS4xMTQ2KSBpbg0Kb3VyIG1vZGVsLCBpbmRpY2F0aW5nIHRoYXQgdGhlIHNjaG9sYXJzIG9mIG91ciBzYW1wbGUgdGVuZCB0byByZW1haW4NCmlzb2xhdGVzLg0KDQojIyMgLS0tU3RlcCAxOiBEZWZpbmUgU2llbmEgRGF0YSAmIFZhcmlhYmxlcw0KDQpgYGB7ciBSU2llbmEgZGVmaW5lIE0xfQ0KIyBkZXBlbmRlbnQgdmFyaWFibGUgDQpuZXRzIDwtIHNpZW5hRGVwZW5kZW50KG5ldF9hcnJheSkNCg0KIyBkZWZpbmUgZGF0YSBvYmplY3QgDQpteWRhdGFfTTEgPC0gc2llbmFEYXRhQ3JlYXRlKG5ldHMpDQoNCmBgYA0KDQpQcmludCBzaG9ydCBkZXNjcmlwdGl2ZSByZXBvcnQNCg0KYGBge3J9DQppZmVsc2UoIWRpci5leGlzdHMoInJlc3VsdHMiKSwgZGlyLmNyZWF0ZSgicmVzdWx0cyIpLCBGQUxTRSkNCg0KYGBgDQoNCmBgYHtyfQ0KcHJpbnQwMVJlcG9ydChteWRhdGFfTTEsIG1vZGVsbmFtZSA9ICIuL3Jlc3VsdHMvcmVzdWx0c19NMSIpICMgY3JlYXRlIGZpbGUgd2l0aCByZXBvcnQgaW4gcmVzdWx0cyBmb2xkZXIgDQpgYGANCg0KIyMjIC0tLVN0ZXAgMjogTWFrZSBlZmZlY3RzIG9iamVjdC9zdHJ1Y3R1cmUNCg0KYGBge3IgUlNpZW5hIG15ZWZmIG0xfQ0KIyBkZWZpbmUgZWZmZWN0cyBzdHJ1Y3R1cmUgDQpteWVmZl9NMSA8LSBnZXRFZmZlY3RzKG15ZGF0YV9NMSkNCg0KYGBgDQoNCiMjIyAtLS1TdGVwIDM6IEFkZCBFZmZlY3RzDQoNCmBgYHtyIGVmZmVjdHMgbTF9DQoNCm15ZWZmX00xIDwtIGluY2x1ZGVFZmZlY3RzKG15ZWZmX00xLCBpc29sYXRlTmV0LCBpblBvcCwgb3V0QWN0KQ0KDQpgYGANCg0KIyMjIC0tLVN0ZXAgNDogU3BlY2lmeSBtb2RlbC9hbGdvcml0aG0NCg0KYGBge3IgYWxnbyBtMX0NCg0KbXlBbGdvcml0aG1fTTEgPC0gc2llbmFBbGdvcml0aG1DcmVhdGUgKHByb2puYW1lID0gInJlc3VsdHNfTTEiKQ0KDQpgYGANCg0KIyMjIC0tLVN0ZXAgNTogRXN0aW1hdGUgbW9kZWwNCg0KYGBge3IgZXN0aW1hdGUgbTEsIGV2YWwgPSBGQUxTRX0NCiMgZXN0aW1hdGUgdGhlIG1vZGVsIA0KTW9kZWwxIDwtIHNpZW5hMDcobXlBbGdvcml0aG1fTTEsIGRhdGEgPSBteWRhdGFfTTEsIGVmZmVjdHMgPSBteWVmZl9NMSwgcmV0dXJuRGVwcyA9IFRSVUUpDQpNb2RlbDENCiMgbWF4aW11bSBjb252ZXJnZW5jZSA+LjI1DQojIHJ1biBhZ2FpbjoNCk1vZGVsMS4xIDwtIHNpZW5hMDcobXlBbGdvcml0aG1fTTEsIGRhdGEgPSBteWRhdGFfTTEsIGVmZmVjdHMgPSBteWVmZl9NMSwgcHJldkFucz0gTW9kZWwxLCByZXR1cm5EZXBzID0gVFJVRSkNCk1vZGVsMS4xDQoNCiNmc2F2ZShNb2RlbDEsIGZpbGUgPSJlc3RpbWF0ZWRfTTEiKQ0KI2ZzYXZlKE1vZGVsMS4xLCBmaWxlID0gImVzdGltYXRlZF9NMS4xIikNCg0KYGBgDQoNCmBgYHtyIGxvYWQgTTEgb3V0cHV0LCBlY2hvPUZBTFNFfQ0KDQpNb2RlbDEgPC0gZmxvYWQoIi4vZGF0YS9wcm9jZXNzZWQvZXN0aW1hdGVkX00xXzIwMjQxMTIzLnJkYSIpDQpNb2RlbDENCg0KTW9kZWwxLjEgPC0gZmxvYWQoIi4vZGF0YS9wcm9jZXNzZWQvZXN0aW1hdGVkX00xLjFfMjAyNDExMjMucmRhIikNCk1vZGVsMS4xDQpgYGANCg0KIyMjIC0tLVN0ZXAgNjogR09GIC0gR29vZG5lc3Mgb2YgRml0DQoNCmBgYHtyIEdPRiBNMX0NCkdPRl9NMS4xIDwtIHNpZW5hR09GKE1vZGVsMS4xLCBJbmRlZ3JlZURpc3RyaWJ1dGlvbiwgdmVyYm9zZSA9IEZBTFNFLCBqb2luID0gVFJVRSwgdmFyTmFtZSA9ICJuZXRzIikNCg0KcGxvdChHT0ZfTTEuMSwgbWFpbiA9ICJHT0YgLSBNb2RlbCAxIFxuIEluZGVncmVlIERpc3RyaWJ1dGlvbiIpDQpgYGANCg0KLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tDQoNCiMjIFw8XD4gTW9kZWwgMiAtIEdlbmRlcg0KDQpUaGlzIG1vZGVsIGlzIHBhcnRseSBzaW1pbGFyIHRvIE1vZGVsIDEgYnV0IGFkZGl0aW9uYWxseSBob2xkcyB0aGUNCm5ldHdvcmsgc3RhdGlzdGljcyBzYW1lWCwgZGlmZlhUcmFuc1RyaXAsIGVnb1ggJiBhbHRYIG9mIHRoZSBjb3ZhcmlhdGUNCmdlbmRlci4gRWdvWCBhbmQgQWx0WCBvdWdodCB0byBpbmRpY2F0ZSB3aGV0aGVyIG1hbGUgb3IgZmVtYWxlIHNjaG9sYXJzDQphcmUgbW9yZSBsaWtlbHkgdG8gaW5pdGlhdGUgb3IgcmVjZWl2ZSB0aWVzLCB3aGlsZSBzYW1lWCBtb2RlbHMgdGhlDQpnZW5lcmFsIHRlbmRlbmN5IGZvciBzY2hvbGFycyB0byBjb2xsYWJvcmF0ZSB3aXRoIHNhbWUtZ2VuZGVyIHBlZXJzLg0KDQpUaGUgc3RhdGlzdGljIGZvciB0cmFuc2l0aXZlIHRyaXBsZXRzIGJhc2VkIG9uIGEgZGlmZmVyZW50IGNvdmFyaWF0ZQ0KdmFsdWUgKGhlcmU6IGRpZmZlcmVudCBnZW5kZXIpIHdhcyBvcmlnaW5hbGx5IGluY2x1ZGVkIHRvIGNvbnRyb2wgZm9yDQpyZWxhdGlvbnNoaXBzIG9mIHRyaWFkaWMgbmF0dXJlIChkaWZmWFRyYW5zVHJpcCksIGJ1dCB3aWxsIGJlDQpkaXNyZWdhcmRlZCBpbiB0aGUgaW50ZXJwcmV0YXRpb24gb2YgdGhlIHJlc3VsdHMgc2luY2UgYSBtb3JlDQphcHByb3ByaWF0ZSBjb250cm9sIHN0YXRpc3RpYyB3b3VsZCBoYXZlIGJlZW4gdGhhdCBvZiB0cmFuc2l0aXZlDQp0cmlwbGV0cyAoVHJhbnNUcmlwKSwgYnV0IEkgc2ltcGx5IGxhY2sgdGhlIHRpbWUgdG8gYWRqdXN0IHRoZSBtb2RlbHMuDQoNCmBgYCAgICAgICAgIA0KRXN0aW1hdGVzLCBzdGFuZGFyZCBlcnJvcnMgYW5kIGNvbnZlcmdlbmNlIHQtcmF0aW9zICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEVzdGltYXRlICAgU3RhbmRhcmQgICBDb252ZXJnZW5jZQ0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBFcnJvciAgICAgIHQtcmF0aW8gICAgIA0KUmF0ZSBwYXJhbWV0ZXJzOiAgICANCjAgICAgICAgUmF0ZSBwYXJhbWV0ZXIgICAgICAgICAgICAgICAgICAgICAgIDIuOTIwNCAgKCAwLjQ2MTcgICApICAgICAgICAgICAgICAgDQoNCk90aGVyIHBhcmFtZXRlcnM6ICAgIA0KMS4gZXZhbCBvdXRkZWdyZWUgKGRlbnNpdHkpICAgICAgICAgICAgICAgICAtMS44NjI4ICAoIDEuMTA2MCAgICkgICAgMC4wNzAzIC0tPiBpbnNpZ24uICgtMS42ODQyNjgpICAgIA0KMi4gZXZhbCByZWNpcHJvY2l0eSAgICAgICAgICAgICAgICAgICAgICAgICAgMS4zMzQxICAoIDAuNDU0MyAgICkgICAtMC4wMTUyIC0tPiBzaWduLiAgICAoMi45MzY2MDYpKioqICAgICANCjMuIGV2YWwgaW5kZWdyZWUgLSBwb3B1bGFyaXR5ICAgICAgICAgICAgICAgIDAuMjIwOSAgKCAwLjA0NzAgICApICAgLTAuMDA4MyAtLT4gc2lnbi4gICAgKDQuNykgICAgICoqKg0KNC4gZXZhbCBvdXRkZWdyZWUgLSBhY3Rpdml0eSAgICAgICAgICAgICAgICAtMC4zMDE3ICAoIDAuMjI4NyAgICkgICAgMC4wODA2IC0tPiBpbnNpZ24uICgtMS4zMTkxOTUpICAgIA0KNS4gZXZhbCBuZXR3b3JrLWlzb2xhdGUgICAgICAgICAgICAgICAgICAgICAgNC43NTA3ICAoIDEuNTE5NCAgICkgICAtMC4wMzc5IC0tPiBzaWduLiAgICAoMy4xMjY2OTUpKioqICAgICANCg0KNi4gZXZhbCBnZW5kZXJfUlMgYWx0ZXIgICAgICAgICAgICAgICAgICAgICAgMC4zMjU0ICAoIDAuMjcwMSAgICkgICAgMC4wNDExIC0tPiBpbnNpZ24uICAoMS4yMDQ3MzkpICAgICAgDQo3LiBldmFsIGdlbmRlcl9SUyBlZ28gICAgICAgICAgICAgICAgICAgICAgIC0xLjA2NDIgICggMC42MDU1ICAgKSAgIC0wLjA0MDAgLS0+IGluc2lnbi4gKC0xLjc1NzU1NikgICAgIA0KOC4gZXZhbCBzYW1lIGdlbmRlcl9SUyAgICAgICAgICAgICAgICAgICAgICAgMC42NjM3ICAoIDAuMjY4NSAgICkgICAgMC4wMzA4IC0tPiBzaWduLiAgICAoMi40NzE4ODEpKioqICAgICANCjkuIGV2YWwgdHJhbnNpdGl2ZSB0cmlwbGV0cyBkaWZmLiBnZW5kZXJfUlMgIDIuMTc4NyAgKCAwLjYwMjcgICApICAgIDAuMDQxNiAtLT4gc2lnbi4gICAgKDMuNjE0OSkgICoqKg0KYGBgDQoNClRoZSBtYXhpbXVtIGNvbnZlcmdlbmNlIHJhdGlvIGZvciBtb2RlbCAyIGlzICoqMC4xMzIqKiBhbmQgdGhlIEdvb2RuZXNzDQpvZiBGaXQgb24gdGhlIGluZGVncmVlIGRpc3RyaWJ1dGlvbiBpcyAqKjAuMDk2KiouDQoNCkxvb2tpbmcgYXQgb3VyICdiYXNlLWxpbmUnIG5ldHdvcmsgc3RhdGlzdGljcywgaXQgYmVhcnMgbm90aW5nIHRoYXQgdGhlDQplc3RpbWF0ZSBmb3IgT3V0ZGVncmVlIGlzIG5vdCBzaWduaWZpY2FudCBhbnltb3JlLiBUaGlzIHN0YXRpc3RpYydzDQpwcmlvciBzaWduaWZpY2FuY2UgY2FuIHNlZW1pbmdseSBiZSBleHBsYWluZWQgYnkgYSBwYXJhbWV0ZXIgcmVsYXRpbmcgdG8NCnRoZSBjb3ZhcmlhdGUgZ2VuZGVyIHRoYXQgSSBhZGRlZCB0byB0aGlzIG1vZGVsLiBIb3dldmVyLCB0aGUgZXN0aW1hdGUNCm9mIHRoZSBvdXRkZWdyZWUgcGFyYW1ldGVyIGlzIHN0aWxsIG5lYXJpbmcgdGhlIHNpZ25pZmljYW5jZSAndGhyZXNob2xkJw0KKGIgPSAtMS44NjI4LCBTRSA9IDEuMTA2MCwgYi9TRSA9IC0xLjY4NDI2OCkuDQoNCkNvbXBhcmluZyB0aGlzIG1vZGVsIHRvIHRoZSBwcmlvciBvbmVzLCB3ZSBzZWUgdGhhdCB0aGUgcmVjaXByb2NpdHkNCmVzdGltYXRlIGlzIHN0aWxsIHNpZ25pZmljYW50bHkgcG9zaXRpdmUgKGIgPSAxLjMzNDEsIFNFID0gMC40NTQzKS4NCg0KVGhlIHBhcmFtZXRlcnMgb2YgdGhlIHN0cnVjdHVyYWwgbmV0d29yayBzdGF0aXN0aWNzIGFsc28gc2hvdyBzaW1pbGFyDQpwYXR0ZXJucyBpbiBlc3RpbWF0ZXMgYW5kIHNpZ25pZmljYW5jZSBhcyB0aGV5IGRpZCBpbiBtb2RlbCAxLg0KDQpDb25jZXJuaW5nIHRoZSBhZGRlZCBjb3ZhcmlhdGUgImdlbmRlciIsIHdlIGZpbmQgdGhhdCB0aGUgcGFyYW1ldGVyDQplc3RpbWF0ZXMgZm9yIGJvdGggY292YXJpYXRlLXJlbGF0ZWQgYWN0aXZpdHkgKGVnb1gpICwgcGVydGFpbmluZyB0byB0aGUNCmdlbmRlciBvZiB0aGUgZWdvLCBhbmQgY292YXJpYXRlLXJlbGF0ZWQgcG9wdWxhcml0eSAoYWx0WCksIHJlbGF0aW5nIHRvDQp0aGUgZ2VuZGVyIG9mIHRoZSBhbHRlciwgZG8gKipub3QqKiBzaG93IGFueSBzaWduaWZpY2FuY2UgYW5kIGhlbmNlIGRvDQpub3QgYWxsb3cgZm9yIHJlbGlhYmxlIGluZmVyZW5jZXMuDQoNClRoZSAnc2FtZS1jb3ZhcmlhdGUnIG1lYXN1cmUgKHNhbWVYKSBmb3IgZ2VuZGVyIGlzIHNpZ25pZmljYW50bHkNCnBvc2l0aXZlIChiID0gMC42NjM3LCBTRSA9MC4yNjg1KS4gSXQgcmV2ZWFscyB0aGF0IHNjaG9sYXJzLCBpbmRlZWQsDQpwcmVmZXIgc2FtZS1nZW5kZXIgY29sbGFib3JhdG9ycy4gVGhpcyBzdXBwb3J0cyBIMSwgd2hpY2ggcG9zaXRzIGdlbmRlcg0KaG9tb3BoaWx5IGluIGNvbGxhYm9yYXRpb24gcGF0dGVybnMuDQoNCk1vZGVsIDIgcHJvdmlkZXMgc3Ryb25nIGV2aWRlbmNlIGZvciBnZW5kZXIgaG9tb3BoaWx5IChIMSksIHdpdGgNCnNjaG9sYXJzIG1vcmUgbGlrZWx5IHRvIGNvbGxhYm9yYXRlIHdpdGggc2FtZS1nZW5kZXIgcGVlcnMsIGJ1dCBubw0Kc2lnbmlmaWNhbnQgZGlmZmVyZW5jZXMgaW4gY29sbGFib3JhdGlvbiB0ZW5kZW5jaWVzIGJhc2VkIG9uIHRoZSBnZW5kZXINCm9mIGVnbyBvciBhbHRlci4NCg0KSHlwb3RoZXNpcyBhYm91dCBzdHJ1Y3R1cmFsIGVmZmVjdHMNCg0KLSAgICoqTmV0d29yayBTdGF0aXN0aWNzKio6DQoNCiAgICAtICAgKipzYW1lWCAoR2VuZGVyKSoqOiBUZXN0cyBmb3IgZ2VuZGVyIGhvbW9waGlseSBkaXJlY3RseS4NCg0KICAgIC0gICBTdHJ1Y3R1cmFsIHN0YXRpc3RpY3MgbGlrZSAqKnJlY2lwcm9jaXR5KiosICoqaW5Qb3AqKiwNCiAgICAgICAgKipvdXRBY3QqKiwgYW5kICoqaXNvbGF0ZU5ldCoqIGFyZSBjb250cm9sIHZhcmlhYmxlcyB0byBhY2NvdW50DQogICAgICAgIGZvciBuZXR3b3JrLWxldmVsIGR5bmFtaWNzLg0KDQotICAgKipDb25maXJtYXRpb24qKjoNCg0KICAgIC0gICBBIHNpZ25pZmljYW50IGBzYW1lWGAgY29lZmZpY2llbnQsIGV2ZW4gYWZ0ZXIgaW5jbHVkaW5nDQogICAgICAgIHN0cnVjdHVyYWwgY29udHJvbHMsIHdvdWxkIGNvbmZpcm0gdGhhdCBnZW5kZXIgaG9tb3BoaWx5IGV4aXN0cw0KICAgICAgICBhdCB0aGUgZHlhZGljIGxldmVsLg0KDQogICAgLSAgIElmIGBzYW1lWGAgYmVjb21lcyBub24tc2lnbmlmaWNhbnQgYWZ0ZXIgY29udHJvbHMsIGl0IHN1Z2dlc3RzDQogICAgICAgIHN0cnVjdHVyYWwgZmFjdG9ycywgbm90IGluZGl2aWR1YWwgcHJlZmVyZW5jZXMsIGV4cGxhaW4gZ2VuZGVyDQogICAgICAgIGNsdXN0ZXJpbmcuDQoNCi0tXD4gdW5zdXJlIGlmIHRoaXMgaHBvbGQgdHJ1ZSBmb3IgbWUsIHNpbmNlIEkgYWRkZWQgZ2VuZGVyIG9ubHkgYWZ0ZXINCnJ1bm5pbmcgYSBtb2RlbCB0aGF0IGNvbnRyb2xzIGZvciBzdHJ1Y3R1cmFsIGVmZmVjdHMgc28gSSBjYW5ub3QgcmVhbGx5DQppbmZlciB0aGF0IGJ1dCBpdCdTIHRvbyBsYXRlIHRvIGNoYW5nZSB0aGF0IG5vdy4NCg0KIyMjIC0tLVN0ZXAgMTogRGVmaW5lIFNpZW5hIERhdGEgJiBWYXJpYWJsZXMNCg0KYGBge3IgUlNpZW5hIGRlZmluZSBtMn0NCiMgZGVwZW5kZW50IHZhcmlhYmxlIA0KbmV0cyA8LSBzaWVuYURlcGVuZGVudChuZXRfYXJyYXkpDQoNCiMgcHV0IGdlbmRlciBpbiBvYmplY3QgDQpnZW5kZXIgPC0gZGZfZWdvJGdlbmRlcg0KDQojIGNvdmFyaWF0ZSAxDQpnZW5kZXJfUlMgPC0gY29Db3ZhcihnZW5kZXIpICMgZ2VuZGVyIGFzIGNvdmFyaWF0ZSBpbiBSc2llbmENCg0KIyBkZWZpbmUgZGF0YSBvYmplY3QgDQpteWRhdGFfTTIgPC0gc2llbmFEYXRhQ3JlYXRlKG5ldHMsIGdlbmRlcl9SUykNCg0KYGBgDQoNClByaW50IHNob3J0IGRlc2NyaXB0aXZlIHJlcG9ydA0KDQpgYGB7cn0NCmlmZWxzZSghZGlyLmV4aXN0cygicmVzdWx0cyIpLCBkaXIuY3JlYXRlKCJyZXN1bHRzIiksIEZBTFNFKQ0KDQpgYGANCg0KYGBge3J9DQpwcmludDAxUmVwb3J0KG15ZGF0YV9NMiwgbW9kZWxuYW1lID0gIi4vcmVzdWx0cy9yZXN1bHRzX00yIikgIyBjcmVhdGUgZmlsZSB3aXRoIHJlcG9ydCBpbiByZXN1bHRzIGZvbGRlciANCmBgYA0KDQojIyMgLS0tU3RlcCAyOiBNYWtlIGVmZmVjdHMgb2JqZWN0L3N0cnVjdHVyZQ0KDQpgYGB7ciBSU2llbmEgbXllZmYgbTJ9DQojIGRlZmluZSBlZmZlY3RzIHN0cnVjdHVyZSANCm15ZWZmX00yIDwtIGdldEVmZmVjdHMobXlkYXRhX00yKQ0KYGBgDQoNCiMjIyAtLS1TdGVwIDM6IEFkZCBFZmZlY3RzDQoNCmBgYHtyIGVmZmVjdHMgbTJ9DQpteWVmZl9NMiA8LSBpbmNsdWRlRWZmZWN0cyhteWVmZl9NMiwgaXNvbGF0ZU5ldCwgaW5Qb3AsIG91dEFjdCkgDQoNCm15ZWZmX00yIDwtIGluY2x1ZGVFZmZlY3RzKG15ZWZmX00yLCBlZ29YLCBhbHRYLCBkaWZmWFRyYW5zVHJpcCwgc2FtZVgsIGludGVyYWN0aW9uMSA9ICJnZW5kZXJfUlMiKSANCmBgYA0KDQpgYGB7PWh0bWx9DQo8IS0tDQojIGlzb2xhdGVuZXQ6IGlmIGluZGl2aWR1YWwgaXMgYWxvbmUgdGhleSAibGlrZSB0by90ZW5kIHRvIHN0YXkgYWxvbmUiDQojIGluUG9wOiBwcGwgbGlrZSB0byBjb2xsYWJvcmF0ZSB3aXRoIHBlb3BsZSB3aG8gYXJlIHBvcHVsYXINCg0KIyBzYW1lWA0KIyBzYW1lIGNvdmFyaWF0ZSwgd2hpY2ggY2FuIGFsc28gYmUgY2FsbGVkIGNvdmFyaWF0ZS1yZWxhdGVkIGlkZW50aXR5IChzYW1lWCksIGRlZmluZWQgYnkgdGhlIG51bWJlciBvZiB0aWVzIG9mIGkgdG8gYWxsIG90aGVyIGFjdG9ycyBqIHdobyBoYXZlIGV4YWN0bHkgdGhlIHNhbWUgdmFsdWUgb24gdGhlIGNvdmFyaWF0ZSwgcyBuZXQgaTk1KHgpID0gUCBqeGlqIEl7dmkgPSB2an0sDQojIHdoZXJlIHRoZSBpbmRpY2F0b3IgZnVuY3Rpb24gSXt2aSA9IHZqfSBpcyAxIGlmIHRoZSBjb25kaXRpb24ge3ZpID0gdmp9IGlzIHNhdGlzZmllZCwgYW5kIDAgaWYgaXQgaXMgbm90Ow0KDQoNCiNkaWZmWFRyYW5zVHJpcA0KZGlmZmVyZW50IGNvdmFyaWF0ZSDDlyB0cmFuc2l0aXZlIHRyaXBsZXRzIChkaWZmWFRyYW5zVHJpcCksIGRlZmluZWQgYnkgdGhlIG51bWJlcg0Kb2YgdHJhbnNpdGl2ZSB0cmlwbGV0cyBpIOKGkiBoIOKGkiBqIOKGkCBpIHRoYXQgaGF2ZSBkaWZmZXJlbnQgY292YXJpYXRlIHZhbHVlcyBmb3IgaSBhbmQgaiwNCmRpZmYuIGNvdi4gdmFsdWVzID0gZGlmZiBnZW5kZXINCg0KLS0+DQpgYGANCiMjIyAtLS1TdGVwIDQ6IFNwZWNpZnkgbW9kZWwvYWxnb3JpdGhtDQoNCmBgYHtyIGFsZ28gbTJ9DQoNCm15QWxnb3JpdGhtX00yIDwtIHNpZW5hQWxnb3JpdGhtQ3JlYXRlIChwcm9qbmFtZSA9ICJyZXN1bHRzX00yIikNCg0KYGBgDQoNCiMjIyAtLS1TdGVwIDU6IEVzdGltYXRlIG1vZGVsDQoNCmBgYHtyIGVzdGltYXRlIG0yLCBldmFsID1GQUxTRX0NCiMgZXN0aW1hdGUgdGhlIG1vZGVsIA0KTW9kZWwyIDwtIHNpZW5hMDcobXlBbGdvcml0aG1fTTIsIGRhdGEgPSBteWRhdGFfTTIsIGVmZmVjdHMgPSBteWVmZl9NMiwgcmV0dXJuRGVwcyA9IFRSVUUpDQpNb2RlbDINCiMgbWF4aW11bSBjb252ZXJnZW5jZSA+LjI1DQojIHJ1biBhZ2FpbjoNCk1vZGVsMi4xIDwtIHNpZW5hMDcobXlBbGdvcml0aG1fTTIsIGRhdGEgPSBteWRhdGFfTTIsIGVmZmVjdHMgPSBteWVmZl9NMiwgcHJldkFucz0gTW9kZWwyLCByZXR1cm5EZXBzID0gVFJVRSkNCk1vZGVsMi4xIA0KDQojZnNhdmUoTW9kZWwyLCBmaWxlID0iZXN0aW1hdGVkX00yIikNCiNmc2F2ZShNb2RlbDIuMSwgZmlsZSA9ICJlc3RpbWF0ZWRfTTIuMSIpDQoNCmBgYA0KDQpgYGB7ciBsb2FkIE0yIG91dHB1dCwgZWNobz1GQUxTRX0NCg0KTW9kZWwyIDwtIGZsb2FkKCIuL2RhdGEvcHJvY2Vzc2VkL2VzdGltYXRlZF9NMl8yMDI0MTEyMy5yZGEiKQ0KTW9kZWwyDQoNCk1vZGVsMi4xIDwtIGZsb2FkICgiLi9kYXRhL3Byb2Nlc3NlZC9lc3RpbWF0ZWRfTTIuMV8yMDI0MTEyMy5yZGEiKQ0KTW9kZWwyLjENCmBgYA0KDQojIyMgLS0tU3RlcCA2OiBHT0YgLSBHb29kbmVzcyBvZiBGaXQNCg0KYGBge3IgR09GIE0yfQ0KR09GX00yLjEgPC0gc2llbmFHT0YoTW9kZWwyLjEsIEluZGVncmVlRGlzdHJpYnV0aW9uLCB2ZXJib3NlID0gRkFMU0UsIGpvaW4gPSBUUlVFLCB2YXJOYW1lID0gIm5ldHMiKQ0KDQpwbG90KEdPRl9NMi4xLCBtYWluID0gIkdPRiAtIE1vZGVsIDIgXG4gSW5kZWdyZWUgRGlzdHJpYnV0aW9uIikNCmBgYA0KDQotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0NCg0KIyMgXDxcPiBNb2RlbCAzIC0gRGVwYXJ0bWVudA0KDQpUaGlzIG1vZGVsIGlzIHBhcnRseSBzaW1pbGFyIHRvIE1vZGVsIDIgYnV0IGFkZGl0aW9uYWxseSBob2xkcyB0aGUNCm5ldHdvcmsgc3RhdGlzdGljcyBlZ29YIGFuZCBhbHRYIGZvciB0aGUgbWFpbiBlZmZlY3Qgb2YgZGVwYXJ0bWVudCwgdG8NCmludmVzdGlnYXRlIGRpZmZlcmVuY2VzIGluIHNhbWUtZ2VuZGVyIGNvbGxhYm9yYXRpb24gcGF0dGVybnMgYmFzZWQgb24NCnRoZSB0d28gZGVwYXJ0bWVudHMuDQoNCk9yaWdpbmFsbHksIEkgcGxhbm5lZCB0byBhbHNvIGluY2x1ZGUgYW4gaW50ZXJhY3Rpb24gdGVybSBvZiBkZXBhcnRtX1JTDQphbmQgZ2VuZGVyX1JTIHRvIG9idGFpbiBjbGVhcmVyIGluc2lnaHRzIGludG8gdmFyaWF0aW9ucyBpbiBwYXR0ZXJucyBvZg0KZ2VuZGVyIGhvbW9waGlseSBpbiByZWxhdGlvbiB0byBzY2hvbGFycycgZGVwYXJ0bWVudHMuIEhvd2V2ZXIsIEkgaGF2ZQ0KcmVmcmFpbmVkIGZyb20gYWRkaW5nIGFub3RoZXIgbW9kZWwgdG8gdGhpcyBwcm9qZWN0LiBJIGRlY2lkZWQgYWdhaW5zdA0KdGhpcyBwYXJ0bHkgZHVlIHRvIHRpbWUgY29uc3RyYWludHMgYnV0IEkgYWxzbyByZWFzb24gdGhhdCBJIGNhbiB1c2UgdGhlDQpjb21wYXJpc29uIG9mIG1vZGVsIDIgYW5kIDMgdG8gZXhhbWluZSBjaGFuZ2VzIGluIHRoZSBlc3RpbWF0ZSBvZg0KJ3NhbWVYJyAoZ2VuZGVyKSwgdG8gKnRlbnRhdGl2ZWx5KiBpbmZlciB3aGV0aGVyIHRoZSBkZXBhcnRtZW50IG9mDQpzY2hvbGFycyBtb2RpZmllcyB0aGUgY29sbGFib3JhdGlvbiBwYXR0ZXJucyBhdCBoYW5kLg0KDQpNb2RlbCAzIGhhcyBhIG1heGltdW0gY29udmVyZ2VuY2UgcmF0aW8gb2YgKiowLjE4MioqIGFuZCBhIEdvb2RuZXNzIG9mDQpGaXQgb24gdGhlIGluZGVncmVlIGRpc3RyaWJ1dGlvbiBvZiAqKjAuMTA4KiouDQoNCkludGVyZXN0aW5nbHksIHRoZSBlc3RpbWF0ZSBmb3Igb3V0ZGVncmVlIChkZW5zaXR5KSB0aGF0IGhhZCBsb3N0IGl0cw0Kc2lnbmlmaWNhbmNlIGluIG1vZGVsIDIsIGlzIG5vdyBiYWNrIHRvIGJlaW5nIHNpZ25pZmljYW50IGFuZCBuZWdhdGl2ZQ0KKGIgPSAtNC4zMjMzLCBTRSA9IDEuMDg3MSkuDQoNCkluIHRlcm1zIG9mIGVzdGltYXRlIHNpemUgYW5kIHNpZ25pZmljYW5jZSBvZiB0aGUgc3RydWN0dXJhbCBuZXR3b3JrDQpzdGF0aXN0aWNzIHdlLCBvbmNlIGFnYWluLCBmaW5kIHNpbWlsYXIgcGF0dGVybnMgYXMgaW4gbW9kZWxzIDEgYW5kIDIuDQpIb3dldmVyLCB0aGUgb3V0ZGVncmVlIHBhcmFtZXRlciBoYXMgbm93IHJlYWNoZWQgc2lnbmlmaWNhbmNlIChiID0NCi00LjMyMzMsIFNFID0gMS4wODcxKS4NCg0KV2l0aCByZWdhcmQgdG8gdGhlIG5ldHdvcmsgc3RhdGlzdGljcyBvZiB0aGUgY292YXJpYXRlICdnZW5kZXInLCB3ZSBmaW5kDQp0aGF0IHRoZSBlc3RpbWF0ZXMgcmVsYXRpbmcgdG8gdGhlIGdlbmRlciBvZiBhbiBlZ28gKGVnb1gpIGFuZCB0aGUNCmdlbmRlciBvZiBhbiBhbHRlciAoYWx0WCkgcmVtYWluIG5vbi1zaWduaWZpY2FudC4gVGhlIHBhcmFtZXRlcg0KZXN0aW1hdGVzIGZvciBzYW1lWCByZW1haW5zIHNpZ25pZmljYW50bHkgcG9zaXRpdmUgKGIgPSAwLjY2MzIsIFNFID0NCjAuMjYyMykgYW5kIGFyZSBhbG1vc3QgaWRlbnRpY2FsIHRvIHRob3NlIG9mIG1vZGVsIDIgKGIgPSAwLjY2MzIsIFNFID0NCjAuMjYyMykuIFRoaXMgc3VnZ2VzdHMgdGhhdCBhZGRpbmcgdGhlIGNvdmFyaWF0ZSAnZGVwYXJ0bWVudCcgZGlkIG5vdA0KYnJpbmcgYWJvdXQgYW55IG5vdGV3b3J0aHkgY2hhbmdlcyBpbiBwYXR0ZXJucyBvZiBzY2hvbGFycyBzZWVraW5nIG91dA0Kc2FtZS1nZW5kZXJlZCBzY2hvbGFycyB0byBjb2xsYWJvcmF0ZS4NCg0KV2hlbiBpdCBjb21lcyB0byB0aGUgcGFyYW1ldGVycyBwZXJ0YWluaW5nIHRvIHRoZSBhZGRlZCBjb3ZhcmlhdGUNCidkZXBhcnRtZW50Jywgd2UgZmluZCB0aGF0IGFueSBkaWZmZXJlbmNlcyBpbiBjb2xsYWJvcmF0aW9uIGJhc2VkIG9uIHRoZQ0KZGVwYXJ0bWVudCBvZiBhbiBlZ28gKGVnb1gpIG9yIG9mIGFuIGFsdGVyIChhbHRYKSBhcmUgbm90IHdhcnJhbnRlZCwgYXMNCnRoZSBlc3RpbWF0ZXMgb2YgdGhlc2UgcGFyYW1ldGVycyBhcmUgaW5zaWduaWZpY2FudC4gSG93ZXZlciwgd2UgZmluZCBhDQpzaWduaWZpY2FudGx5IHBvc2l0aXZlIGVzdGltYXRlIGZvciB0aGUgcGFyYW1ldGVyIG9mICdjb3ZhcmlhdGUtcmVsYXRlZA0KaWRlbnRpdHknIChzYW1lWCksIHdoaWNoIGluZGljYXRlcyB0aGF0IHNjaG9sYXJzIGFyZSBtb3JlIGxpa2VseSB0bw0KY29sbGFib3JhdGUgd2l0aCBwZW9wbGUgZnJvbSB0aGVpciBvd24gZGVwYXJ0bWVudCwgaW5kaWNhdGluZw0KKipkZXBhcnRtZW50LWJhc2VkIGhvbW9waGlseSoqLiAoYiA9IDIuNzI0MCwgU0UgPSAwLjcyNzcpLg0KDQpNb2RlbCAzIGhpZ2hsaWdodHMgcGVyc2lzdGVudCBnZW5kZXIgaG9tb3BoaWx5IChIMSkgYWNyb3NzIGRlcGFydG1lbnRzDQpidXQgZG9lcyBub3QgcHJvdmlkZSBldmlkZW5jZSBmb3IgZGlmZmVyZW5jZXMgaW4gZ2VuZGVyIGhvbW9waGlseQ0KYmV0d2VlbiBTb2Npb2xvZ3kgYW5kIFBvbGl0aWNhbCBTY2llbmNlLCBjb250cmFyeSB0byBIMi4NCg0KLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tDQoNCkVzdGltYXRlcyBhbmQgU0VzIG1vZGVsIDM6DQoNCjFcLiBldmFsOiBvdXRkZWdyZWUgKGRlbnNpdHkpIC00LjMyMzMgKCAxLjA4NzEpIFwqXCpcKg0KDQoyXC4gZXZhbDogcmVjaXByb2NpdHkgMS4wNzI1ICggMC40MTc0KSBcKlwqXCoNCg0KM1wuIGV2YWw6IGluZGVncmVlIC0gcG9wdWxhcml0eSAwLjIxMjIgKCAwLjA1MTcpIFwqXCpcKg0KDQo0XC4gZXZhbDogb3V0ZGVncmVlIC0gYWN0aXZpdHkgLTAuMzM2NCAoIDAuMjE4MikgaW5zaWduLiAoLTEuNTQxNzA1KQ0KDQo1XC4gZXZhbDogbmV0d29yay1pc29sYXRlIDQuMjAwNiAoIDEuMzAwNykgXCpcKlwqDQoNCjZcLiBldmFsOiBnZW5kZXJfUlMgYWx0ZXIgMC4zMzU2ICggMC4yNjU5KSBpbnNpZ24gKDEuMjYyMTI5KQ0KDQo3XC4gZXZhbDogZ2VuZGVyX1JTIGVnbyAtMS4wMDY2ICggMC41MTIxKSBpbnNpZ24gKC0xLjk2NTYzMikgYWxtb3N0DQpzaWduaWZpY2FudA0KDQo4XC4gZXZhbDogc2FtZSBnZW5kZXJfUlMgMC42NjMyICggMC4yNjIzKSBzaWduLiAoMi41Mjg0MCkgXCpcKlwqIFwNCihzYW1lWDogY29tcGFyaXNvbiBtb2RlbCAyIGFuZCAzOlwNCmVzdGltYXRlIGdvdCBoYXJkbHkgYW55IHNtYWxsZXIgKDAuNjYzNy0tXD4wLjY2MzIpLCBTRSBnb3QgaGFyZGx5IGFueQ0Kc21hbGxlciAoMC4yNjg1LS1cPjAuMjYyMyksIHNpZ25pZmljYW5jZSB2YWx1ZSBnb3QgYmlnZ2VyDQooMi40Nzg4MS0tXD4yLjUyODQwKSkNCg0KOVwuIGV2YWw6IHRyLiB0cmlwbC4gZGlmZi4gZ2VuZC4gMS41NDc5ICggMC41NDAzKSBzaWduLiAoMi44NjQ4OSkNClwqXCpcKlwNCihkaWZmeFRyVHJpcCBjb21wYXJpc29uIG1vZGVsIDIgYW5kIDM6XA0KZXN0aW1hdGUgZ290IHNtYWxsZXIgYW5kIE5FR0FUSVZFICgyLjE3ODcg4oCTXD4tMS41NDc5KSwgU0UgZ290IHNtYWxsZXINCigwLjYwMjcg4oCTXD4gMC41NDAzKSwgc2lnbmlmaWNhbmNlIHZhbHVlIGdvdCBzbWFsbGVyICgzLjYxNDktLVw+Mi44NjQ4OSkpDQoNCjEwXC4gZXZhbDogZGVwYXJ0bV9SUyBhbHRlciAwLjQxNDEgKCAwLjc1NDYpIGluc2lnbi4gKDAuNTQ5KQ0KDQoxMVwuIGV2YWw6IGRlcGFydG1fUlMgZWdvIC0xLjE1NzMgKCAwLjkxNDgpIGluc2lnbiAoLTEuMjcpDQoNCjEyXC4gZXZhbDogc2FtZSBkZXBhcnRtX1JTIDIuNzI0MCAoIDAuNzI3NykgXCpcKlwqDQoNCi0gICAqKk5ldHdvcmsgU3RhdGlzdGljcyoqOg0KDQogICAgLSAgICoqc2FtZVggKEdlbmRlcikqKjogQ29tcHV0ZSBhbmQgY29tcGFyZSB0aGUgc2l6ZSBhbmQNCiAgICAgICAgc2lnbmlmaWNhbmNlIG9mIHRoZSBjb2VmZmljaWVudCBmb3IgZWFjaCBkZXBhcnRtZW50LiBUaGlzDQogICAgICAgIHJlcXVpcmVzIHNlcGFyYXRlIG1vZGVscyBmb3IgZWFjaCBkZXBhcnRtZW50IG9yIGludGVyYWN0aW9uDQogICAgICAgIHRlcm1zIHRoYXQgYWxsb3cgdGhlIGVmZmVjdCB0byB2YXJ5IGJ5IGRlcGFydG1lbnQuDQoNCi0gICAqKkNvbmZpcm1hdGlvbioqOg0KDQogICAgLSAgIEEgc2lnbmlmaWNhbnRseSBzdHJvbmdlciBwb3NpdGl2ZSBjb2VmZmljaWVudCBmb3IgYHNhbWVYYCBpbg0KICAgICAgICBQb2xpdGljYWwgU2NpZW5jZSBjb21wYXJlZCB0byBTb2Npb2xvZ3kgd291bGQgY29uZmlybSB0aGUNCiAgICAgICAgaHlwb3RoZXNpcy4NCg0KICAgIC0gICBTaW1pbGFyIGNvZWZmaWNpZW50cyBvciByZXZlcnNlZCBwYXR0ZXJucyB3b3VsZCBkaXNjb25maXJtIHRoZQ0KICAgICAgICBoeXBvdGhlc2lzLg0KDQphbHRYIC0gZWdvcyBzZW5kIG1vcmUgdGllcyB3aG8gaGF2ZSBtb3JlIG9uIGdlbmRlciAoYWthLiBnZW5kZXIgPTEpDQooaWlpaXNoIGxvb2sgYXQgZWdvWCBleHBsYW5hbnRpb24sIHRoaXMgaXMgYmFzaWNhbGx5IHRoZSBzYW1lIGJ1dCBpbg0KInJldmVyc2UiLCBha2EgYWJvdXQgcmVjZWl2aW5nIHJhdGhlciB0aGFuIHNlbmRpbmcpDQoNCi0gICBjb3ZhcmlhdGUtYWx0ZXIgb3IgY292YXJpYXRlLXJlbGF0ZWQgcG9wdWxhcml0eSAoYWx0WCksIGRlZmluZWQgYnkNCiAgICB0aGUgc3VtIG9mIHRoZSBjb3ZhcmlhdGUgb3ZlciBhbGwgYWN0b3JzIHRvIHdob20gKioqaSoqKiBoYXMgYSB0aWUsDQotICAgc2FtZSBhcyBlZ29YIGJ1dCBSRUNFSVZJTkcgdGllcw0KDQplZ29YIC0gW2RlZmluaXRpb24/XQ0KDQotICAgY292YXJpYXRlLWVnbyBvciBjb3ZhcmlhdGUtcmVsYXRlZCBhY3Rpdml0eSAoZWdvWCksIGRlZmluZWQgYnkgaeKAmXMNCiAgICBvdXQtZGVncmVlIHdlaWdodGVkIGJ5IGhpcyBjb3ZhcmlhdGUgdmFsdWUsDQotICAgc2luY2UgbWFsZSA9IDEgZWdvWCBvbmx5ICJsb29rcyBhdCIgbWVuJ3MgdGllcw0KLSAgIGlmIGVnb1ggc2lnbmlmaWNhbnQgdGhlbiBtZW4ncyB0aWVzIHNpZ24uIGRpZmYuIGJhc2VkIG9uIHdoZXRoZXIgaXRzDQogICAgdG8gYSBtYW4gb3Igd29tYW4gKGxvb2sgYXQgZGlyZWN0aW9uIG9mIGVmZmVjdCB0byBrbm93IHdoaWNoIGdlbmRlcikNCg0KIyMjIC0tLVN0ZXAgMTogRGVmaW5lIFNpZW5hIERhdGEgJiBWYXJpYWJsZXMNCg0KYGBge3IgUlNpZW5hIGRlZmluZSBtM30NCiMgZGVwZW5kZW50IHZhcmlhYmxlIA0KbmV0cyA8LSBzaWVuYURlcGVuZGVudChuZXRfYXJyYXkpDQoNCiMgcHV0IGdlbmRlciBpbiBvYmplY3QgDQpnZW5kZXIgPC0gZGZfZWdvJGdlbmRlcg0KDQojIGNvdmFyaWF0ZSAxDQpnZW5kZXJfUlMgPC0gY29Db3ZhcihnZW5kZXIpICMgZ2VuZGVyIGFzIGNvdmFyaWF0ZSBpbiBSc2llbmENCg0KI3B1dCBkZXBhcnRtZW50IGluIG9iamVjdCANCmRlcGFydG1lbnQgPC0gZmFjdG9yKGRmX2VnbyRkaXNjaXBsaW5lLjI0LCBsZXZlbHMgPSBjKCJzb2Npb2xvZ3kiLCAicG9saXRpY2FsIHNjaWVuY2UiKSkNCiNtYWtlIG51bWVyaWMNCmRlcGFydG1lbnRfbnVtZXJpYyA8LSBhcy5udW1lcmljKGRlcGFydG1lbnQpIC0gMSAjIHNvY2lvbG9neSA9IDAsIHBvbGl0aWNhbCBzY2llbmNlID0gMQ0KIyBjb3ZhcmlhdGUgMg0KZGVwYXJ0bV9SUyA8LSBjb0NvdmFyKGRlcGFydG1lbnRfbnVtZXJpYykNCg0KIyBkZWZpbmUgZGF0YSBvYmplY3QgDQpteWRhdGFfTTMgPC0gc2llbmFEYXRhQ3JlYXRlKG5ldHMsIGdlbmRlcl9SUywgZGVwYXJ0bV9SUykNCg0KYGBgDQoNClByaW50IHNob3J0IGRlc2NyaXB0aXZlIHJlcG9ydA0KDQpgYGB7cn0NCmlmZWxzZSghZGlyLmV4aXN0cygicmVzdWx0cyIpLCBkaXIuY3JlYXRlKCJyZXN1bHRzIiksIEZBTFNFKQ0KDQpgYGANCg0KYGBge3J9DQpwcmludDAxUmVwb3J0KG15ZGF0YV9NMywgbW9kZWxuYW1lID0gIi4vcmVzdWx0cy9yZXN1bHRzX00zIikgIyBjcmVhdGUgZmlsZSB3aXRoIHJlcG9ydCBpbiByZXN1bHRzIGZvbGRlciANCmBgYA0KDQojIyMgLS0tU3RlcCAyOiBNYWtlIGVmZmVjdHMgb2JqZWN0L3N0cnVjdHVyZQ0KDQpgYGB7ciBSU2llbmEgbXllZmYgbTN9DQojIGRlZmluZSBlZmZlY3RzIHN0cnVjdHVyZSANCm15ZWZmX00zIDwtIGdldEVmZmVjdHMobXlkYXRhX00zKQ0KYGBgDQoNCiMjIyAtLS1TdGVwIDM6IEFkZCBFZmZlY3RzDQoNCmBgYHtyIGVmZmVjdHMgbTN9DQpteWVmZl9NMyA8LSBpbmNsdWRlRWZmZWN0cyhteWVmZl9NMywgaXNvbGF0ZU5ldCwgaW5Qb3AsIG91dEFjdCkgIyBtb2RlbCAxDQoNCm15ZWZmX00zIDwtIGluY2x1ZGVFZmZlY3RzKG15ZWZmX00zLCBlZ29YLCBhbHRYLCBkaWZmWFRyYW5zVHJpcCwgc2FtZVgsIGludGVyYWN0aW9uMSA9ICJnZW5kZXJfUlMiKSAjbW9kZWwgMg0KDQpteWVmZl9NMyA8LSBpbmNsdWRlRWZmZWN0cyhteWVmZl9NMywgZWdvWCwgYWx0WCwgc2FtZVgsIGludGVyYWN0aW9uMSA9ICJkZXBhcnRtX1JTIikgI21vZGVsIDMNCg0KYGBgDQoNCmBgYHs9aHRtbH0NCjwhLS0NCiMgaXNvbGF0ZW5ldDogaWYgaW5kaXZpZHVhbCBpcyBhbG9uZSB0aGV5ICJsaWtlIHRvL3RlbmQgdG8gc3RheSBhbG9uZSINCiMgaW5Qb3A6IHBwbCBsaWtlIHRvIGNvbGxhYm9yYXRlIHdpdGggcGVvcGxlIHdobyBhcmUgcG9wdWxhcg0KDQojIHNhbWVYDQojIHNhbWUgY292YXJpYXRlLCB3aGljaCBjYW4gYWxzbyBiZSBjYWxsZWQgY292YXJpYXRlLXJlbGF0ZWQgaWRlbnRpdHkgKHNhbWVYKSwgZGVmaW5lZCBieSB0aGUgbnVtYmVyIG9mIHRpZXMgb2YgaSB0byBhbGwgb3RoZXIgYWN0b3JzIGogd2hvIGhhdmUgZXhhY3RseSB0aGUgc2FtZSB2YWx1ZSBvbiB0aGUgY292YXJpYXRlLCBzIG5ldCBpOTUoeCkgPSBQIGp4aWogSXt2aSA9IHZqfSwNCiMgd2hlcmUgdGhlIGluZGljYXRvciBmdW5jdGlvbiBJe3ZpID0gdmp9IGlzIDEgaWYgdGhlIGNvbmRpdGlvbiB7dmkgPSB2an0gaXMgc2F0aXNmaWVkLCBhbmQgMCBpZiBpdCBpcyBub3Q7DQoNCg0KI2RpZmZYVHJhbnNUcmlwDQpkaWZmZXJlbnQgY292YXJpYXRlIMOXIHRyYW5zaXRpdmUgdHJpcGxldHMgKGRpZmZYVHJhbnNUcmlwKSwgZGVmaW5lZCBieSB0aGUgbnVtYmVyDQpvZiB0cmFuc2l0aXZlIHRyaXBsZXRzIGkg4oaSIGgg4oaSIGog4oaQIGkgdGhhdCBoYXZlIGRpZmZlcmVudCBjb3ZhcmlhdGUgdmFsdWVzIGZvciBpIGFuZCBqLA0KZGlmZi4gY292LiB2YWx1ZXMgPSBkaWZmIGdlbmRlcg0KDQotLT4NCmBgYA0KIyMjIC0tLVN0ZXAgNDogU3BlY2lmeSBtb2RlbC9hbGdvcml0aG0NCg0KYGBge3IgYWxnbyBtM30NCg0KbXlBbGdvcml0aG1fTTMgPC0gc2llbmFBbGdvcml0aG1DcmVhdGUgKHByb2puYW1lID0gInJlc3VsdHNfTTMiKQ0KDQpgYGANCg0KIyMjIC0tLVN0ZXAgNTogRXN0aW1hdGUgbW9kZWwNCg0KYGBge3IgZXN0aW1hdGUgbTMsIGV2YWwgPUZBTFNFfQ0KIyBlc3RpbWF0ZSB0aGUgbW9kZWwgDQpNb2RlbDMgPC0gc2llbmEwNyhteUFsZ29yaXRobV9NMywgZGF0YSA9IG15ZGF0YV9NMywgZWZmZWN0cyA9IG15ZWZmX00zLCByZXR1cm5EZXBzID0gVFJVRSkNCk1vZGVsMw0KDQojaWYgbWF4aW11bSBjb252ZXJnZW5jZSA+LjI1OiBydW4gYWdhaW4NCk1vZGVsMy4xIDwtIHNpZW5hMDcobXlBbGdvcml0aG1fTTMsIGRhdGEgPSBteWRhdGFfTTMsIGVmZmVjdHMgPSBteWVmZl9NMywgcHJldkFucz0gTW9kZWwzLCByZXR1cm5EZXBzID0gVFJVRSkNCk1vZGVsMy4xIA0KDQojZnNhdmUoTW9kZWwzLCBmaWxlID0iZXN0aW1hdGVkX00zIikNCiNmc2F2ZShNb2RlbDMuMSwgZmlsZSA9ICJlc3RpbWF0ZWRfTTMuMSIpDQoNCmBgYA0KDQpgYGB7ciBsb2FkIE0zIG91dHB1dCwgZWNobz1GQUxTRX0NCg0KTW9kZWwzIDwtIGZsb2FkKCIuL2RhdGEvcHJvY2Vzc2VkL2VzdGltYXRlZF9NM18yMDI0MTEyMy5yZGEiKQ0KTW9kZWwzDQoNCk1vZGVsMy4xIDwtIGZsb2FkICgiLi9kYXRhL3Byb2Nlc3NlZC9lc3RpbWF0ZWRfTTMuMV8yMDI0MTEyMy5yZGEiKQ0KTW9kZWwzLjENCmBgYA0KDQojIyMgLS0tU3RlcCA2OiBHT0YgLSBHb29kbmVzcyBvZiBGaXQNCg0KYGBge3IgR09GIE0zfQ0KR09GX00zLjEgPC0gc2llbmFHT0YoTW9kZWwzLjEgLCBJbmRlZ3JlZURpc3RyaWJ1dGlvbiwgdmVyYm9zZSA9IEZBTFNFLCBqb2luID0gVFJVRSwgdmFyTmFtZSA9ICJuZXRzIikNCg0KcGxvdChHT0ZfTTMuMSwgbWFpbiA9ICJHT0YgLSBNb2RlbCAzIFxuIEluZGVncmVlIERpc3RyaWJ1dGlvbiIpDQpgYGANCg0KLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tDQoNCiMjIFw8XD4gTW9kZWwgNCAtIEgtSW5kZXgNCg0KVGhpcyBtb2RlbCBmdXJ0aGVyIGJ1aWxkcyBvbiB0aGUgcHJpb3IgbW9kZWwgYW5kIGFsc28gaW5jbHVkZXMgbmV0d29yaw0Kc3RhdGlzdGljcyBvZiB0aGUgY292YXJpYXRlIEgtSW5kZXgsIG5hbWVseSBlZ29YLCBhbHRYIGFuZCBpblBvcFguIEJ5DQphZGRpbmcgdGhlc2UgZWZmZWN0cyB3ZSBjYW4gbW9kZWwgaG93IHRoZSBoLWluZGV4IG9mIGEgc2Nob2xhcg0KaW5mbHVlbmNlcyB0aGVpciBwcmVmZXJlbmNlcyByZWdhcmRpbmcgc2FtZS1nZW5kZXJlZCBjb2xsYWJvcmF0aW9ucy4NClNpbWlsYXJseSwgdG8gbW9kZWwgMywgdGhpcyBtb2RlbCBjb3VsZCBoYXZlIHByb2ZpdGVkIGZyb20gYSAnZm9sbG93LXVwJw0KbW9kZWwgdGhhdCBpbmNsdWRlcyBhbmQgaW50ZXJhY3Rpb24gdGVybSBiZXR3ZWVuIGgtaW5kZXggYW5kIGdlbmRlciB0bw0KYmV0dGVyIGluZmVyIGFib3V0IHRoZWlyIGluZmx1ZW5jZXMuIFRoZSBzYW1lIHJlYXNvbmluZyBmb3IgbXkgZGVjaXNpb24NCnRvIHN0aWNrIHdpdGggb25lIG1vZGVsIHByaW9yIGFsc28gYXBwbGllcyB0byB0aGlzIGNhc2UuIEVnb1ggZm9yIHRoaXMNCmNvdmFyaWF0ZSBleGFtaW5lcyBob3cgdGhlIGgtaW5kZXggb2YgYSBzY2hvbGFyIGFmZmVjdHMgdGhlaXINCmNvbGxhYm9yYXRpb24gYmVoYXZpb3IsIHdoaWxlIEFsdFggZXhhbWluZXMgaG93IHRoZSBoLWluZGV4IG9mIHBvdGVudGlhbA0KY29sbGFib3JhdG9ycyBhZmZlY3RzIHRoZWlyIGF0dHJhY3RpdmVuZXNzIGFzIHBhcnRuZXJzLiBXaXRoIHRoZSBoZWxwIG9mDQp0aGVzZSBlZmZlY3RzIHdlIGNhbiB0ZXN0IHByZXN0aWdpb3VzIHNjaG9sYXJzIGFyZSBtb3JlIGxpa2VseSB0bw0KaW5pdGlhdGUgb3IgcmVjZWl2ZSB0aWVzLiBCeSBsb29raW5nIGF0IGluLWRlZ3JlZSBwb3B1bGFyaXR5IHdlaWdodGVkIGJ5DQpzZW5kZXLigJlzIEgtaW5kZXggKGluUG9wWGkpIHdlIGNhbiBhc3Nlc3NlIHdoZXRoZXIgYSBoaWdoIGgtaW5kZXgNCmluY3JlYXNlcyB0aGUgbGlrZWxpaG9vZCBvZiBiZWluZyBzb3VnaHQgb3V0IGFzIGEgY29sbGFib3JhdG9yLlwNCg0KYGBgICAgICAgICAgDQpFc3RpbWF0ZXMsIHN0YW5kYXJkIGVycm9ycyBhbmQgY29udmVyZ2VuY2UgdC1yYXRpb3MNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRXN0aW1hdGUgICBTdGFuZGFyZCAgIENvbnZlcmdlbmNlDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRXJyb3IgICAgICB0LXJhdGlvDQpSYXRlIHBhcmFtZXRlcnM6ICANCiAgMCAgICAgIFJhdGUgcGFyYW1ldGVyICAgICAgICAgICAgICAgICAgICAgICAyLjY4OTEgICggMC4zNjc1ICAgKSAgICAgICAgICAgICAgIA0KDQpPdGhlciBwYXJhbWV0ZXJzOiAgICAgDQogICAxLiBldmFsIG91dGRlZ3JlZSAoZGVuc2l0eSkgICAgICAgICAgICAgICAgIC0yLjc2OTMgICggMS45MjA1ICAgKSAgICAwLjA2OTggLS0+IGluc2lnbi4gKC0xLjQ0MTk2OCkgICAgICAgDQogICAyLiBldmFsIHJlY2lwcm9jaXR5ICAgICAgICAgICAgICAgICAgICAgICAgICAyLjE3NzAgICggMC41OTYwICAgKSAgICAwLjA5MTkgLS0+IHNpZ24uICAgICgzLjY1MjY4NSkqKiogICAgICANCiAgIDMuIGV2YWwgaW5kZWdyZWUgLSBwb3B1bGFyaXR5ICAgICAgICAgICAgICAgLTAuMDY1MyAgKCAwLjE2NTQgICApICAgLTAuMDEwNCAtLT4gaW5zaWduLiAoLTAuMzk0ODAwNSkgICAgICANCiAgIDQuIGV2YWwgb3V0ZGVncmVlIC0gYWN0aXZpdHkgICAgICAgICAgICAgICAgLTAuNjg1MSAgKCAwLjQwMjkgICApICAgIDAuMDUyNyAtLT4gaW5zaWduLiAoLTEuNzAwNDIyKSAgICAgIA0KICAgNS4gZXZhbCBuZXR3b3JrLWlzb2xhdGUgICAgICAgICAgICAgICAgICAgICAgNS40NjM0ICAoIDIuMjc3MCAgICkgICAgMC4wMDI4IC0tPiBzaWduLiAgICAoMi4zOTkzODUpKioqICAgICAgDQogICA2LiBldmFsIGdlbmRlcl9SUyBhbHRlciAgICAgICAgICAgICAgICAgICAgIC0wLjA5MDMgICggMC4zMzcyICAgKSAgICAwLjAxMjkgLS0+IGluc2lnbi4gKC0wLjI2Nzc5MzYpICAgICAgIA0KICAgNy4gZXZhbCBnZW5kZXJfUlMgZWdvICAgICAgICAgICAgICAgICAgICAgICAgMC4yOTkzICAoIDAuNDkzNCAgICkgICAtMC4wNTAzIC0tPiBpbnNpZ24uICgwLjYwNjYwNzIpICAgICAgDQogICA4LiBldmFsIHNhbWUgZ2VuZGVyX1JTICAgICAgICAgICAgICAgICAgICAgICAwLjY4MjAgICggMC4yODA0ICAgKSAgICAwLjAyMDEgLS0+IHNpZ24uICAgKDIuNDMyMjQpICAqKiogICAgICAgDQogICA5LiBldmFsIHRyYW5zaXRpdmUgdHJpcGxldHMgZGlmZi4gZ2VuZGVyX1JTICAyLjQ4NzEgICggMC42NjcwICAgKSAgICAwLjA1MDUgLS0+IHNpZ24uICAgKDMuNzI4Nzg2KSAqKiogICAgDQogIDEwLiBldmFsIGRlcGFydG1fUlMgYWx0ZXIgICAgICAgICAgICAgICAgICAgICAwLjM5MjkgICggMC42MTI4ICAgKSAgIC0wLjAwNjEgLS0+IGluc2lnbi4gKDAuNjQxMTU1NCkgICAgDQogIDExLiBldmFsIGRlcGFydG1fUlMgZWdvICAgICAgICAgICAgICAgICAgICAgIC0xLjQ2NTIgICggMC42OTYzICAgKSAgIC0wLjAxMTUgLS0+IFNJR04uICAgKC0yLjEwNDI2NSkqKioNCiAgMTIuIGV2YWwgc2FtZSBkZXBhcnRtX1JTICAgICAgICAgICAgICAgICAgICAgIDIuNjMyNyAgKCAwLjYwODAgICApICAgIDAuMDE3MyAtLT4gc2lnbiAgICAoNC4zMzAwOTkpICoqKiAgICANCiAgMTMuIGV2YWwgaF9pbmRleF9SUyBhbHRlciAgICAgICAgICAgICAgICAgICAgIDAuMDgyOSAgKCAwLjAzNjQgICApICAgLTAuMDAzMSAtLT4gU0lHTiAgICAoMi4yNzc0NzMpICoqKg0KICAxNC4gZXZhbCBoX2luZGV4X1JTIGVnbyAgICAgICAgICAgICAgICAgICAgICAtMC4xNTkxICAoIDAuMDc0NCAgICkgICAgMC4wMTYxIC0tPiBTSUdOLiAgKC0yLjEzODQ0MSkgKioqICAgDQogIDE1LiBldmFsIGluZC4gcG9wLl4oMS8xKSB3ZWlnaHRlZCBoX2luZGV4X1JTIC0wLjAyODcgICggMC4wNTcwICAgKSAgIC0wLjAxMjkgLS0+IGluc2lnbi4oLTAuNTAzNTA4OCkNCmBgYA0KDQpNb2RlbCA0IGhhcyBhIG1heGltdW0gY29udmVyZ2VuY2UgcmF0aW8gb2YgKiowLjIzLCoqIGFuZCBhIGEgR29vZG5lc3Mgb2YNCkZpdCBvbiB0aGUgaW5kZWdyZWUgZGlzdHJpYnV0aW9uIG9mICoqMC4xOTcqKi4NCg0KU3RydWN0dXJhbCBuZXR3b3JrIHN0YXRpc3RpY3M6DQoNClRoZSBlc3RpbWF0ZSBmb3Igb3V0ZGVncmVlIGlzIG5lZ2F0aXZlIGJ1dCBub3Qgc2lnbmlmaWNhbnQuIFRoaXMNCnN1Z2dlc3RzIHRoYXQsIGFmdGVyIGFjY291bnRpbmcgZm9yIG90aGVyIHZhcmlhYmxlcywgdGhlIGJhc2VsaW5lDQpsaWtlbGlob29kIG9mIGZvcm1pbmcgdGllcyByZW1haW5zIGxvdyBhbmQgaXMgbm90IGEgbWFqb3IgZHJpdmVyIG9mDQpjb2xsYWJvcmF0aW9uIHBhdHRlcm5zLiBSZWNpcHJvY2l0eSBoYXMgYSBzaWduaWZpY2FudCBwb3NpdGl2ZSBlc3RpbWF0ZQ0KKGIgPSAyLjE3NzAsIFNFID0gMC41OTYwKS4gVGhpcyByZWZsZWN0cyBhIHN0cm9uZyB0ZW5kZW5jeSBmb3IgbXV0dWFsDQpjb2xsYWJvcmF0aW9ucywgbWVhbmluZyBpZiBvbmUgc2Nob2xhciBjb2xsYWJvcmF0ZXMgd2l0aCBhbm90aGVyLCB0aGUNCmxhdHRlciBpcyBsaWtlbHkgdG8gY29sbGFib3JhdGUgYmFjayAoZHlhZGljIHJlY2lwcm9jaXR5KS4gVGhlIHBhcmFtdGVycw0KSW5kZWdyZWUgUG9wdWxhcml0eSBhbmQgT3V0ZGVncmVlIEFjdGl2aXR5IGFyZSBib3RoIGluc2lnbmlmaWNhbnQsDQpzdWdnZXN0aW5nIHRoYXQgbmVpdGhlciB0aGUgdGVuZGVuY3kgdG8gcmVjZWl2ZSBtYW55IGNvbGxhYm9yYXRpb25zDQooaW5kZWdyZWUgcG9wdWxhcml0eSkgbm9yIHRoZSB0ZW5kZW5jeSB0byBpbml0aWF0ZSB0aGVtIChvdXRkZWdyZWUNCmFjdGl2aXR5KSBpcyBzaWduaWZpY2FudGx5IHJlbGV2YW50IHRvIHRoZSBuZXR3b3JrIHN0cnVjdHVyZS4gVGhlDQpuZXR3b3JrIGlzb2xhdGUgZXN0aW1hdGUgaXMsIG9uY2UgYWdhaW4sIHNpZ25pZmljYW50bHkgcG9zaXRpdmUgKCBiID0NCjUuNDYzNCwgU0UgPSAyLjI3NzApLCBpbmRpY2F0aW5nIHRoYXQgYXMgaXNvbGF0ZXMgdGVuZCB0byByZW1haW4NCmlzb2xhdGVkLg0KDQpHZW5kZXI6DQoNClNpbWlsYXIgdG8gQWx0WCBhbmQgRWdvWCBpbiBwcmlvciBtb2RlbHMsIGJvdGggYW4gYWx0ZXIncyBnZW5kZXIgKGIgPQ0KLTAuMDkwMywgU0UgPSAwLjMzNzIpIGFuZCBhbiBlZ28ncyBnZW5kZXIgKGIgPSAwLjI5OTMsIFNFID0gMC40OTM0KQ0Kc3RpbGwgaGF2ZSBpbnNpZ25pZmljYW50IGVmZmVjdHMuIFRoZSBwYXJhbWV0ZXIgU2FtZVggc2hvd3MgYQ0Kc2lnbmlmaWNhbnQgcG9zaXRpdmUgZXN0aW1hdGUgKGIgPSAwLjY4MjAsIFNFID0gMC4yODA0KSB3aGljaCBiYXJlbHkNCmRpZmZlcnMgZnJvbSB0aGUgdHdvIHByaW9yIG1vZGVscy4gVGhpcyBzdWdnZXN0cyB0aGF0IGFkZGluZyB0aGUNCmNvdmFyaWF0ZSAnSC1JbmRleCcgZGlkIG5vdCBwcm9tcHQgYW55IG1ham9yIGNoYW5nZXMgaW4gc2Nob2xhcnMnDQpwcmVmZXJlbmNlcyBmb3Igc2FtZS1nZW5kZXJlZCBjb2xsYWJvcmF0b3JzLg0KDQpEZXBhcnRtZW50Og0KDQpXaGlsZSBhbiBhbHRlcidzIGRlcGFydG1lbioqdCoqIChBbHRYKSByZW1haW5lZCBpbnNpZ25pZmljYW50IHRvIHRoZQ0KY29sbGFib3JhdGlvbiBwYXR0ZXJucywgdGhlIGVzdGltYXRlcyBmb3IgYW4gZWdvJ3MgZGVwYXJ0bWVudCBjaGFuZ2VkDQppbmNvbXBhcmlzb24gdG8gdGhlIHByaW9yIG1vZGVsLiBJbiB0aGlzIG1vZGVsLCBlZ29YIHNlZW1zIHRvIGJlIG9mDQpzaWduaWZpY2FudCByZWxldmFuY2UgKGIgPSAtMS40NjUyLCBTRSA9IDAuNjk2MyksIHdpdGggaXRzIG5lZ2F0aXZlDQplc3RpbWF0ZSBpbmRpY2F0aW5nIHRoYXQsIG9uY2UgZWZmZWN0cyBvZiBoLWluZGV4IGFyZSBjb250cm9sbGVkIGZvciwNCnNjaG9sYXJzIGZyb20gdGhlIHBvbGl0aWNhbCBzY2llbmNlIChjb2RlZCBhcyAxKSBkZXBhcnRtZW50IGhhdmUgYSBsb3dlcg0KdGVuZGVuY3kgdG8gaW5pdGlhdGUgY29sbGFib3JhdGlvbnMgdGhhbiBzY2hvbGFycyBmcm9tIHRoZSBzb2Npb2xvZ3kNCmRlcGFydG1lbnQgKGNvZGVkIGFzIDApLiBcDQpTaW1pbGFyIHRvIHRoZSBwcmlvciBtb2RlbCwgdGhlIHNhbWVYIHBhcmFtZXRlciBmb3IgZGVwYXJ0bWVudCBzaG93cyBhDQpzaWduaWZpY2FudCBwb3NpdGl2ZSBlc3RpbWF0ZSAoYiA9IDIuNjMyNywgU0UgPSAwLjYwODApIHNjaG9sYXJzIGFyZQ0Kc3RpbGwgbW9yZSBsaWtlbHkgdG8gY29sbGFib3JhdGUgd2l0aCBvdGhlcnMgZnJvbSB0aGUgc2FtZSBkZXBhcnRtZW50Lg0KDQpILUluZGV4Og0KDQpCb3RoIGFuIGFsdGVyJ3MgYW5kIGFuIGVnbydzIEgtSW5kZXggc2VlbSB0byBiZSByZWxldmFudCBpbg0KY29sbGFib3JhdGlvbiBwcmVmZXJlbmNlcy4gVGhlIHNpZ25pZmljYW50IGFuZCBwb3NpdGl2ZSBlc3RpbWF0ZW9mIEFsdFgNCihiID0gMC4wODI5LCBTRSA9IDAuMDM2NCkgc3VnZ2VzdCB0aGF0IHNjaG9sYXJzIHdpdGggaGlnaGVyIGgtaW5kZXggYXJlDQptb3JlIHByZWZlcnJlZCBhcyBjb2xsYWJvcmF0b3JzLiBUaGUgZWdvWCBlc3RpbWF0ZSBpcyBzaWduaWZpY2FudCBhbmQNCm5lZ2F0aXZlIChiID0gLTAuMTU5MSwgU0UgPSAwLjA3NDQpIHN1Z2dlc3RpbmcgdGhhdCBzY2hvbGFycyB3aXRoIGhpZ2hlcg0KaC1pbmRleCBhcmUgbGVzcyBsaWtlbHkgdG8gaW5pdGlhdGUgY29sbGFib3JhdGlvbnMuDQoNCipEaXNjdXNzaW9uIHBhcnQgYWJvdXQgZWdvWCBoLmluZGV4OiAqKiJUaGlzIGlzIGluIGxpbmUgd2l0aCB0aGVvcmllcyBvZg0KcHJlZmVyZW50aWFsIGF0dGFjaG1lbnQgYW5kIHVwd2FyZCBtb2JpbGl0eSwgYmVjYXVzZSBhcyBlZ29zIHdpdGggaGlnaGVyDQpwcmVzdGlnZSB3aWxsIGFyZSBtb3JlIGxpa2VseSB0byByZWNlaXZlIHJlcXVlc3QgZm9yIGNvbGxhYm9yYXRpb24NCnJhdGhlciB0aGVuIHNlbmRpbmcgcmVxdWVzdCBmb3IgY29sbGFib3JhdGlvbi4iIC0gTmllbHMqKioNCg0KVGhlIGVzdGltYXRlIGZvciB0aGUgSW5kZWdyZWUgUG9wdWxhcml0eSB3ZWlnaHRlZCBieSBoLWluZGV4IGlzDQppbnNpZ25pZmljYW50LCBzdWdnZXN0aW5nIHRoYXQgaGlnaC1wcmVzdGlnZSBpbmRpdmlkdWFscyAoYXMgbWVhc3VyZWQgYnkNCnRoZWlyIGgtaW5kZXgpIGRvIG5vdCBzaWduaWZpY2FudGx5IHJlY2VpdmUgbW9yZSBpbmRlZ3JlZXMNCg0KVGhlIHJlc3VsdHMgcGFydGlhbGx5IHN1cHBvcnQgKipINCoqLCBhcyB0aGUgaC1pbmRleCBpcyBzaG93biB0bw0KaW5mbHVlbmNlIGNvbGxhYm9yYXRpb24gcGF0dGVybnMsIHdpdGggcHJlc3RpZ2lvdXMgc2Nob2xhcnMgYmVpbmcgbW9yZQ0KbGlrZWx5IHRvIGF0dHJhY3QgY29sbGFib3JhdGlvbnMgYXMgYWx0ZXJzIGJ1dCBsZXNzIGxpa2VseSB0byBpbml0aWF0ZQ0KdGhlbSBhcyBlZ29zLiBIb3dldmVyLCBnZW5kZXIgaG9tb3BoaWx5IHJlbWFpbnMgc2lnbmlmaWNhbnQgZXZlbiBhZnRlcg0KY29udHJvbGxpbmcgZm9yIHRoZSBoLWluZGV4LCBzdWdnZXN0aW5nIHRoYXQgcHJlc3RpZ2UgZG9lcyBub3QNCnN1YnN0YW50aWFsbHkgd2Vha2VuIHRoZSBpbmZsdWVuY2Ugb2YgZ2VuZGVyIGhvbW9waGlseSBpbiBjby1hdXRob3JzaGlwDQpuZXR3b3Jrcy4NCg0KVHJhbnNpdGl2ZSBUcmlwbGV0cyAoRGlmZiBHZW5kZXIpOiBBIHBvc2l0aXZlIHNpZ25pZmljYW50IGVmZmVjdA0KKGI9Mi40ODcxLCBTRSA9IDAuNjY3MCkuIFRoaXMgc3VnZ2VzdHMgdGhhdCB0cmFuc2l0aXZlIHN0cnVjdHVyZXMgKHdoZXJlDQp0d28gcGVvcGxlIGNvbm5lY3RlZCB0byBhIGNvbW1vbiB0aGlyZCBwYXJ0eSBjb2xsYWJvcmF0ZSkgYXJlIG1vcmUNCmxpa2VseSBldmVuIGFjcm9zcyBnZW5kZXIgZGlmZmVyZW5jZXMuIENvdWxkIGJlIGEgcG90ZW50aWFsDQpjb3VudGVyYmFsYW5jZSB0byBob21vcGhpbHkuDQoNClItTWFudWFsOiBpbi1kZWdyZWUgcG9wdWxhcml0eSB3ZWlnaHRlZCBieSBzZW5kZXLigJlzIFYgKGluUG9wWCkNCmRlZmluZWQgYnkgdGhlIHN1bSBvZiB2YWx1ZXMgb2YgViBmb3IgYWN0b3JzIGggZm9yIHdoaWNoIHRoZXJlIGFyZSB0aWVzDQppIOKGkiBqIOKGkCBoDQoNCm5vdGUgdGhhdCB0byB1c2UgdGhpcyBlZmZlY3QgZm9yIHAgPSAyIHRoZSB2YXJpYWJsZSBWIG11c3QgYmUNCm5vbm5lZ2F0aXZlLCB3aGljaA0KaW1wbGllcyB0aGF0IGl0IG11c3QgYmUgbm9uLWNlbnRlcmVkOw0KZnVydGhlciBub3RlIHRoYXQgaWYgViBpcyBhIGJlaGF2aW9yYWwgdmFyaWFibGUsIGl0IHdpbGwgYmUgdXNlZCBpbiB0aGUNCmNlbnRlcmVkIHZlcnNpb24sDQpzbyB0aGF0IHAgbXVzdCBiZSAxOyBpZiB3ZWlnaHRpbmcgYnkgYSBub24tY2VudGVyZWQgYmVoYXZpb3JhbCB2YXJpYWJsZQ0KaXMgZGVzaXJlZCwgYQ0KbmV3IGVmZmVjdCBpcyBuZWNlc3Nhcnk7DQoNCiMjIyAtLS1TdGVwIDE6IERlZmluZSBTaWVuYSBEYXRhICYgVmFyaWFibGVzDQoNCmBgYHtyIFJTaWVuYSBkZWZpbmUgbTR9DQojIGRlcGVuZGVudCB2YXJpYWJsZSANCm5ldHMgPC0gc2llbmFEZXBlbmRlbnQobmV0X2FycmF5KQ0KDQojIHB1dCBnZW5kZXIgaW4gb2JqZWN0IA0KZ2VuZGVyIDwtIGRmX2VnbyRnZW5kZXINCiMgY292YXJpYXRlIDENCmdlbmRlcl9SUyA8LSBjb0NvdmFyKGdlbmRlcikgIyBnZW5kZXIgYXMgY292YXJpYXRlIGluIFJzaWVuYQ0KDQojcHV0IGRlcGFydG1lbnQgaW4gb2JqZWN0IA0KZGVwYXJ0bWVudCA8LSBmYWN0b3IoZGZfZWdvJGRpc2NpcGxpbmUuMjQsIGxldmVscyA9IGMoInNvY2lvbG9neSIsICJwb2xpdGljYWwgc2NpZW5jZSIpKQ0KI21ha2UgbnVtZXJpYw0KZGVwYXJ0bWVudF9udW1lcmljIDwtIGFzLm51bWVyaWMoZGVwYXJ0bWVudCkgLSAxICMgc29jaW9sb2d5ID0gMCwgcG9saXRpY2FsIHNjaWVuY2UgPSAxDQojIGNvdmFyaWF0ZSAyDQpkZXBhcnRtX1JTIDwtIGNvQ292YXIoZGVwYXJ0bWVudF9udW1lcmljKQ0KDQojIHB1dCBoLWluZGV4IGluIG9iamVjdCANCmhfaW5kZXggPC0gZGZfZWdvJGhfaW5kZXgNCmRmX2VnbyRoX2luZGV4DQojIGNvdmFyaWF0ZSAzDQpoX2luZGV4X1JTIDwtIGNvQ292YXIoaF9pbmRleCkgIyBoX2luZGV4IGFzIGNvdmFyaWF0ZSBpbiBSU2llbmENCg0KIyBkZWZpbmUgZGF0YSBvYmplY3QgDQpteWRhdGFfTTQgPC0gc2llbmFEYXRhQ3JlYXRlKG5ldHMsIGdlbmRlcl9SUywgZGVwYXJ0bV9SUywgaF9pbmRleF9SUykNCg0KYGBgDQoNClByaW50IHNob3J0IGRlc2NyaXB0aXZlIHJlcG9ydA0KDQpgYGB7cn0NCmlmZWxzZSghZGlyLmV4aXN0cygicmVzdWx0cyIpLCBkaXIuY3JlYXRlKCJyZXN1bHRzIiksIEZBTFNFKQ0KDQpgYGANCg0KYGBge3J9DQpwcmludDAxUmVwb3J0KG15ZGF0YV9NNCwgbW9kZWxuYW1lID0gIi4vcmVzdWx0cy9yZXN1bHRzX000IikgIyBjcmVhdGUgZmlsZSB3aXRoIHJlcG9ydCBpbiByZXN1bHRzIGZvbGRlciANCmBgYA0KDQojIyMgLS0tU3RlcCAyOiBNYWtlIGVmZmVjdHMgb2JqZWN0L3N0cnVjdHVyZQ0KDQpgYGB7ciBSU2llbmEgbXllZmYgTTR9DQoNCiMgZGVmaW5lIGVmZmVjdHMgc3RydWN0dXJlIA0KbXllZmZfTTQgPC0gZ2V0RWZmZWN0cyhteWRhdGFfTTQpDQoNCmBgYA0KDQojIyMgLS0tU3RlcCAzOiBBZGQgRWZmZWN0cw0KDQpgYGB7ciBlZmZlY3RzIE00fQ0KDQpteWVmZl9NNCA8LSBpbmNsdWRlRWZmZWN0cyhteWVmZl9NNCwgaXNvbGF0ZU5ldCwgaW5Qb3AsIG91dEFjdCkgIyBtb2RlbCAxDQoNCm15ZWZmX000IDwtIGluY2x1ZGVFZmZlY3RzKG15ZWZmX000LCBlZ29YLCBhbHRYLCBkaWZmWFRyYW5zVHJpcCwgc2FtZVgsIGludGVyYWN0aW9uMSA9ICJnZW5kZXJfUlMiKSAjbW9kZWwgMg0KDQpteWVmZl9NNCA8LSBpbmNsdWRlRWZmZWN0cyhteWVmZl9NNCwgZWdvWCwgYWx0WCwgc2FtZVgsIGludGVyYWN0aW9uMSA9ICJkZXBhcnRtX1JTIikgI21vZGVsIDMNCiAgDQpteWVmZl9NNCA8LSBpbmNsdWRlRWZmZWN0cyhteWVmZl9NNCwgZWdvWCwgYWx0WCwgaW5Qb3BYLCBpbnRlcmFjdGlvbjEgPSAiaF9pbmRleF9SUyIpICMgbW9kZWwgNA0KDQpgYGANCg0KYGBgez1odG1sfQ0KPCEtLQ0KIyBpc29sYXRlbmV0OiBpZiBpbmRpdmlkdWFsIGlzIGFsb25lIHRoZXkgImxpa2UgdG8vdGVuZCB0byBzdGF5IGFsb25lIg0KIyBpblBvcDogcHBsIGxpa2UgdG8gY29sbGFiIHdpdGggcGVvcGxlIHdobyBhcmUgcG9wdWxhcg0KDQojIHNhbWVYDQojIHNhbWUgY292YXJpYXRlLCB3aGljaCBjYW4gYWxzbyBiZSBjYWxsZWQgY292YXJpYXRlLXJlbGF0ZWQgaWRlbnRpdHkgKHNhbWVYKSwgZGVmaW5lZCBieSB0aGUgbnVtYmVyIG9mIHRpZXMgb2YgaSB0byBhbGwgb3RoZXIgYWN0b3JzIGogd2hvIGhhdmUgZXhhY3RseSB0aGUgc2FtZSB2YWx1ZSBvbiB0aGUgY292YXJpYXRlLCBzIG5ldCBpOTUoeCkgPSBQIGp4aWogSXt2aSA9IHZqfSwNCiMgd2hlcmUgdGhlIGluZGljYXRvciBmdW5jdGlvbiBJe3ZpID0gdmp9IGlzIDEgaWYgdGhlIGNvbmRpdGlvbiB7dmkgPSB2an0gaXMgc2F0aXNmaWVkLCBhbmQgMCBpZiBpdCBpcyBub3Q7DQoNCiMgbG9vayB1cCBpblBvcFg6IHByZWZlcmVudGlhbCBhdHRhY2htZW50IChjZi4gS29lbiBsZWwpLCBoaWdoZXIgaC1pbmRleCBtb3JlIHBvcHVsYXIgDQogICMgY2YuIEZyaWRhcyBtb2RlbGluZyBwcm9jZXNzIChKb2NoZW0gdG9sZCBoZXIgdGhhdCApDQoNCi0tPg0KYGBgDQojIyMgLS0tU3RlcCA0OiBTcGVjaWZ5IG1vZGVsL2FsZ29yaXRobQ0KDQpgYGB7ciBhbGdvIE00fQ0KDQpteUFsZ29yaXRobV9NNCA8LSBzaWVuYUFsZ29yaXRobUNyZWF0ZSAocHJvam5hbWUgPSAicmVzdWx0c19NNCIpDQoNCmBgYA0KDQojIyMgLS0tU3RlcCA1OiBFc3RpbWF0ZSBtb2RlbA0KDQpgYGB7ciBlc3RpbWF0ZSBNNCwgZXZhbCA9RkFMU0V9DQojIGVzdGltYXRlIHRoZSBtb2RlbCANCk1vZGVsNCA8LSBzaWVuYTA3KG15QWxnb3JpdGhtX000LCBkYXRhID0gbXlkYXRhX000LCBlZmZlY3RzID0gbXllZmZfTTQsIHJldHVybkRlcHMgPSBUUlVFKQ0KTW9kZWw0DQoNCiNmc2F2ZShNb2RlbDQsIGZpbGUgPSJlc3RpbWF0ZWRfTTQiKQ0KDQpgYGANCg0KYGBge3IgbG9hZCBNNCBvdXRwdXQsIGVjaG89RkFMU0V9DQoNCk1vZGVsNCA8LSBmbG9hZCgiLi9kYXRhL3Byb2Nlc3NlZC9lc3RpbWF0ZWRfTTRfMjAyNDExMjMucmRhIikNCk1vZGVsNA0KDQpgYGANCg0KIyMjIC0tLVN0ZXAgNjogR09GIC0gR29vZG5lc3Mgb2YgRml0DQoNCmBgYHtyIEdPRiBNNH0NCkdPRl9NNCA8LSBzaWVuYUdPRihNb2RlbDQsIEluZGVncmVlRGlzdHJpYnV0aW9uLCB2ZXJib3NlID0gRkFMU0UsIGpvaW4gPSBUUlVFLCB2YXJOYW1lID0gIm5ldHMiKQ0KDQpwbG90KEdPRl9NNCwgbWFpbiA9ICJHT0YgLSBNb2RlbCA0IFxuIEluZGVncmVlIERpc3RyaWJ1dGlvbiIpDQpgYGANCg==</div>


</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->
<script>
$(document).ready(function () {
  window.initializeSourceEmbed("modelestimate.Rmd");
  window.initializeCodeFolding("show" === "show");
});
</script>

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
